{
  "version": 3,
  "sources": ["../../zustand/esm/middleware.mjs", "../../zustand/esm/vanilla.mjs", "../../@noble/curves/src/nist.ts", "../../@noble/curves/src/p256.ts", "../../@noble/curves/src/abstract/bls.ts", "../../@noble/curves/src/abstract/tower.ts", "../../@noble/curves/src/bls12-381.ts", "../../viem/account-abstraction/errors/bundler.ts", "../../viem/account-abstraction/errors/userOperation.ts", "../../viem/account-abstraction/utils/errors/getBundlerError.ts", "../../viem/account-abstraction/utils/errors/getUserOperationError.ts", "../../viem/account-abstraction/utils/formatters/userOperationGas.ts", "../../viem/account-abstraction/utils/formatters/userOperationRequest.ts", "../../viem/account-abstraction/actions/paymaster/getPaymasterData.ts", "../../viem/account-abstraction/actions/paymaster/getPaymasterStubData.ts", "../../viem/account-abstraction/actions/bundler/prepareUserOperation.ts", "../../viem/account-abstraction/actions/bundler/estimateUserOperationGas.ts", "../../viem/account-abstraction/actions/bundler/getSupportedEntryPoints.ts", "../../viem/account-abstraction/utils/formatters/userOperation.ts", "../../viem/account-abstraction/actions/bundler/getUserOperation.ts", "../../viem/account-abstraction/utils/formatters/userOperationReceipt.ts", "../../viem/account-abstraction/actions/bundler/getUserOperationReceipt.ts", "../../viem/account-abstraction/actions/bundler/sendUserOperation.ts", "../../viem/account-abstraction/actions/bundler/waitForUserOperationReceipt.ts", "../../viem/account-abstraction/clients/decorators/bundler.ts", "../../viem/account-abstraction/clients/createBundlerClient.ts", "../../viem/account-abstraction/constants/abis.ts", "../../viem/account-abstraction/utils/userOperation/getInitCode.ts", "../../viem/account-abstraction/utils/userOperation/toPackedUserOperation.ts", "../../viem/account-abstraction/utils/userOperation/getUserOperationTypedData.ts", "../../viem/account-abstraction/utils/userOperation/getUserOperationHash.ts", "../../viem/account-abstraction/accounts/toSmartAccount.ts", "../../viem/account-abstraction/constants/address.ts", "../../ox/erc4337/UserOperation.ts", "../../viem/account-abstraction/utils/userOperation/toUserOperation.ts", "../../viem/experimental/erc7821/constants.ts", "../../viem/experimental/erc7821/actions/supportsExecutionMode.ts"],
  "sourcesContent": ["const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === undefined) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === undefined ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === undefined) {\n      connection == null ? undefined : connection.send(action, get());\n      return r;\n    }\n    connection == null ? undefined : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? undefined : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? undefined : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === undefined) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === undefined || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === undefined) {\n              return connection == null ? undefined : connection.init(api.getState());\n            }\n            return connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === undefined) {\n              connection == null ? undefined : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === undefined) {\n                setStateFromDevtools(state);\n                connection == null ? undefined : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === undefined) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? undefined : _a.state;\n            if (!lastComputedState) return;\n            if (store === undefined) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? undefined : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== undefined) f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? undefined : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? undefined : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? undefined : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? undefined : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst persistImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? undefined : _b.call(options, (_a = get()) != null ? _a : configResult)) || undefined;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            const migration = options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n            if (migration instanceof Promise) {\n              return migration.then((result) => [true, result]);\n            }\n            return [true, migration];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, undefined];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? undefined : postRehydrationCallback(stateFromStorage, undefined);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? undefined : postRehydrationCallback(undefined, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? undefined : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n", "const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const api = { setState, getState, getInitialState, subscribe };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\n\nexport { createStore };\n", "/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256, sha384, sha512 } from '@noble/hashes/sha2.js';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\nimport { createHasher, type H2CHasher } from './abstract/hash-to-curve.ts';\nimport { Field } from './abstract/modular.ts';\nimport {\n  mapToCurveSimpleSWU,\n  type WeierstrassOpts,\n  type WeierstrassPointCons,\n} from './abstract/weierstrass.ts';\n\n// p = 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n - 1n\n// a = Fp256.create(BigInt('-3'));\nconst p256_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\n\n// p = 2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n\nconst p384_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt(\n    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'\n  ),\n  n: BigInt(\n    '0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'\n  ),\n  h: BigInt(1),\n  a: BigInt(\n    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc'\n  ),\n  b: BigInt(\n    '0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef'\n  ),\n  Gx: BigInt(\n    '0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'\n  ),\n  Gy: BigInt(\n    '0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'\n  ),\n};\n\n// p = 2n**521n - 1n\nconst p521_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt(\n    '0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n  ),\n  n: BigInt(\n    '0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'\n  ),\n  h: BigInt(1),\n  a: BigInt(\n    '0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc'\n  ),\n  b: BigInt(\n    '0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'\n  ),\n  Gx: BigInt(\n    '0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'\n  ),\n  Gy: BigInt(\n    '0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'\n  ),\n};\n\nconst Fp256 = Field(p256_CURVE.p);\nconst Fp384 = Field(p384_CURVE.p);\nconst Fp521 = Field(p521_CURVE.p);\ntype SwuOpts = {\n  A: bigint;\n  B: bigint;\n  Z: bigint;\n};\nfunction createSWU(Point: WeierstrassPointCons<bigint>, opts: SwuOpts) {\n  const map = mapToCurveSimpleSWU(Point.Fp, opts);\n  return (scalars: bigint[]) => map(scalars[0]);\n}\n\n/** NIST P256 (aka secp256r1, prime256v1) curve, ECDSA and ECDH methods. */\nexport const p256: CurveFnWithCreate = createCurve(\n  { ...p256_CURVE, Fp: Fp256, lowS: false },\n  sha256\n);\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */\nexport const p256_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() => {\n  return createHasher(\n    p256.Point,\n    createSWU(p256.Point, {\n      A: p256_CURVE.a,\n      B: p256_CURVE.b,\n      Z: p256.Point.Fp.create(BigInt('-10')),\n    }),\n    {\n      DST: 'P256_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n      p: p256_CURVE.p,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  );\n})();\n\n// export const p256_oprf: OPRF = createORPF({\n//   name: 'P256-SHA256',\n//   Point: p256.Point,\n//   hash: sha256,\n//   hashToGroup: p256_hasher.hashToCurve,\n//   hashToScalar: p256_hasher.hashToScalar,\n// });\n\n/** NIST P384 (aka secp384r1) curve, ECDSA and ECDH methods. */\nexport const p384: CurveFnWithCreate = createCurve(\n  { ...p384_CURVE, Fp: Fp384, lowS: false },\n  sha384\n);\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */\nexport const p384_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() => {\n  return createHasher(\n    p384.Point,\n    createSWU(p384.Point, {\n      A: p384_CURVE.a,\n      B: p384_CURVE.b,\n      Z: p384.Point.Fp.create(BigInt('-12')),\n    }),\n    {\n      DST: 'P384_XMD:SHA-384_SSWU_RO_',\n      encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',\n      p: p384_CURVE.p,\n      m: 1,\n      k: 192,\n      expand: 'xmd',\n      hash: sha384,\n    }\n  );\n})();\n\n// export const p384_oprf: OPRF = createORPF({\n//   name: 'P384-SHA384',\n//   Point: p384.Point,\n//   hash: sha384,\n//   hashToGroup: p384_hasher.hashToCurve,\n//   hashToScalar: p384_hasher.hashToScalar,\n// });\n\n// const Fn521 = Field(p521_CURVE.n, { allowedScalarLengths: [65, 66] });\n/** NIST P521 (aka secp521r1) curve, ECDSA and ECDH methods. */\nexport const p521: CurveFnWithCreate = createCurve(\n  { ...p521_CURVE, Fp: Fp521, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] },\n  sha512\n);\n\n/** @deprecated use `p256` for consistency with `p256_hasher` */\nexport const secp256r1: typeof p256 = p256;\n/** @deprecated use `p384` for consistency with `p384_hasher` */\nexport const secp384r1: typeof p384 = p384;\n/** @deprecated use `p521` for consistency with `p521_hasher` */\nexport const secp521r1: typeof p521 = p521;\n\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */\nexport const p521_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() => {\n  return createHasher(\n    p521.Point,\n    createSWU(p521.Point, {\n      A: p521_CURVE.a,\n      B: p521_CURVE.b,\n      Z: p521.Point.Fp.create(BigInt('-4')),\n    }),\n    {\n      DST: 'P521_XMD:SHA-512_SSWU_RO_',\n      encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',\n      p: p521_CURVE.p,\n      m: 1,\n      k: 256,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  );\n})();\n\n// export const p521_oprf: OPRF = createORPF({\n//   name: 'P521-SHA512',\n//   Point: p521.Point,\n//   hash: sha512,\n//   hashToGroup: p521_hasher.hashToCurve,\n//   hashToScalar: p521_hasher.hashToScalar, // produces L=98 just like in RFC\n// });\n", "/**\n * NIST secp256r1 aka p256.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type H2CMethod } from './abstract/hash-to-curve.ts';\nimport { p256_hasher, p256 as p256n } from './nist.ts';\n/** @deprecated use `import { p256 } from '@noble/curves/nist.js';` */\nexport const p256: typeof p256n = p256n;\n/** @deprecated use `import { p256 } from '@noble/curves/nist.js';` */\nexport const secp256r1: typeof p256n = p256n;\n/** @deprecated use `import { p256_hasher } from '@noble/curves/nist.js';` */\nexport const hashToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.hashToCurve)();\n/** @deprecated use `import { p256_hasher } from '@noble/curves/nist.js';` */\nexport const encodeToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.encodeToCurve)();\n", "/**\n * BLS != BLS.\n * The file implements BLS (Boneh-Lynn-Shacham) signatures.\n * Used in both BLS (Barreto-Lynn-Scott) and BN (Barreto-Naehrig)\n * families of pairing-friendly curves.\n * Consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\n * Pairing is used to aggregate and verify signatures.\n * There are two modes of operation:\n * - Long signatures:  X-byte keys + 2X-byte sigs (G1 keys + G2 sigs).\n * - Short signatures: 2X-byte keys + X-byte sigs (G2 keys + G1 sigs).\n * @module\n **/\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes,\n  ensureBytes,\n  memoized,\n  randomBytes,\n  type CHash,\n  type Hex,\n  type PrivKey,\n} from '../utils.ts';\nimport { normalizeZ } from './curve.ts';\nimport {\n  createHasher,\n  type H2CHasher,\n  type H2CHashOpts,\n  type H2COpts,\n  type H2CPointConstructor,\n  type htfBasicOpts,\n  type MapToCurve,\n} from './hash-to-curve.ts';\nimport { getMinHashLength, mapHashToField, type IField } from './modular.ts';\nimport type { Fp12, Fp12Bls, Fp2, Fp2Bls, Fp6Bls } from './tower.ts';\nimport {\n  _normFnElement,\n  weierstrassPoints,\n  type CurvePointsRes,\n  type CurvePointsType,\n  type WeierstrassPoint,\n  type WeierstrassPointCons,\n} from './weierstrass.ts';\n\ntype Fp = bigint; // Can be different field?\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\nexport type TwistType = 'multiplicative' | 'divisive';\n\nexport type ShortSignatureCoder<Fp> = {\n  fromBytes(bytes: Uint8Array): WeierstrassPoint<Fp>;\n  fromHex(hex: Hex): WeierstrassPoint<Fp>;\n  toBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n  toHex(point: WeierstrassPoint<Fp>): string;\n  /** @deprecated use `toBytes` */\n  toRawBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n};\n\nexport type SignatureCoder<Fp> = {\n  fromBytes(bytes: Uint8Array): WeierstrassPoint<Fp>;\n  fromHex(hex: Hex): WeierstrassPoint<Fp>;\n  toBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n  toHex(point: WeierstrassPoint<Fp>): string;\n  /** @deprecated use `toBytes` */\n  toRawBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n};\n\nexport type BlsFields = {\n  Fp: IField<Fp>;\n  Fr: IField<bigint>;\n  Fp2: Fp2Bls;\n  Fp6: Fp6Bls;\n  Fp12: Fp12Bls;\n};\n\nexport type PostPrecomputePointAddFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2\n) => { Rx: Fp2; Ry: Fp2; Rz: Fp2 };\nexport type PostPrecomputeFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2,\n  pointAdd: PostPrecomputePointAddFn\n) => void;\nexport type BlsPairing = {\n  Fp12: Fp12Bls;\n  calcPairingPrecomputes: (p: WeierstrassPoint<Fp2>) => Precompute;\n  millerLoopBatch: (pairs: [Precompute, Fp, Fp][]) => Fp12;\n  pairing: (P: WeierstrassPoint<Fp>, Q: WeierstrassPoint<Fp2>, withFinalExponent?: boolean) => Fp12;\n  pairingBatch: (\n    pairs: { g1: WeierstrassPoint<Fp>; g2: WeierstrassPoint<Fp2> }[],\n    withFinalExponent?: boolean\n  ) => Fp12;\n};\n// TODO: replace CurveType with this? It doesn't contain r however and has postPrecompute\nexport type BlsPairingParams = {\n  // NOTE: MSB is always ignored and used as marker for length,\n  // otherwise leading zeros will be lost.\n  // Can be different from 'X' (seed) param!\n  ateLoopSize: bigint;\n  xNegative: boolean;\n  twistType: TwistType; // BLS12-381: Multiplicative, BN254: Divisive\n  // This is super ugly hack for untwist point in BN254 after miller loop\n  postPrecompute?: PostPrecomputeFn;\n};\nexport type CurveType = {\n  G1: CurvePointsType<Fp> & {\n    ShortSignature: SignatureCoder<Fp>;\n    mapToCurve: MapToCurve<Fp>;\n    htfDefaults: H2COpts;\n  };\n  G2: CurvePointsType<Fp2> & {\n    Signature: SignatureCoder<Fp2>;\n    mapToCurve: MapToCurve<Fp2>;\n    htfDefaults: H2COpts;\n  };\n  fields: BlsFields;\n  params: {\n    // NOTE: MSB is always ignored and used as marker for length,\n    // otherwise leading zeros will be lost.\n    // Can be different from 'X' (seed) param!\n    ateLoopSize: BlsPairingParams['ateLoopSize'];\n    xNegative: BlsPairingParams['xNegative'];\n    r: bigint; // TODO: remove\n    twistType: BlsPairingParams['twistType']; // BLS12-381: Multiplicative, BN254: Divisive\n  };\n  htfDefaults: H2COpts;\n  hash: CHash; // Because we need outputLen for DRBG\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n  // This is super ugly hack for untwist point in BN254 after miller loop\n  postPrecompute?: PostPrecomputeFn;\n};\n\ntype PrecomputeSingle = [Fp2, Fp2, Fp2][];\ntype Precompute = PrecomputeSingle[];\n\n/**\n * BLS consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n */\nexport interface BLSCurvePair {\n  longSignatures: BLSSigs<bigint, Fp2>;\n  shortSignatures: BLSSigs<Fp2, bigint>;\n  millerLoopBatch: BlsPairing['millerLoopBatch'];\n  pairing: BlsPairing['pairing'];\n  pairingBatch: BlsPairing['pairingBatch'];\n  G1: { Point: WeierstrassPointCons<bigint> } & H2CHasher<Fp>;\n  G2: { Point: WeierstrassPointCons<Fp2> } & H2CHasher<Fp2>;\n  fields: {\n    Fp: IField<Fp>;\n    Fp2: Fp2Bls;\n    Fp6: Fp6Bls;\n    Fp12: Fp12Bls;\n    Fr: IField<bigint>;\n  };\n  utils: {\n    randomSecretKey: () => Uint8Array;\n    /** @deprecated use randomSecretKey */\n    randomPrivateKey: () => Uint8Array;\n    calcPairingPrecomputes: BlsPairing['calcPairingPrecomputes'];\n  };\n}\n\nexport type CurveFn = BLSCurvePair & {\n  /** @deprecated use `longSignatures.getPublicKey` */\n  getPublicKey: (secretKey: PrivKey) => Uint8Array;\n  /** @deprecated use `shortSignatures.getPublicKey` */\n  getPublicKeyForShortSignatures: (secretKey: PrivKey) => Uint8Array;\n  /** @deprecated use `longSignatures.sign` */\n  sign: {\n    (message: Hex, secretKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (\n      message: WeierstrassPoint<Fp2>,\n      secretKey: PrivKey,\n      htfOpts?: htfBasicOpts\n    ): WeierstrassPoint<Fp2>;\n  };\n  /** @deprecated use `shortSignatures.sign` */\n  signShortSignature: {\n    (message: Hex, secretKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (\n      message: WeierstrassPoint<Fp>,\n      secretKey: PrivKey,\n      htfOpts?: htfBasicOpts\n    ): WeierstrassPoint<Fp>;\n  };\n  /** @deprecated use `longSignatures.verify` */\n  verify: (\n    signature: Hex | WeierstrassPoint<Fp2>,\n    message: Hex | WeierstrassPoint<Fp2>,\n    publicKey: Hex | WeierstrassPoint<Fp>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  /** @deprecated use `shortSignatures.verify` */\n  verifyShortSignature: (\n    signature: Hex | WeierstrassPoint<Fp>,\n    message: Hex | WeierstrassPoint<Fp>,\n    publicKey: Hex | WeierstrassPoint<Fp2>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  verifyBatch: (\n    signature: Hex | WeierstrassPoint<Fp2>,\n    messages: (Hex | WeierstrassPoint<Fp2>)[],\n    publicKeys: (Hex | WeierstrassPoint<Fp>)[],\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  /** @deprecated use `longSignatures.aggregatePublicKeys` */\n  aggregatePublicKeys: {\n    (publicKeys: Hex[]): Uint8Array;\n    (publicKeys: WeierstrassPoint<Fp>[]): WeierstrassPoint<Fp>;\n  };\n  /** @deprecated use `longSignatures.aggregateSignatures` */\n  aggregateSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: WeierstrassPoint<Fp2>[]): WeierstrassPoint<Fp2>;\n  };\n  /** @deprecated use `shortSignatures.aggregateSignatures` */\n  aggregateShortSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: WeierstrassPoint<Fp>[]): WeierstrassPoint<Fp>;\n  };\n  G1: CurvePointsRes<Fp> & H2CHasher<Fp>;\n  G2: CurvePointsRes<Fp2> & H2CHasher<Fp2>;\n  /** @deprecated use `longSignatures.Signature` */\n  Signature: SignatureCoder<Fp2>;\n  /** @deprecated use `shortSignatures.Signature` */\n  ShortSignature: ShortSignatureCoder<Fp>;\n  params: {\n    ateLoopSize: bigint;\n    r: bigint;\n    twistType: TwistType;\n    /** @deprecated */\n    G1b: bigint;\n    /** @deprecated */\n    G2b: Fp2;\n  };\n};\n\ntype BLSInput = Hex | Uint8Array;\nexport interface BLSSigs<P, S> {\n  getPublicKey(secretKey: PrivKey): WeierstrassPoint<P>;\n  sign(hashedMessage: WeierstrassPoint<S>, secretKey: PrivKey): WeierstrassPoint<S>;\n  verify(\n    signature: WeierstrassPoint<S> | BLSInput,\n    message: WeierstrassPoint<S>,\n    publicKey: WeierstrassPoint<P> | BLSInput\n  ): boolean;\n  verifyBatch: (\n    signature: WeierstrassPoint<S> | BLSInput,\n    messages: WeierstrassPoint<S>[],\n    publicKeys: (WeierstrassPoint<P> | BLSInput)[]\n  ) => boolean;\n  aggregatePublicKeys(publicKeys: (WeierstrassPoint<P> | BLSInput)[]): WeierstrassPoint<P>;\n  aggregateSignatures(signatures: (WeierstrassPoint<S> | BLSInput)[]): WeierstrassPoint<S>;\n  hash(message: Uint8Array, DST?: string | Uint8Array, hashOpts?: H2CHashOpts): WeierstrassPoint<S>;\n  Signature: SignatureCoder<S>;\n}\n\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a: bigint) {\n  const res = [];\n  // a>1 because of marker bit\n  for (; a > _1n; a >>= _1n) {\n    if ((a & _1n) === _0n) res.unshift(0);\n    else if ((a & _3n) === _3n) {\n      res.unshift(-1);\n      a += _1n;\n    } else res.unshift(1);\n  }\n  return res;\n}\n\nfunction aNonEmpty(arr: any[]) {\n  if (!Array.isArray(arr) || arr.length === 0) throw new Error('expected non-empty array');\n}\n\n// This should be enough for bn254, no need to export full stuff?\nfunction createBlsPairing(\n  fields: BlsFields,\n  G1: WeierstrassPointCons<Fp>,\n  G2: WeierstrassPointCons<Fp2>,\n  params: BlsPairingParams\n): BlsPairing {\n  const { Fp2, Fp12 } = fields;\n  const { twistType, ateLoopSize, xNegative, postPrecompute } = params;\n  type G1 = typeof G1.BASE;\n  type G2 = typeof G2.BASE;\n  // Applies sparse multiplication as line function\n  let lineFunction: (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) => Fp12;\n  if (twistType === 'multiplicative') {\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n  } else if (twistType === 'divisive') {\n    // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n    // precompute calculations.\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n  } else throw new Error('bls: unknown twist type');\n\n  const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n  function pointDouble(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2) {\n    const t0 = Fp2.sqr(Ry); // Ry²\n    const t1 = Fp2.sqr(Rz); // Rz²\n    const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n    const t3 = Fp2.mul(t2, _3n); // 3 * T2\n    const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n    const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n    const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n    const c2 = Fp2.neg(t4); // -T4 (-h)\n\n    ell.push([c0, c1, c2]);\n\n    Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n    Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n    Rz = Fp2.mul(t0, t4); // T0 * T4\n    return { Rx, Ry, Rz };\n  }\n  function pointAdd(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2, Qx: Fp2, Qy: Fp2) {\n    // Addition\n    const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n    const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n    const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n    const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n    const c2 = t1; // == Rx - Qx * Rz\n\n    ell.push([c0, c1, c2]);\n\n    const t2 = Fp2.sqr(t1); // T1²\n    const t3 = Fp2.mul(t2, t1); // T2 * T1\n    const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n    const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n    Rx = Fp2.mul(t1, t5); // T1 * T5\n    Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n    Rz = Fp2.mul(Rz, t3); // Rz * T3\n    return { Rx, Ry, Rz };\n  }\n\n  // Pre-compute coefficients for sparse multiplication\n  // Point addition and point double calculations is reused for coefficients\n  // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n  // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n  const ATE_NAF = NAfDecomposition(ateLoopSize);\n\n  const calcPairingPrecomputes = memoized((point: G2) => {\n    const p = point;\n    const { x, y } = p.toAffine();\n    // prettier-ignore\n    const Qx = x, Qy = y, negQy = Fp2.neg(y);\n    // prettier-ignore\n    let Rx = Qx, Ry = Qy, Rz = Fp2.ONE;\n    const ell: Precompute = [];\n    for (const bit of ATE_NAF) {\n      const cur: PrecomputeSingle = [];\n      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));\n      if (bit) ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n      ell.push(cur);\n    }\n    if (postPrecompute) {\n      const last = ell[ell.length - 1];\n      postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n    }\n    return ell;\n  });\n\n  // Main pairing logic is here. Computes product of miller loops + final exponentiate\n  // Applies calculated precomputes\n  type MillerInput = [Precompute, Fp, Fp][];\n  function millerLoopBatch(pairs: MillerInput, withFinalExponent: boolean = false) {\n    let f12 = Fp12.ONE;\n    if (pairs.length) {\n      const ellLen = pairs[0][0].length;\n      for (let i = 0; i < ellLen; i++) {\n        f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n        // NOTE: we apply multiple pairings in parallel here\n        for (const [ell, Px, Py] of pairs) {\n          for (const [c0, c1, c2] of ell[i]) f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n        }\n      }\n    }\n    if (xNegative) f12 = Fp12.conjugate(f12);\n    return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n  }\n  type PairingInput = { g1: G1; g2: G2 };\n  // Calculates product of multiple pairings\n  // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n  function pairingBatch(pairs: PairingInput[], withFinalExponent: boolean = true) {\n    const res: MillerInput = [];\n    // Cache precomputed toAffine for all points\n    normalizeZ(\n      G1,\n      pairs.map(({ g1 }) => g1)\n    );\n    normalizeZ(\n      G2,\n      pairs.map(({ g2 }) => g2)\n    );\n    for (const { g1, g2 } of pairs) {\n      if (g1.is0() || g2.is0()) throw new Error('pairing is not available for ZERO point');\n      // This uses toAffine inside\n      g1.assertValidity();\n      g2.assertValidity();\n      const Qa = g1.toAffine();\n      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n    }\n    return millerLoopBatch(res, withFinalExponent);\n  }\n  // Calculates bilinear pairing\n  function pairing(Q: G1, P: G2, withFinalExponent: boolean = true): Fp12 {\n    return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);\n  }\n  return {\n    Fp12, // NOTE: we re-export Fp12 here because pairing results are Fp12!\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    calcPairingPrecomputes,\n  };\n}\n\nfunction createBlsSig<P, S>(\n  blsPairing: BlsPairing,\n  PubCurve: CurvePointsRes<P> & H2CHasher<P>,\n  SigCurve: CurvePointsRes<S> & H2CHasher<S>,\n  SignatureCoder: SignatureCoder<S>,\n  isSigG1: boolean\n): BLSSigs<P, S> {\n  const { Fp12, pairingBatch } = blsPairing;\n  type PubPoint = WeierstrassPoint<P>;\n  type SigPoint = WeierstrassPoint<S>;\n  function normPub(point: PubPoint | BLSInput): PubPoint {\n    return point instanceof PubCurve.Point ? (point as PubPoint) : PubCurve.Point.fromHex(point);\n  }\n  function normSig(point: SigPoint | BLSInput): SigPoint {\n    return point instanceof SigCurve.Point ? (point as SigPoint) : SigCurve.Point.fromHex(point);\n  }\n  function amsg(m: unknown): SigPoint {\n    if (!(m instanceof SigCurve.Point))\n      throw new Error(`expected valid message hashed to ${!isSigG1 ? 'G2' : 'G1'} curve`);\n    return m as SigPoint;\n  }\n\n  type G1 = CurvePointsRes<Fp>['Point']['BASE'];\n  type G2 = CurvePointsRes<Fp2>['Point']['BASE'];\n  type PairingInput = { g1: G1; g2: G2 };\n  // What matters here is what point pairing API accepts as G1 or G2, not actual size or names\n  const pair: (a: PubPoint, b: SigPoint) => PairingInput = !isSigG1\n    ? (a: PubPoint, b: SigPoint) => ({ g1: a, g2: b }) as PairingInput\n    : (a: PubPoint, b: SigPoint) => ({ g1: b, g2: a }) as PairingInput;\n  return {\n    // P = pk x G\n    getPublicKey(secretKey: PrivKey): PubPoint {\n      // TODO: replace with\n      // const sec = PubCurve.Point.Fn.fromBytes(secretKey);\n      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);\n      return PubCurve.Point.BASE.multiply(sec);\n    },\n    // S = pk x H(m)\n    sign(message: SigPoint, secretKey: PrivKey, unusedArg?: any): SigPoint {\n      if (unusedArg != null) throw new Error('sign() expects 2 arguments');\n      // TODO: replace with\n      // PubCurve.Point.Fn.fromBytes(secretKey)\n      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);\n      amsg(message).assertValidity();\n      return message.multiply(sec);\n    },\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(P, H(m)) == e(G, S)\n    // e(S, G) == e(H(m), P)\n    verify(\n      signature: SigPoint | BLSInput,\n      message: SigPoint,\n      publicKey: PubPoint | BLSInput,\n      unusedArg?: any\n    ): boolean {\n      if (unusedArg != null) throw new Error('verify() expects 3 arguments');\n      signature = normSig(signature);\n      publicKey = normPub(publicKey);\n      const P = publicKey.negate();\n      const G = PubCurve.Point.BASE;\n      const Hm = amsg(message);\n      const S = signature;\n      // This code was changed in 1.9.x:\n      // Before it was G.negate() in G2, now it's always pubKey.negate\n      // e(P, -Q)===e(-P, Q)==e(P, Q)^-1. Negate can be done anywhere (as long it is done once per pair).\n      // We just moving sign, but since pairing is multiplicative, we doing X * X^-1 = 1\n      const exp = pairingBatch([pair(P, Hm), pair(G, S)]);\n      return Fp12.eql(exp, Fp12.ONE);\n    },\n    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n    verifyBatch(\n      signature: SigPoint | BLSInput,\n      messages: SigPoint[],\n      publicKeys: (PubPoint | BLSInput)[]\n    ): boolean {\n      aNonEmpty(messages);\n      if (publicKeys.length !== messages.length)\n        throw new Error('amount of public keys and messages should be equal');\n      const sig = normSig(signature);\n      const nMessages = messages;\n      const nPublicKeys = publicKeys.map(normPub);\n      // NOTE: this works only for exact same object\n      const messagePubKeyMap = new Map<SigPoint, PubPoint[]>();\n      for (let i = 0; i < nPublicKeys.length; i++) {\n        const pub = nPublicKeys[i];\n        const msg = nMessages[i];\n        let keys = messagePubKeyMap.get(msg);\n        if (keys === undefined) {\n          keys = [];\n          messagePubKeyMap.set(msg, keys);\n        }\n        keys.push(pub);\n      }\n      const paired = [];\n      const G = PubCurve.Point.BASE;\n      try {\n        for (const [msg, keys] of messagePubKeyMap) {\n          const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n          paired.push(pair(groupPublicKey, msg));\n        }\n        paired.push(pair(G.negate(), sig));\n        return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n      } catch {\n        return false;\n      }\n    },\n    // Adds a bunch of public key points together.\n    // pk1 + pk2 + pk3 = pkA\n    aggregatePublicKeys(publicKeys: (PubPoint | BLSInput)[]): PubPoint {\n      aNonEmpty(publicKeys);\n      publicKeys = publicKeys.map((pub) => normPub(pub));\n      const agg = (publicKeys as PubPoint[]).reduce((sum, p) => sum.add(p), PubCurve.Point.ZERO);\n      agg.assertValidity();\n      return agg;\n    },\n\n    // Adds a bunch of signature points together.\n    // pk1 + pk2 + pk3 = pkA\n    aggregateSignatures(signatures: (SigPoint | BLSInput)[]): SigPoint {\n      aNonEmpty(signatures);\n      signatures = signatures.map((sig) => normSig(sig));\n      const agg = (signatures as SigPoint[]).reduce((sum, s) => sum.add(s), SigCurve.Point.ZERO);\n      agg.assertValidity();\n      return agg;\n    },\n\n    hash(messageBytes: Uint8Array, DST?: string | Uint8Array): SigPoint {\n      abytes(messageBytes);\n      const opts = DST ? { DST } : undefined;\n      return SigCurve.hashToCurve(messageBytes, opts) as SigPoint;\n    },\n    Signature: SignatureCoder,\n  };\n}\n\n// G1_Point: ProjConstructor<bigint>, G2_Point: ProjConstructor<Fp2>,\nexport function bls(CURVE: CurveType): CurveFn {\n  // Fields are specific for curve, so for now we'll need to pass them with opts\n  const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n  // Point on G1 curve: (x, y)\n  const G1_ = weierstrassPoints(CURVE.G1);\n  const G1 = Object.assign(\n    G1_,\n    createHasher(G1_.Point, CURVE.G1.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G1.htfDefaults,\n    })\n  );\n  // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n  const G2_ = weierstrassPoints(CURVE.G2);\n  const G2 = Object.assign(\n    G2_,\n    createHasher(G2_.Point as H2CPointConstructor<Fp2>, CURVE.G2.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G2.htfDefaults,\n    })\n  );\n  type G1 = typeof G1.Point.BASE;\n  type G2 = typeof G2.Point.BASE;\n\n  const pairingRes = createBlsPairing(CURVE.fields, G1.Point, G2.Point, {\n    ...CURVE.params,\n    postPrecompute: CURVE.postPrecompute,\n  });\n\n  const { millerLoopBatch, pairing, pairingBatch, calcPairingPrecomputes } = pairingRes;\n  const longSignatures = createBlsSig(pairingRes, G1, G2, CURVE.G2.Signature, false);\n  const shortSignatures = createBlsSig(pairingRes, G2, G1, CURVE.G1.ShortSignature, true);\n\n  const rand = CURVE.randomBytes || randomBytes;\n  const randomSecretKey = (): Uint8Array => {\n    const length = getMinHashLength(Fr.ORDER);\n    return mapHashToField(rand(length), Fr.ORDER);\n  };\n  const utils = {\n    randomSecretKey,\n    randomPrivateKey: randomSecretKey,\n    calcPairingPrecomputes,\n  };\n\n  // LEGACY code\n  type G1Hex = Hex | G1;\n  type G2Hex = Hex | G2;\n\n  const { ShortSignature } = CURVE.G1;\n  const { Signature } = CURVE.G2;\n\n  function normP1Hash(point: G1Hex, htfOpts?: htfBasicOpts): G1 {\n    return point instanceof G1.Point\n      ? point\n      : shortSignatures.hash(ensureBytes('point', point), htfOpts?.DST);\n  }\n  function normP2Hash(point: G2Hex, htfOpts?: htfBasicOpts): G2 {\n    return point instanceof G2.Point\n      ? point\n      : longSignatures.hash(ensureBytes('point', point), htfOpts?.DST);\n  }\n\n  function getPublicKey(privateKey: PrivKey): Uint8Array {\n    return longSignatures.getPublicKey(privateKey).toBytes(true);\n  }\n  function getPublicKeyForShortSignatures(privateKey: PrivKey): Uint8Array {\n    return shortSignatures.getPublicKey(privateKey).toBytes(true);\n  }\n  function sign(message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n  function sign(message: G2, privateKey: PrivKey, htfOpts?: htfBasicOpts): G2;\n  function sign(message: G2Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array | G2 {\n    const Hm = normP2Hash(message, htfOpts);\n    const S = longSignatures.sign(Hm, privateKey);\n    return message instanceof G2.Point ? S : Signature.toBytes(S);\n  }\n  function signShortSignature(\n    message: Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array;\n  function signShortSignature(message: G1, privateKey: PrivKey, htfOpts?: htfBasicOpts): G1;\n  function signShortSignature(\n    message: G1Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array | G1 {\n    const Hm = normP1Hash(message, htfOpts);\n    const S = shortSignatures.sign(Hm, privateKey);\n    return message instanceof G1.Point ? S : ShortSignature.toBytes(S);\n  }\n  function verify(\n    signature: G2Hex,\n    message: G2Hex,\n    publicKey: G1Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = normP2Hash(message, htfOpts);\n    return longSignatures.verify(signature, Hm, publicKey);\n  }\n  function verifyShortSignature(\n    signature: G1Hex,\n    message: G1Hex,\n    publicKey: G2Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = normP1Hash(message, htfOpts);\n    return shortSignatures.verify(signature, Hm, publicKey);\n  }\n  function aggregatePublicKeys(publicKeys: Hex[]): Uint8Array;\n  function aggregatePublicKeys(publicKeys: G1[]): G1;\n  function aggregatePublicKeys(publicKeys: G1Hex[]): Uint8Array | G1 {\n    const agg = longSignatures.aggregatePublicKeys(publicKeys);\n    return publicKeys[0] instanceof G1.Point ? agg : agg.toBytes(true);\n  }\n  function aggregateSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateSignatures(signatures: G2[]): G2;\n  function aggregateSignatures(signatures: G2Hex[]): Uint8Array | G2 {\n    const agg = longSignatures.aggregateSignatures(signatures);\n    return signatures[0] instanceof G2.Point ? agg : Signature.toBytes(agg);\n  }\n  function aggregateShortSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateShortSignatures(signatures: G1[]): G1;\n  function aggregateShortSignatures(signatures: G1Hex[]): Uint8Array | G1 {\n    const agg = shortSignatures.aggregateSignatures(signatures);\n    return signatures[0] instanceof G1.Point ? agg : ShortSignature.toBytes(agg);\n  }\n  function verifyBatch(\n    signature: G2Hex,\n    messages: G2Hex[],\n    publicKeys: G1Hex[],\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = messages.map((m) => normP2Hash(m, htfOpts));\n    return longSignatures.verifyBatch(signature, Hm, publicKeys);\n  }\n\n  G1.Point.BASE.precompute(4);\n\n  return {\n    longSignatures,\n    shortSignatures,\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    verifyBatch,\n    fields: {\n      Fr,\n      Fp,\n      Fp2,\n      Fp6,\n      Fp12,\n    },\n    params: {\n      ateLoopSize: CURVE.params.ateLoopSize,\n      twistType: CURVE.params.twistType,\n      // deprecated\n      r: CURVE.params.r,\n      G1b: CURVE.G1.b,\n      G2b: CURVE.G2.b,\n    },\n    utils,\n\n    // deprecated\n    getPublicKey,\n    getPublicKeyForShortSignatures,\n    sign,\n    signShortSignature,\n    verify,\n    verifyShortSignature,\n    aggregatePublicKeys,\n    aggregateSignatures,\n    aggregateShortSignatures,\n    G1,\n    G2,\n    Signature,\n    ShortSignature,\n  };\n}\n", "/**\n * Towered extension fields.\n * Rather than implementing a massive 12th-degree extension directly, it is more efficient\n * to build it up from smaller extensions: a tower of extensions.\n *\n * For BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\n * on top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\n *\n * For more info: \"Pairings for beginners\" by Costello, section 7.3.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitGet, bitLen, concatBytes, notImplemented } from '../utils.ts';\nimport * as mod from './modular.ts';\nimport type { WeierstrassPoint, WeierstrassPointCons } from './weierstrass.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\n// Fp₂ over complex plane\nexport type BigintTuple = [bigint, bigint];\nexport type Fp = bigint;\n// Finite extension field over irreducible polynominal.\n// Fp(u) / (u² - β) where β = -1\nexport type Fp2 = { c0: bigint; c1: bigint };\nexport type BigintSix = [bigint, bigint, bigint, bigint, bigint, bigint];\nexport type Fp6 = { c0: Fp2; c1: Fp2; c2: Fp2 };\nexport type Fp12 = { c0: Fp6; c1: Fp6 }; // Fp₁₂ = Fp₆² => Fp₂³, Fp₆(w) / (w² - γ) where γ = v\n// prettier-ignore\nexport type BigintTwelve = [\n  bigint, bigint, bigint, bigint, bigint, bigint,\n  bigint, bigint, bigint, bigint, bigint, bigint\n];\n\nexport type Fp2Bls = mod.IField<Fp2> & {\n  Fp: mod.IField<Fp>;\n  frobeniusMap(num: Fp2, power: number): Fp2;\n  fromBigTuple(num: BigintTuple): Fp2;\n  mulByB: (num: Fp2) => Fp2;\n  mulByNonresidue: (num: Fp2) => Fp2;\n  reim: (num: Fp2) => { re: Fp; im: Fp };\n  Fp4Square: (a: Fp2, b: Fp2) => { first: Fp2; second: Fp2 };\n  NONRESIDUE: Fp2;\n};\n\nexport type Fp6Bls = mod.IField<Fp6> & {\n  Fp2: Fp2Bls;\n  frobeniusMap(num: Fp6, power: number): Fp6;\n  fromBigSix: (tuple: BigintSix) => Fp6;\n  mul1(num: Fp6, b1: Fp2): Fp6;\n  mul01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\n  mulByFp2(lhs: Fp6, rhs: Fp2): Fp6;\n  mulByNonresidue: (num: Fp6) => Fp6;\n};\n\nexport type Fp12Bls = mod.IField<Fp12> & {\n  Fp6: Fp6Bls;\n  frobeniusMap(num: Fp12, power: number): Fp12;\n  fromBigTwelve: (t: BigintTwelve) => Fp12;\n  mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n  mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n  mulByFp2(lhs: Fp12, rhs: Fp2): Fp12;\n  conjugate(num: Fp12): Fp12;\n  finalExponentiate(num: Fp12): Fp12;\n  _cyclotomicSquare(num: Fp12): Fp12;\n  _cyclotomicExp(num: Fp12, n: bigint): Fp12;\n};\n\nfunction calcFrobeniusCoefficients<T>(\n  Fp: mod.IField<T>,\n  nonResidue: T,\n  modulus: bigint,\n  degree: number,\n  num: number = 1,\n  divisor?: number\n) {\n  const _divisor = BigInt(divisor === undefined ? degree : divisor);\n  const towerModulus: any = modulus ** BigInt(degree);\n  const res: T[][] = [];\n  for (let i = 0; i < num; i++) {\n    const a = BigInt(i + 1);\n    const powers: T[] = [];\n    for (let j = 0, qPower = _1n; j < degree; j++) {\n      const power = ((a * qPower - a) / _divisor) % towerModulus;\n      powers.push(Fp.pow(nonResidue, power));\n      qPower *= modulus;\n    }\n    res.push(powers);\n  }\n  return res;\n}\n\n// This works same at least for bls12-381, bn254 and bls12-377\nexport function psiFrobenius(\n  Fp: mod.IField<Fp>,\n  Fp2: Fp2Bls,\n  base: Fp2\n): {\n  psi: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  psi2: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  G2psi: (c: WeierstrassPointCons<Fp2>, P: WeierstrassPoint<Fp2>) => WeierstrassPoint<Fp2>;\n  G2psi2: (c: WeierstrassPointCons<Fp2>, P: WeierstrassPoint<Fp2>) => WeierstrassPoint<Fp2>;\n  PSI_X: Fp2;\n  PSI_Y: Fp2;\n  PSI2_X: Fp2;\n  PSI2_Y: Fp2;\n} {\n  // GLV endomorphism Ψ(P)\n  const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\n  const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\n  function psi(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    // This x10 faster than previous version in bls12-381\n    const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\n    const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\n    return [x2, y2];\n  }\n  // Ψ²(P) endomorphism (psi2(x) = psi(psi(x)))\n  const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\n  // This equals -1, which causes y to be Fp2.neg(y).\n  // But not sure if there are case when this is not true?\n  const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\n  if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE))) throw new Error('psiFrobenius: PSI2_Y!==-1');\n  function psi2(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];\n  }\n  // Map points\n  const mapAffine =\n    <T>(fn: (x: T, y: T) => [T, T]) =>\n    (c: WeierstrassPointCons<T>, P: WeierstrassPoint<T>) => {\n      const affine = P.toAffine();\n      const p = fn(affine.x, affine.y);\n      return c.fromAffine({ x: p[0], y: p[1] });\n    };\n  const G2psi = mapAffine(psi);\n  const G2psi2 = mapAffine(psi2);\n  return { psi, psi2, G2psi, G2psi2, PSI_X, PSI_Y, PSI2_X, PSI2_Y };\n}\n\nexport type Tower12Opts = {\n  ORDER: bigint;\n  X_LEN: number;\n  NONRESIDUE?: Fp;\n  FP2_NONRESIDUE: BigintTuple;\n  Fp2sqrt?: (num: Fp2) => Fp2;\n  Fp2mulByB: (num: Fp2) => Fp2;\n  Fp12finalExponentiate: (num: Fp12) => Fp12;\n};\n\nconst Fp2fromBigTuple = (Fp: mod.IField<bigint>, tuple: BigintTuple | bigint[]) => {\n  if (tuple.length !== 2) throw new Error('invalid tuple');\n  const fps = tuple.map((n) => Fp.create(n)) as BigintTuple;\n  return { c0: fps[0], c1: fps[1] };\n};\n\nclass _Field2 implements mod.IField<Fp2> {\n  readonly ORDER: bigint;\n  readonly BITS: number;\n  readonly BYTES: number;\n  readonly isLE: boolean;\n  readonly MASK = _1n;\n\n  readonly ZERO: Fp2;\n  readonly ONE: Fp2;\n  readonly Fp: mod.IField<bigint>;\n\n  readonly NONRESIDUE: Fp2;\n  readonly mulByB: Tower12Opts['Fp2mulByB'];\n  readonly Fp_NONRESIDUE: bigint;\n  readonly Fp_div2: bigint;\n  readonly FROBENIUS_COEFFICIENTS: Fp[];\n\n  constructor(\n    Fp: mod.IField<bigint>,\n    opts: Partial<{\n      NONRESIDUE: bigint;\n      FP2_NONRESIDUE: BigintTuple;\n      Fp2mulByB: Tower12Opts['Fp2mulByB'];\n    }> = {}\n  ) {\n    const ORDER = Fp.ORDER;\n    const FP2_ORDER = ORDER * ORDER;\n    this.Fp = Fp;\n    this.ORDER = FP2_ORDER;\n    this.BITS = bitLen(FP2_ORDER);\n    this.BYTES = Math.ceil(bitLen(FP2_ORDER) / 8);\n    this.isLE = Fp.isLE;\n    this.ZERO = { c0: Fp.ZERO, c1: Fp.ZERO };\n    this.ONE = { c0: Fp.ONE, c1: Fp.ZERO };\n\n    this.Fp_NONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\n    this.Fp_div2 = Fp.div(Fp.ONE, _2n); // 1/2\n    this.NONRESIDUE = Fp2fromBigTuple(Fp, opts.FP2_NONRESIDUE!);\n    // const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\n    this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, this.Fp_NONRESIDUE, Fp.ORDER, 2)[0];\n    this.mulByB = opts.Fp2mulByB!;\n    Object.seal(this);\n  }\n  fromBigTuple(tuple: BigintTuple) {\n    return Fp2fromBigTuple(this.Fp, tuple);\n  }\n  create(num: Fp2) {\n    return num;\n  }\n  isValid({ c0, c1 }: Fp2) {\n    function isValidC(num: bigint, ORDER: bigint) {\n      return typeof num === 'bigint' && _0n <= num && num < ORDER;\n    }\n    return isValidC(c0, this.ORDER) && isValidC(c1, this.ORDER);\n  }\n  is0({ c0, c1 }: Fp2) {\n    return this.Fp.is0(c0) && this.Fp.is0(c1);\n  }\n  isValidNot0(num: Fp2) {\n    return !this.is0(num) && this.isValid(num);\n  }\n  eql({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) {\n    return this.Fp.eql(c0, r0) && this.Fp.eql(c1, r1);\n  }\n  neg({ c0, c1 }: Fp2) {\n    return { c0: this.Fp.neg(c0), c1: this.Fp.neg(c1) };\n  }\n  pow(num: Fp2, power: bigint): Fp2 {\n    return mod.FpPow(this, num, power);\n  }\n  invertBatch(nums: Fp2[]): Fp2[] {\n    return mod.FpInvertBatch(this, nums);\n  }\n  // Normalized\n  add(f1: Fp2, f2: Fp2): Fp2 {\n    const { c0, c1 } = f1;\n    const { c0: r0, c1: r1 } = f2;\n    return {\n      c0: this.Fp.add(c0, r0),\n      c1: this.Fp.add(c1, r1),\n    };\n  }\n  sub({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) {\n    return {\n      c0: this.Fp.sub(c0, r0),\n      c1: this.Fp.sub(c1, r1),\n    };\n  }\n  mul({ c0, c1 }: Fp2, rhs: Fp2) {\n    const { Fp } = this;\n    if (typeof rhs === 'bigint') return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\n    // (a+bi)(c+di) = (ac−bd) + (ad+bc)i\n    const { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp.mul(c0, r0); // c0 * o0\n    let t2 = Fp.mul(c1, r1); // c1 * o1\n    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n    const o0 = Fp.sub(t1, t2);\n    const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n    return { c0: o0, c1: o1 };\n  }\n  sqr({ c0, c1 }: Fp2) {\n    const { Fp } = this;\n    const a = Fp.add(c0, c1);\n    const b = Fp.sub(c0, c1);\n    const c = Fp.add(c0, c0);\n    return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\n  }\n  // NonNormalized stuff\n  addN(a: Fp2, b: Fp2): Fp2 {\n    return this.add(a, b);\n  }\n  subN(a: Fp2, b: Fp2): Fp2 {\n    return this.sub(a, b);\n  }\n  mulN(a: Fp2, b: Fp2): Fp2 {\n    return this.mul(a, b);\n  }\n  sqrN(a: Fp2): Fp2 {\n    return this.sqr(a);\n  }\n  // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n  div(lhs: Fp2, rhs: Fp2): Fp2 {\n    const { Fp } = this;\n    // @ts-ignore\n    return this.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));\n  }\n  inv({ c0: a, c1: b }: Fp2): Fp2 {\n    // We wish to find the multiplicative inverse of a nonzero\n    // element a + bu in Fp2. We leverage an identity\n    //\n    // (a + bu)(a - bu) = a² + b²\n    //\n    // which holds because u² = -1. This can be rewritten as\n    //\n    // (a + bu)(a - bu)/(a² + b²) = 1\n    //\n    // because a² + b² = 0 has no nonzero solutions for (a, b).\n    // This gives that (a - bu)/(a² + b²) is the inverse\n    // of (a + bu). Importantly, this can be computing using\n    // only a single inversion in Fp.\n    const { Fp } = this;\n    const factor = Fp.inv(Fp.create(a * a + b * b));\n    return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\n  }\n  sqrt(num: Fp2) {\n    // This is generic for all quadratic extensions (Fp2)\n    const { Fp } = this;\n    const Fp2 = this;\n    const { c0, c1 } = num;\n    if (Fp.is0(c1)) {\n      // if c0 is quadratic residue\n      if (mod.FpLegendre(Fp, c0) === 1) return Fp2.create({ c0: Fp.sqrt(c0), c1: Fp.ZERO });\n      else return Fp2.create({ c0: Fp.ZERO, c1: Fp.sqrt(Fp.div(c0, this.Fp_NONRESIDUE)) });\n    }\n    const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), this.Fp_NONRESIDUE)));\n    let d = Fp.mul(Fp.add(a, c0), this.Fp_div2);\n    const legendre = mod.FpLegendre(Fp, d);\n    // -1, Quadratic non residue\n    if (legendre === -1) d = Fp.sub(d, a);\n    const a0 = Fp.sqrt(d);\n    const candidateSqrt = Fp2.create({ c0: a0, c1: Fp.div(Fp.mul(c1, this.Fp_div2), a0) });\n    if (!Fp2.eql(Fp2.sqr(candidateSqrt), num)) throw new Error('Cannot find square root');\n    // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\n    const x1 = candidateSqrt;\n    const x2 = Fp2.neg(x1);\n    const { re: re1, im: im1 } = Fp2.reim(x1);\n    const { re: re2, im: im2 } = Fp2.reim(x2);\n    if (im1 > im2 || (im1 === im2 && re1 > re2)) return x1;\n    return x2;\n  }\n  // Same as sgn0_m_eq_2 in RFC 9380\n  isOdd(x: Fp2) {\n    const { re: x0, im: x1 } = this.reim(x);\n    const sign_0 = x0 % _2n;\n    const zero_0 = x0 === _0n;\n    const sign_1 = x1 % _2n;\n    return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\n  }\n  // Bytes util\n  fromBytes(b: Uint8Array): Fp2 {\n    const { Fp } = this;\n    if (b.length !== this.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n    return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\n  }\n  toBytes({ c0, c1 }: Fp2) {\n    return concatBytes(this.Fp.toBytes(c0), this.Fp.toBytes(c1));\n  }\n  cmov({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2, c: boolean) {\n    return {\n      c0: this.Fp.cmov(c0, r0, c),\n      c1: this.Fp.cmov(c1, r1, c),\n    };\n  }\n  reim({ c0, c1 }: Fp2) {\n    return { re: c0, im: c1 };\n  }\n  Fp4Square(a: Fp2, b: Fp2): { first: Fp2; second: Fp2 } {\n    const Fp2 = this;\n    const a2 = Fp2.sqr(a);\n    const b2 = Fp2.sqr(b);\n    return {\n      first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b² * Nonresidue + a²\n      second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b)² - a² - b²\n    };\n  }\n  // multiply by u + 1\n  mulByNonresidue({ c0, c1 }: Fp2) {\n    return this.mul({ c0, c1 }, this.NONRESIDUE);\n  }\n  frobeniusMap({ c0, c1 }: Fp2, power: number): Fp2 {\n    return {\n      c0,\n      c1: this.Fp.mul(c1, this.FROBENIUS_COEFFICIENTS[power % 2]),\n    };\n  }\n}\n\nclass _Field6 implements Fp6Bls {\n  readonly ORDER: bigint;\n  readonly BITS: number;\n  readonly BYTES: number;\n  readonly isLE: boolean;\n  readonly MASK = _1n;\n\n  readonly ZERO: Fp6;\n  readonly ONE: Fp6;\n  readonly Fp2: Fp2Bls;\n  readonly FROBENIUS_COEFFICIENTS_1: Fp2[];\n  readonly FROBENIUS_COEFFICIENTS_2: Fp2[];\n\n  constructor(Fp2: Fp2Bls) {\n    this.Fp2 = Fp2;\n    this.ORDER = Fp2.ORDER; // TODO: unused, but need to verify\n    this.BITS = 3 * Fp2.BITS;\n    this.BYTES = 3 * Fp2.BYTES;\n    this.isLE = Fp2.isLE;\n    this.ZERO = { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO };\n    this.ONE = { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO };\n    const { Fp } = Fp2;\n    const frob = calcFrobeniusCoefficients(Fp2, Fp2.NONRESIDUE, Fp.ORDER, 6, 2, 3);\n    this.FROBENIUS_COEFFICIENTS_1 = frob[0];\n    this.FROBENIUS_COEFFICIENTS_2 = frob[1];\n    Object.seal(this);\n  }\n  add({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.add(c0, r0),\n      c1: Fp2.add(c1, r1),\n      c2: Fp2.add(c2, r2),\n    };\n  }\n  sub({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.sub(c0, r0),\n      c1: Fp2.sub(c1, r1),\n      c2: Fp2.sub(c2, r2),\n    };\n  }\n  mul({ c0, c1, c2 }: Fp6, rhs: Fp6 | bigint) {\n    const { Fp2 } = this;\n    if (typeof rhs === 'bigint') {\n      return {\n        c0: Fp2.mul(c0, rhs),\n        c1: Fp2.mul(c1, rhs),\n        c2: Fp2.mul(c2, rhs),\n      };\n    }\n    const { c0: r0, c1: r1, c2: r2 } = rhs;\n    const t0 = Fp2.mul(c0, r0); // c0 * o0\n    const t1 = Fp2.mul(c1, r1); // c1 * o1\n    const t2 = Fp2.mul(c2, r2); // c2 * o2\n    return {\n      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n      c0: Fp2.add(\n        t0,\n        Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))\n      ),\n      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n      c1: Fp2.add(\n        Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)),\n        Fp2.mulByNonresidue(t2)\n      ),\n      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n      c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\n    };\n  }\n  sqr({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    let t0 = Fp2.sqr(c0); // c0²\n    let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n    let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n    let t4 = Fp2.sqr(c2); // c2²\n    return {\n      c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\n      c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\n      // T1 + (c0 - c1 + c2)² + T3 - T0 - T4\n      c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\n    };\n  }\n  addN(a: Fp6, b: Fp6): Fp6 {\n    return this.add(a, b);\n  }\n  subN(a: Fp6, b: Fp6): Fp6 {\n    return this.sub(a, b);\n  }\n  mulN(a: Fp6, b: Fp6): Fp6 {\n    return this.mul(a, b);\n  }\n  sqrN(a: Fp6): Fp6 {\n    return this.sqr(a);\n  }\n\n  create(num: Fp6) {\n    return num;\n  }\n\n  isValid({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    return Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2);\n  }\n  is0({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    return Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2);\n  }\n  isValidNot0(num: Fp6) {\n    return !this.is0(num) && this.isValid(num);\n  }\n  neg({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    return { c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) };\n  }\n  eql({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) {\n    const { Fp2 } = this;\n    return Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2);\n  }\n  sqrt(_: Fp6) {\n    return notImplemented();\n  }\n  // Do we need division by bigint at all? Should be done via order:\n  div(lhs: Fp6, rhs: Fp6) {\n    const { Fp2 } = this;\n    const { Fp } = Fp2;\n    return this.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));\n  }\n  pow(num: Fp6, power: Fp): Fp6 {\n    return mod.FpPow(this, num, power);\n  }\n  invertBatch(nums: Fp6[]): Fp6[] {\n    return mod.FpInvertBatch(this, nums);\n  }\n\n  inv({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0² - c2 * c1 * (u + 1)\n    let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2² * (u + 1) - c0 * c1\n    let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1² - c0 * c2\n    // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n    let t4 = Fp2.inv(\n      Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0))\n    );\n    return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\n  }\n  // Bytes utils\n  fromBytes(b: Uint8Array): Fp6 {\n    const { Fp2 } = this;\n    if (b.length !== this.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n    const B2 = Fp2.BYTES;\n    return {\n      c0: Fp2.fromBytes(b.subarray(0, B2)),\n      c1: Fp2.fromBytes(b.subarray(B2, B2 * 2)),\n      c2: Fp2.fromBytes(b.subarray(2 * B2)),\n    };\n  }\n  toBytes({ c0, c1, c2 }: Fp6): Uint8Array {\n    const { Fp2 } = this;\n    return concatBytes(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2));\n  }\n  cmov({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6, c: boolean) {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.cmov(c0, r0, c),\n      c1: Fp2.cmov(c1, r1, c),\n      c2: Fp2.cmov(c2, r2, c),\n    };\n  }\n  fromBigSix(t: BigintSix): Fp6 {\n    const { Fp2 } = this;\n    if (!Array.isArray(t) || t.length !== 6) throw new Error('invalid Fp6 usage');\n    return {\n      c0: Fp2.fromBigTuple(t.slice(0, 2) as BigintTuple),\n      c1: Fp2.fromBigTuple(t.slice(2, 4) as BigintTuple),\n      c2: Fp2.fromBigTuple(t.slice(4, 6) as BigintTuple),\n    };\n  }\n  frobeniusMap({ c0, c1, c2 }: Fp6, power: number) {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.frobeniusMap(c0, power),\n      c1: Fp2.mul(Fp2.frobeniusMap(c1, power), this.FROBENIUS_COEFFICIENTS_1[power % 6]),\n      c2: Fp2.mul(Fp2.frobeniusMap(c2, power), this.FROBENIUS_COEFFICIENTS_2[power % 6]),\n    };\n  }\n  mulByFp2({ c0, c1, c2 }: Fp6, rhs: Fp2): Fp6 {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.mul(c0, rhs),\n      c1: Fp2.mul(c1, rhs),\n      c2: Fp2.mul(c2, rhs),\n    };\n  }\n  mulByNonresidue({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    return { c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 };\n  }\n  // Sparse multiplication\n  mul1({ c0, c1, c2 }: Fp6, b1: Fp2): Fp6 {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n      c1: Fp2.mul(c0, b1),\n      c2: Fp2.mul(c1, b1),\n    };\n  }\n  // Sparse multiplication\n  mul01({ c0, c1, c2 }: Fp6, b0: Fp2, b1: Fp2): Fp6 {\n    const { Fp2 } = this;\n    let t0 = Fp2.mul(c0, b0); // c0 * b0\n    let t1 = Fp2.mul(c1, b1); // c1 * b1\n    return {\n      // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n      c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n      // (b0 + b1) * (c0 + c1) - T0 - T1\n      c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n      // (c0 + c2) * b0 - T0 + T1\n      c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\n    };\n  }\n}\n\nclass _Field12 implements Fp12Bls {\n  readonly ORDER: bigint;\n  readonly BITS: number;\n  readonly BYTES: number;\n  readonly isLE: boolean;\n  readonly MASK = _1n;\n\n  readonly ZERO: Fp12;\n  readonly ONE: Fp12;\n\n  readonly Fp6: Fp6Bls;\n  readonly FROBENIUS_COEFFICIENTS: Fp2[];\n  readonly X_LEN: number;\n  readonly finalExponentiate: Tower12Opts['Fp12finalExponentiate'];\n\n  constructor(Fp6: Fp6Bls, opts: Tower12Opts) {\n    const { Fp2 } = Fp6;\n    const { Fp } = Fp2;\n    this.Fp6 = Fp6;\n\n    this.ORDER = Fp2.ORDER; // TODO: verify if it's unuesd\n    this.BITS = 2 * Fp6.BITS;\n    this.BYTES = 2 * Fp6.BYTES;\n    this.isLE = Fp6.isLE;\n    this.ZERO = { c0: Fp6.ZERO, c1: Fp6.ZERO };\n    this.ONE = { c0: Fp6.ONE, c1: Fp6.ZERO };\n\n    this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(\n      Fp2,\n      Fp2.NONRESIDUE,\n      Fp.ORDER,\n      12,\n      1,\n      6\n    )[0];\n    this.X_LEN = opts.X_LEN;\n    this.finalExponentiate = opts.Fp12finalExponentiate;\n  }\n  create(num: Fp12) {\n    return num;\n  }\n  isValid({ c0, c1 }: Fp12) {\n    const { Fp6 } = this;\n    return Fp6.isValid(c0) && Fp6.isValid(c1);\n  }\n  is0({ c0, c1 }: Fp12) {\n    const { Fp6 } = this;\n    return Fp6.is0(c0) && Fp6.is0(c1);\n  }\n  isValidNot0(num: Fp12) {\n    return !this.is0(num) && this.isValid(num);\n  }\n  neg({ c0, c1 }: Fp12) {\n    const { Fp6 } = this;\n    return { c0: Fp6.neg(c0), c1: Fp6.neg(c1) };\n  }\n  eql({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) {\n    const { Fp6 } = this;\n    return Fp6.eql(c0, r0) && Fp6.eql(c1, r1);\n  }\n  sqrt(_: any): any {\n    notImplemented();\n  }\n  inv({ c0, c1 }: Fp12) {\n    const { Fp6 } = this;\n    let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0² - c1² * v)\n    return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\n  }\n  div(lhs: Fp12, rhs: Fp12) {\n    const { Fp6 } = this;\n    const { Fp2 } = Fp6;\n    const { Fp } = Fp2;\n    return this.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));\n  }\n  pow(num: Fp12, power: bigint): Fp12 {\n    return mod.FpPow(this, num, power);\n  }\n  invertBatch(nums: Fp12[]): Fp12[] {\n    return mod.FpInvertBatch(this, nums);\n  }\n\n  // Normalized\n  add({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) {\n    const { Fp6 } = this;\n    return {\n      c0: Fp6.add(c0, r0),\n      c1: Fp6.add(c1, r1),\n    };\n  }\n  sub({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) {\n    const { Fp6 } = this;\n    return {\n      c0: Fp6.sub(c0, r0),\n      c1: Fp6.sub(c1, r1),\n    };\n  }\n  mul({ c0, c1 }: Fp12, rhs: Fp12 | bigint) {\n    const { Fp6 } = this;\n    if (typeof rhs === 'bigint') return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\n    let { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp6.mul(c0, r0); // c0 * r0\n    let t2 = Fp6.mul(c1, r1); // c1 * r1\n    return {\n      c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\n      // (c0 + c1) * (r0 + r1) - (T1 + T2)\n      c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\n    };\n  }\n  sqr({ c0, c1 }: Fp12) {\n    const { Fp6 } = this;\n    let ab = Fp6.mul(c0, c1); // c0 * c1\n    return {\n      // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n      c0: Fp6.sub(\n        Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab),\n        Fp6.mulByNonresidue(ab)\n      ),\n      c1: Fp6.add(ab, ab),\n    }; // AB + AB\n  }\n  // NonNormalized stuff\n  addN(a: Fp12, b: Fp12): Fp12 {\n    return this.add(a, b);\n  }\n  subN(a: Fp12, b: Fp12): Fp12 {\n    return this.sub(a, b);\n  }\n  mulN(a: Fp12, b: Fp12): Fp12 {\n    return this.mul(a, b);\n  }\n  sqrN(a: Fp12): Fp12 {\n    return this.sqr(a);\n  }\n\n  // Bytes utils\n  fromBytes(b: Uint8Array): Fp12 {\n    const { Fp6 } = this;\n    if (b.length !== this.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n    return {\n      c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n      c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\n    };\n  }\n  toBytes({ c0, c1 }: Fp12): Uint8Array {\n    const { Fp6 } = this;\n    return concatBytes(Fp6.toBytes(c0), Fp6.toBytes(c1));\n  }\n  cmov({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12, c: boolean) {\n    const { Fp6 } = this;\n    return {\n      c0: Fp6.cmov(c0, r0, c),\n      c1: Fp6.cmov(c1, r1, c),\n    };\n  }\n  // Utils\n  // toString() {\n  //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');\n  // },\n  // fromTuple(c: [Fp6, Fp6]) {\n  //   return new Fp12(...c);\n  // }\n  fromBigTwelve(t: BigintTwelve): Fp12 {\n    const { Fp6 } = this;\n    return {\n      c0: Fp6.fromBigSix(t.slice(0, 6) as BigintSix),\n      c1: Fp6.fromBigSix(t.slice(6, 12) as BigintSix),\n    };\n  }\n  // Raises to q**i -th power\n  frobeniusMap(lhs: Fp12, power: number) {\n    const { Fp6 } = this;\n    const { Fp2 } = Fp6;\n    const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\n    const coeff = this.FROBENIUS_COEFFICIENTS[power % 12];\n    return {\n      c0: Fp6.frobeniusMap(lhs.c0, power),\n      c1: Fp6.create({\n        c0: Fp2.mul(c0, coeff),\n        c1: Fp2.mul(c1, coeff),\n        c2: Fp2.mul(c2, coeff),\n      }),\n    };\n  }\n  mulByFp2({ c0, c1 }: Fp12, rhs: Fp2): Fp12 {\n    const { Fp6 } = this;\n    return {\n      c0: Fp6.mulByFp2(c0, rhs),\n      c1: Fp6.mulByFp2(c1, rhs),\n    };\n  }\n  conjugate({ c0, c1 }: Fp12): Fp12 {\n    return { c0, c1: this.Fp6.neg(c1) };\n  }\n  // Sparse multiplication\n  mul014({ c0, c1 }: Fp12, o0: Fp2, o1: Fp2, o4: Fp2) {\n    const { Fp6 } = this;\n    const { Fp2 } = Fp6;\n    let t0 = Fp6.mul01(c0, o0, o1);\n    let t1 = Fp6.mul1(c1, o4);\n    return {\n      c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\n      // (c1 + c0) * [o0, o1+o4] - T0 - T1\n      c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\n    };\n  }\n  mul034({ c0, c1 }: Fp12, o0: Fp2, o3: Fp2, o4: Fp2) {\n    const { Fp6 } = this;\n    const { Fp2 } = Fp6;\n    const a = Fp6.create({\n      c0: Fp2.mul(c0.c0, o0),\n      c1: Fp2.mul(c0.c1, o0),\n      c2: Fp2.mul(c0.c2, o0),\n    });\n    const b = Fp6.mul01(c1, o3, o4);\n    const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\n    return {\n      c0: Fp6.add(Fp6.mulByNonresidue(b), a),\n      c1: Fp6.sub(e, Fp6.add(a, b)),\n    };\n  }\n\n  // A cyclotomic group is a subgroup of Fp^n defined by\n  //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n  // The result of any pairing is in a cyclotomic subgroup\n  // https://eprint.iacr.org/2009/565.pdf\n  // https://eprint.iacr.org/2010/354.pdf\n  _cyclotomicSquare({ c0, c1 }: Fp12): Fp12 {\n    const { Fp6 } = this;\n    const { Fp2 } = Fp6;\n    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\n    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\n    const { first: t3, second: t4 } = Fp2.Fp4Square(c0c0, c1c1);\n    const { first: t5, second: t6 } = Fp2.Fp4Square(c1c0, c0c2);\n    const { first: t7, second: t8 } = Fp2.Fp4Square(c0c1, c1c2);\n    const t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\n    return {\n      c0: Fp6.create({\n        c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3), // 2 * (T3 - c0c0)  + T3\n        c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5), // 2 * (T5 - c0c1)  + T5\n        c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7),\n      }), // 2 * (T7 - c0c2)  + T7\n      c1: Fp6.create({\n        c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9), // 2 * (T9 + c1c0) + T9\n        c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4), // 2 * (T4 + c1c1) + T4\n        c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6),\n      }),\n    }; // 2 * (T6 + c1c2) + T6\n  }\n  // https://eprint.iacr.org/2009/565.pdf\n  _cyclotomicExp(num: Fp12, n: bigint): Fp12 {\n    let z = this.ONE;\n    for (let i = this.X_LEN - 1; i >= 0; i--) {\n      z = this._cyclotomicSquare(z);\n      if (bitGet(n, i)) z = this.mul(z, num);\n    }\n    return z;\n  }\n}\n\nexport function tower12(opts: Tower12Opts): {\n  Fp: Readonly<mod.IField<bigint> & Required<Pick<mod.IField<bigint>, 'isOdd'>>>;\n  Fp2: Fp2Bls;\n  Fp6: Fp6Bls;\n  Fp12: Fp12Bls;\n} {\n  const Fp = mod.Field(opts.ORDER);\n  const Fp2 = new _Field2(Fp, opts);\n  const Fp6 = new _Field6(Fp2);\n  const Fp12 = new _Field12(Fp6, opts);\n  return { Fp, Fp2, Fp6, Fp12 };\n}\n", "/**\n * bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\n\n* Construct zk-SNARKs at the ~120-bit security, as per [Barbulescu-Duquesne 2017](https://hal.science/hal-01534101/file/main.pdf)\n* Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\nthe Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\n\nBLS can mean 2 different things:\n\n* Barreto-Lynn-Scott: BLS12, a Pairing Friendly Elliptic Curve\n* Boneh-Lynn-Shacham: A Signature Scheme.\n\n### Summary\n\n1. BLS Relies on expensive bilinear pairing\n2. Secret Keys: 32 bytes\n3. Public Keys: 48 OR 96 bytes - big-endian x coordinate of point on G1 OR G2 curve\n4. Signatures: 96 OR 48 bytes - big-endian x coordinate of point on G2 OR G1 curve\n5. The 12 stands for the Embedding degree.\n\nModes of operation:\n\n* Long signatures:  48-byte keys + 96-byte sigs (G1 keys + G2 sigs).\n* Short signatures: 96-byte keys + 48-byte sigs (G2 keys + G1 sigs).\n\n### Formulas\n\n- `P = pk x G` - public keys\n- `S = pk x H(m)` - signing, uses hash-to-curve on m\n- `e(P, H(m)) == e(G, S)` - verification using pairings\n- `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\n\n### Curves\n\nG1 is ordinary elliptic curve. G2 is extension field curve, think \"over complex numbers\".\n\n- G1: y² = x³ + 4\n- G2: y² = x³ + 4(u + 1) where u = √−1; r-order subgroup of E'(Fp²), M-type twist\n\n### Towers\n\nPairing G1 + G2 produces element in Fp₁₂, 12-degree polynomial.\nFp₁₂ is usually implemented using tower of lower-degree polynomials for speed.\n\n- Fp₁₂ = Fp₆² => Fp₂³\n- Fp(u) / (u² - β) where β = -1\n- Fp₂(v) / (v³ - ξ) where ξ = u + 1\n- Fp₆(w) / (w² - γ) where γ = v\n- Fp²[u] = Fp/u²+1\n- Fp⁶[v] = Fp²/v³-1-u\n- Fp¹²[w] = Fp⁶/w²-v\n\n### Params\n\n* Embedding degree (k): 12\n* Seed is sometimes named x or t\n* t = -15132376222941642752\n* p = (t-1)² * (t⁴-t²+1)/3 + t\n* r = t⁴-t²+1\n* Ate loop size: X\n\nTo verify curve parameters, see\n[pairing-friendly-curves spec](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11).\nBasic math is done over finite fields over p.\nMore complicated math is done over polynominal extension fields.\n\n### Compatibility and notes\n1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC.\nFilecoin uses little endian byte arrays for secret keys - make sure to reverse byte order.\n2. Make sure to correctly select mode: \"long signature\" or \"short signature\".\n3. Compatible with specs:\n   RFC 9380,\n   [cfrg-pairing-friendly-curves-11](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11),\n   [cfrg-bls-signature-05](https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/).\n\n *\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { bls, type CurveFn } from './abstract/bls.ts';\nimport { Field, type IField } from './abstract/modular.ts';\nimport {\n  abytes,\n  bitLen,\n  bitMask,\n  bytesToHex,\n  bytesToNumberBE,\n  concatBytes,\n  ensureBytes,\n  numberToBytesBE,\n  type Hex,\n} from './utils.ts';\n// Types\nimport { isogenyMap } from './abstract/hash-to-curve.ts';\nimport type { BigintTuple, Fp, Fp12, Fp2, Fp6 } from './abstract/tower.ts';\nimport { psiFrobenius, tower12 } from './abstract/tower.ts';\nimport {\n  mapToCurveSimpleSWU,\n  type AffinePoint,\n  type WeierstrassOpts,\n  type WeierstrassPoint,\n  type WeierstrassPointCons,\n} from './abstract/weierstrass.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\n// To verify math:\n// https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11\n\n// The BLS parameter x (seed) for BLS12-381. NOTE: it is negative!\n// x = -2^63 - 2^62 - 2^60 - 2^57 - 2^48 - 2^16\nconst BLS_X = BigInt('0xd201000000010000');\n// t = x (called differently in different places)\n// const t = -BLS_X;\nconst BLS_X_LEN = bitLen(BLS_X);\n\n// a=0, b=4\n// P is characteristic of field Fp, in which curve calculations are done.\n// p = (t-1)² * (t⁴-t²+1)/3 + t\n// bls12_381_Fp = (t-1n)**2n * (t**4n - t**2n + 1n) / 3n + t\n// r*h is curve order, amount of points on curve,\n// where r is order of prime subgroup and h is cofactor.\n// r = t⁴-t²+1\n// r = (t**4n - t**2n + 1n)\n// cofactor h of G1: (t - 1)²/3\n// cofactorG1 = (t-1n)**2n/3n\n// x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n// y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\nconst bls12_381_CURVE_G1: WeierstrassOpts<bigint> = {\n  p: BigInt(\n    '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'\n  ),\n  n: BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'),\n  h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),\n  a: _0n,\n  b: _4n,\n  Gx: BigInt(\n    '0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'\n  ),\n  Gy: BigInt(\n    '0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'\n  ),\n};\n\n// CURVE FIELDS\nexport const bls12_381_Fr: IField<bigint> = Field(bls12_381_CURVE_G1.n, {\n  modFromBytes: true,\n  isLE: true,\n});\nconst { Fp, Fp2, Fp6, Fp12 } = tower12({\n  ORDER: bls12_381_CURVE_G1.p,\n  X_LEN: BLS_X_LEN,\n  // Finite extension field over irreducible polynominal.\n  // Fp(u) / (u² - β) where β = -1\n  FP2_NONRESIDUE: [_1n, _1n],\n  Fp2mulByB: ({ c0, c1 }) => {\n    const t0 = Fp.mul(c0, _4n); // 4 * c0\n    const t1 = Fp.mul(c1, _4n); // 4 * c1\n    // (T0-T1) + (T0+T1)*i\n    return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };\n  },\n  Fp12finalExponentiate: (num) => {\n    const x = BLS_X;\n    // this^(q⁶) / this\n    const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\n    // t0^(q²) * t0\n    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\n    const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\n    const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\n    const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\n    const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\n    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\n    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\n    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\n    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\n    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\n    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\n    // (t2 * t5)^(q²) * (t4 * t1)^(q³) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\n    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\n  },\n});\n\n// GLV endomorphism Ψ(P), for fast cofactor clearing\nconst { G2psi, G2psi2 } = psiFrobenius(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE)); // 1/(u+1)\n\n/**\n * Default hash_to_field / hash-to-curve for BLS.\n * m: 1 for G1, 2 for G2\n * k: target security level in bits\n * hash: any function, e.g. BBS+ uses BLAKE2: see [github](https://github.com/hyperledger/aries-framework-go/issues/2247).\n * Parameter values come from [section 8.8.2 of RFC 9380](https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2).\n */\nconst htfDefaults = Object.freeze({\n  DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n  encodeDST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n  p: Fp.ORDER,\n  m: 2,\n  k: 128,\n  expand: 'xmd',\n  hash: sha256,\n});\n\n// a=0, b=4\n// cofactor h of G2\n// (t^8 - 4t^7 + 5t^6 - 4t^4 + 6t^3 - 4t^2 - 4t + 13)/9\n// cofactorG2 = (t**8n - 4n*t**7n + 5n*t**6n - 4n*t**4n + 6n*t**3n - 4n*t**2n - 4n*t+13n)/9n\n// x = 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758*u + 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n// y = 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582*u + 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\nconst bls12_381_CURVE_G2 = {\n  p: Fp2.ORDER,\n  n: bls12_381_CURVE_G1.n,\n  h: BigInt(\n    '0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'\n  ),\n  a: Fp2.ZERO,\n  b: Fp2.fromBigTuple([_4n, _4n]),\n  Gx: Fp2.fromBigTuple([\n    BigInt(\n      '0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'\n    ),\n    BigInt(\n      '0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e'\n    ),\n  ]),\n  Gy: Fp2.fromBigTuple([\n    BigInt(\n      '0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'\n    ),\n    BigInt(\n      '0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be'\n    ),\n  ]),\n};\n\n// Encoding utils\n// Compressed point of infinity\n// Set compressed & point-at-infinity bits\nconst COMPZERO = setMask(Fp.toBytes(_0n), { infinity: true, compressed: true });\n\nfunction parseMask(bytes: Uint8Array) {\n  // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\n  bytes = bytes.slice();\n  const mask = bytes[0] & 0b1110_0000;\n  const compressed = !!((mask >> 7) & 1); // compression bit (0b1000_0000)\n  const infinity = !!((mask >> 6) & 1); // point at infinity bit (0b0100_0000)\n  const sort = !!((mask >> 5) & 1); // sort bit (0b0010_0000)\n  bytes[0] &= 0b0001_1111; // clear mask (zero first 3 bits)\n  return { compressed, infinity, sort, value: bytes };\n}\n\nfunction setMask(\n  bytes: Uint8Array,\n  mask: { compressed?: boolean; infinity?: boolean; sort?: boolean }\n) {\n  if (bytes[0] & 0b1110_0000) throw new Error('setMask: non-empty mask');\n  if (mask.compressed) bytes[0] |= 0b1000_0000;\n  if (mask.infinity) bytes[0] |= 0b0100_0000;\n  if (mask.sort) bytes[0] |= 0b0010_0000;\n  return bytes;\n}\n\nfunction pointG1ToBytes(\n  _c: WeierstrassPointCons<Fp>,\n  point: WeierstrassPoint<Fp>,\n  isComp: boolean\n) {\n  const { BYTES: L, ORDER: P } = Fp;\n  const is0 = point.is0();\n  const { x, y } = point.toAffine();\n  if (isComp) {\n    if (is0) return COMPZERO.slice();\n    const sort = Boolean((y * _2n) / P);\n    return setMask(numberToBytesBE(x, L), { compressed: true, sort });\n  } else {\n    if (is0) {\n      return concatBytes(Uint8Array.of(0x40), new Uint8Array(2 * L - 1));\n    } else {\n      return concatBytes(numberToBytesBE(x, L), numberToBytesBE(y, L));\n    }\n  }\n}\n\nfunction signatureG1ToBytes(point: WeierstrassPoint<Fp>) {\n  point.assertValidity();\n  const { BYTES: L, ORDER: P } = Fp;\n  const { x, y } = point.toAffine();\n  if (point.is0()) return COMPZERO.slice();\n  const sort = Boolean((y * _2n) / P);\n  return setMask(numberToBytesBE(x, L), { compressed: true, sort });\n}\n\nfunction pointG1FromBytes(bytes: Uint8Array): AffinePoint<Fp> {\n  const { compressed, infinity, sort, value } = parseMask(bytes);\n  const { BYTES: L, ORDER: P } = Fp;\n  if (value.length === 48 && compressed) {\n    const compressedValue = bytesToNumberBE(value);\n    // Zero\n    const x = Fp.create(compressedValue & bitMask(Fp.BITS));\n    if (infinity) {\n      if (x !== _0n) throw new Error('invalid G1 point: non-empty, at infinity, with compression');\n      return { x: _0n, y: _0n };\n    }\n    const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381_CURVE_G1.b)); // y² = x³ + b\n    let y = Fp.sqrt(right);\n    if (!y) throw new Error('invalid G1 point: compressed point');\n    if ((y * _2n) / P !== BigInt(sort)) y = Fp.neg(y);\n    return { x: Fp.create(x), y: Fp.create(y) };\n  } else if (value.length === 96 && !compressed) {\n    // Check if the infinity flag is set\n    const x = bytesToNumberBE(value.subarray(0, L));\n    const y = bytesToNumberBE(value.subarray(L));\n    if (infinity) {\n      if (x !== _0n || y !== _0n) throw new Error('G1: non-empty point at infinity');\n      return bls12_381.G1.Point.ZERO.toAffine();\n    }\n    return { x: Fp.create(x), y: Fp.create(y) };\n  } else {\n    throw new Error('invalid G1 point: expected 48/96 bytes');\n  }\n}\n\nfunction signatureG1FromBytes(hex: Hex): WeierstrassPoint<Fp> {\n  const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex, 48));\n  const P = Fp.ORDER;\n  const Point = bls12_381.G1.Point;\n  const compressedValue = bytesToNumberBE(value);\n  // Zero\n  if (infinity) return Point.ZERO;\n  const x = Fp.create(compressedValue & bitMask(Fp.BITS));\n  const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381_CURVE_G1.b)); // y² = x³ + b\n  let y = Fp.sqrt(right);\n  if (!y) throw new Error('invalid G1 point: compressed');\n  const aflag = BigInt(sort);\n  if ((y * _2n) / P !== aflag) y = Fp.neg(y);\n  const point = Point.fromAffine({ x, y });\n  point.assertValidity();\n  return point;\n}\n\nfunction pointG2ToBytes(\n  _c: WeierstrassPointCons<Fp2>,\n  point: WeierstrassPoint<Fp2>,\n  isComp: boolean\n) {\n  const { BYTES: L, ORDER: P } = Fp;\n  const is0 = point.is0();\n  const { x, y } = point.toAffine();\n  if (isComp) {\n    if (is0) return concatBytes(COMPZERO, numberToBytesBE(_0n, L));\n    const flag = Boolean(y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P);\n    return concatBytes(\n      setMask(numberToBytesBE(x.c1, L), { compressed: true, sort: flag }),\n      numberToBytesBE(x.c0, L)\n    );\n  } else {\n    if (is0) return concatBytes(Uint8Array.of(0x40), new Uint8Array(4 * L - 1));\n    const { re: x0, im: x1 } = Fp2.reim(x);\n    const { re: y0, im: y1 } = Fp2.reim(y);\n    return concatBytes(\n      numberToBytesBE(x1, L),\n      numberToBytesBE(x0, L),\n      numberToBytesBE(y1, L),\n      numberToBytesBE(y0, L)\n    );\n  }\n}\n\nfunction signatureG2ToBytes(point: WeierstrassPoint<Fp2>) {\n  point.assertValidity();\n  const { BYTES: L } = Fp;\n  if (point.is0()) return concatBytes(COMPZERO, numberToBytesBE(_0n, L));\n  const { x, y } = point.toAffine();\n  const { re: x0, im: x1 } = Fp2.reim(x);\n  const { re: y0, im: y1 } = Fp2.reim(y);\n  const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\n  const sort = Boolean((tmp / Fp.ORDER) & _1n);\n  const z2 = x0;\n  return concatBytes(\n    setMask(numberToBytesBE(x1, L), { sort, compressed: true }),\n    numberToBytesBE(z2, L)\n  );\n}\n\nfunction pointG2FromBytes(bytes: Uint8Array): AffinePoint<Fp2> {\n  const { BYTES: L, ORDER: P } = Fp;\n  const { compressed, infinity, sort, value } = parseMask(bytes);\n  if (\n    (!compressed && !infinity && sort) || // 00100000\n    (!compressed && infinity && sort) || // 01100000\n    (sort && infinity && compressed) // 11100000\n  ) {\n    throw new Error('invalid encoding flag: ' + (bytes[0] & 0b1110_0000));\n  }\n  const slc = (b: Uint8Array, from: number, to?: number) => bytesToNumberBE(b.slice(from, to));\n  if (value.length === 96 && compressed) {\n    if (infinity) {\n      // check that all bytes are 0\n      if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n        throw new Error('invalid G2 point: compressed');\n      }\n      return { x: Fp2.ZERO, y: Fp2.ZERO };\n    }\n    const x_1 = slc(value, 0, L);\n    const x_0 = slc(value, L, 2 * L);\n    const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });\n    const right = Fp2.add(Fp2.pow(x, _3n), bls12_381_CURVE_G2.b); // y² = x³ + 4 * (u+1) = x³ + b\n    let y = Fp2.sqrt(right);\n    const Y_bit = y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P ? _1n : _0n;\n    y = sort && Y_bit > 0 ? y : Fp2.neg(y);\n    return { x, y };\n  } else if (value.length === 192 && !compressed) {\n    if (infinity) {\n      if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n        throw new Error('invalid G2 point: uncompressed');\n      }\n      return { x: Fp2.ZERO, y: Fp2.ZERO };\n    }\n    const x1 = slc(value, 0 * L, 1 * L);\n    const x0 = slc(value, 1 * L, 2 * L);\n    const y1 = slc(value, 2 * L, 3 * L);\n    const y0 = slc(value, 3 * L, 4 * L);\n    return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };\n  } else {\n    throw new Error('invalid G2 point: expected 96/192 bytes');\n  }\n}\n\nfunction signatureG2FromBytes(hex: Hex) {\n  const { ORDER: P } = Fp;\n  // TODO: Optimize, it's very slow because of sqrt.\n  const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex));\n  const Point = bls12_381.G2.Point;\n  const half = value.length / 2;\n  if (half !== 48 && half !== 96)\n    throw new Error('invalid compressed signature length, expected 96/192 bytes');\n  const z1 = bytesToNumberBE(value.slice(0, half));\n  const z2 = bytesToNumberBE(value.slice(half));\n  // Indicates the infinity point\n  if (infinity) return Point.ZERO;\n  const x1 = Fp.create(z1 & bitMask(Fp.BITS));\n  const x2 = Fp.create(z2);\n  const x = Fp2.create({ c0: x2, c1: x1 });\n  const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381_CURVE_G2.b); // y² = x³ + 4\n  // The slow part\n  let y = Fp2.sqrt(y2);\n  if (!y) throw new Error('Failed to find a square root');\n\n  // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n  // If y1 happens to be zero, then use the bit of y0\n  const { re: y0, im: y1 } = Fp2.reim(y);\n  const aflag1 = BigInt(sort);\n  const isGreater = y1 > _0n && (y1 * _2n) / P !== aflag1;\n  const is0 = y1 === _0n && (y0 * _2n) / P !== aflag1;\n  if (isGreater || is0) y = Fp2.neg(y);\n  const point = Point.fromAffine({ x, y });\n  point.assertValidity();\n  return point;\n}\n\n/**\n * bls12-381 pairing-friendly curve.\n * @example\n * import { bls12_381 as bls } from '@noble/curves/bls12-381';\n * // G1 keys, G2 signatures\n * const privateKey = '67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c';\n * const message = '64726e3da8';\n * const publicKey = bls.getPublicKey(privateKey);\n * const signature = bls.sign(message, privateKey);\n * const isValid = bls.verify(signature, message, publicKey);\n */\nexport const bls12_381: CurveFn = bls({\n  // Fields\n  fields: {\n    Fp,\n    Fp2,\n    Fp6,\n    Fp12,\n    Fr: bls12_381_Fr,\n  },\n  // G1: y² = x³ + 4\n  G1: {\n    ...bls12_381_CURVE_G1,\n    Fp,\n    htfDefaults: { ...htfDefaults, m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    // Checks is the point resides in prime-order subgroup.\n    // point.isTorsionFree() should return true for valid points\n    // It returns false for shitty points.\n    // https://eprint.iacr.org/2021/1130.pdf\n    isTorsionFree: (c, point): boolean => {\n      // GLV endomorphism ψ(P)\n      const beta = BigInt(\n        '0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'\n      );\n      const phi = new c(Fp.mul(point.X, beta), point.Y, point.Z);\n      // TODO: unroll\n      const xP = point.multiplyUnsafe(BLS_X).negate(); // [x]P\n      const u2P = xP.multiplyUnsafe(BLS_X); // [u2]P\n      return u2P.equals(phi);\n    },\n    // Clear cofactor of G1\n    // https://eprint.iacr.org/2019/403\n    clearCofactor: (_c, point) => {\n      // return this.multiplyUnsafe(CURVE.h);\n      return point.multiplyUnsafe(BLS_X).add(point); // x*P + P\n    },\n    mapToCurve: mapToG1,\n    fromBytes: pointG1FromBytes,\n    toBytes: pointG1ToBytes,\n    ShortSignature: {\n      fromBytes(bytes: Uint8Array) {\n        abytes(bytes);\n        return signatureG1FromBytes(bytes);\n      },\n      fromHex(hex: Hex): WeierstrassPoint<Fp> {\n        return signatureG1FromBytes(hex);\n      },\n      toBytes(point: WeierstrassPoint<Fp>) {\n        return signatureG1ToBytes(point);\n      },\n      toRawBytes(point: WeierstrassPoint<Fp>) {\n        return signatureG1ToBytes(point);\n      },\n      toHex(point: WeierstrassPoint<Fp>) {\n        return bytesToHex(signatureG1ToBytes(point));\n      },\n    },\n  },\n  G2: {\n    ...bls12_381_CURVE_G2,\n    Fp: Fp2,\n    // https://datatracker.ietf.org/doc/html/rfc9380#name-clearing-the-cofactor\n    // https://datatracker.ietf.org/doc/html/rfc9380#name-cofactor-clearing-for-bls12\n    hEff: BigInt(\n      '0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'\n    ),\n    htfDefaults: { ...htfDefaults },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    mapToCurve: mapToG2,\n    // Checks is the point resides in prime-order subgroup.\n    // point.isTorsionFree() should return true for valid points\n    // It returns false for shitty points.\n    // https://eprint.iacr.org/2021/1130.pdf\n    // Older version: https://eprint.iacr.org/2019/814.pdf\n    isTorsionFree: (c, P): boolean => {\n      return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P)); // ψ(P) == [u](P)\n    },\n    // Maps the point into the prime-order subgroup G2.\n    // clear_cofactor_bls12381_g2 from RFC 9380.\n    // https://eprint.iacr.org/2017/419.pdf\n    // prettier-ignore\n    clearCofactor: (c, P) => {\n      const x = BLS_X;\n      let t1 = P.multiplyUnsafe(x).negate();  // [-x]P\n      let t2 = G2psi(c, P);                   // Ψ(P)\n      let t3 = P.double();                    // 2P\n      t3 = G2psi2(c, t3);                     // Ψ²(2P)\n      t3 = t3.subtract(t2);                   // Ψ²(2P) - Ψ(P)\n      t2 = t1.add(t2);                        // [-x]P + Ψ(P)\n      t2 = t2.multiplyUnsafe(x).negate();     // [x²]P - [x]Ψ(P)\n      t3 = t3.add(t2);                        // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P)\n      t3 = t3.subtract(t1);                   // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P\n      const Q = t3.subtract(P);               // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P - 1P\n      return Q;                               // [x²-x-1]P + [x-1]Ψ(P) + Ψ²(2P)\n    },\n    fromBytes: pointG2FromBytes,\n    toBytes: pointG2ToBytes,\n    Signature: {\n      fromBytes(bytes: Uint8Array): WeierstrassPoint<Fp2> {\n        abytes(bytes);\n        return signatureG2FromBytes(bytes);\n      },\n      fromHex(hex: Hex): WeierstrassPoint<Fp2> {\n        return signatureG2FromBytes(hex);\n      },\n      toBytes(point: WeierstrassPoint<Fp2>) {\n        return signatureG2ToBytes(point);\n      },\n      toRawBytes(point: WeierstrassPoint<Fp2>) {\n        return signatureG2ToBytes(point);\n      },\n      toHex(point: WeierstrassPoint<Fp2>) {\n        return bytesToHex(signatureG2ToBytes(point));\n      },\n    },\n  },\n  params: {\n    ateLoopSize: BLS_X, // The BLS parameter x for BLS12-381\n    r: bls12_381_CURVE_G1.n, // order; z⁴ − z² + 1; CURVE.n from other curves\n    xNegative: true,\n    twistType: 'multiplicative',\n  },\n  htfDefaults,\n  hash: sha256,\n});\n\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\nconst isogenyMapG2 = isogenyMap(\n  Fp2,\n  [\n    // xNum\n    [\n      [\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n      ],\n      [\n        '0x0',\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a',\n      ],\n      [\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d',\n      ],\n      [\n        '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',\n        '0x0',\n      ],\n    ],\n    // xDen\n    [\n      [\n        '0x0',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63',\n      ],\n      [\n        '0xc',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f',\n      ],\n      ['0x1', '0x0'], // LAST 1\n    ],\n    // yNum\n    [\n      [\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n      ],\n      [\n        '0x0',\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be',\n      ],\n      [\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f',\n      ],\n      [\n        '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',\n        '0x0',\n      ],\n    ],\n    // yDen\n    [\n      [\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n      ],\n      [\n        '0x0',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3',\n      ],\n      [\n        '0x12',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99',\n      ],\n      ['0x1', '0x0'], // LAST 1\n    ],\n  ].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt) as BigintTuple))) as [\n    Fp2[],\n    Fp2[],\n    Fp2[],\n    Fp2[],\n  ]\n);\n// 11-isogeny map from E' to E\nconst isogenyMapG1 = isogenyMap(\n  Fp,\n  [\n    // xNum\n    [\n      '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',\n      '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',\n      '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',\n      '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',\n      '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',\n      '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',\n      '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',\n      '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',\n      '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',\n      '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',\n      '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',\n      '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229',\n    ],\n    // xDen\n    [\n      '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',\n      '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',\n      '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',\n      '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',\n      '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',\n      '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',\n      '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',\n      '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',\n      '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',\n      '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n      '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',\n      '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',\n      '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',\n      '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',\n      '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',\n      '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',\n      '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',\n      '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',\n      '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',\n      '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',\n      '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',\n      '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',\n      '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',\n      '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',\n      '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',\n      '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604',\n    ],\n    // yDen\n    [\n      '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',\n      '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',\n      '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',\n      '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',\n      '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',\n      '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',\n      '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',\n      '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',\n      '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',\n      '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',\n      '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',\n      '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',\n      '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',\n      '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',\n      '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n  ].map((i) => i.map((j) => BigInt(j))) as [Fp[], Fp[], Fp[], Fp[]]\n);\n\n// Optimized SWU Map - Fp to G1\nconst G1_SWU = mapToCurveSimpleSWU(Fp, {\n  A: Fp.create(\n    BigInt(\n      '0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d'\n    )\n  ),\n  B: Fp.create(\n    BigInt(\n      '0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0'\n    )\n  ),\n  Z: Fp.create(BigInt(11)),\n});\n// SWU Map - Fp2 to G2': y² = x³ + 240i * x + 1012 + 1012i\nconst G2_SWU = mapToCurveSimpleSWU(Fp2, {\n  A: Fp2.create({ c0: Fp.create(_0n), c1: Fp.create(BigInt(240)) }), // A' = 240 * I\n  B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }), // B' = 1012 * (1 + I)\n  Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) }), // Z: -(2 + I)\n});\n\nfunction mapToG1(scalars: bigint[]) {\n  const { x, y } = G1_SWU(Fp.create(scalars[0]));\n  return isogenyMapG1(x, y);\n}\nfunction mapToG2(scalars: bigint[]) {\n  const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars as BigintTuple));\n  return isogenyMapG2(x, y);\n}\n", "import type { Address } from 'abitype'\nimport { BaseError } from '../../errors/base.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type AccountNotDeployedErrorType = AccountNotDeployedError & {\n  name: 'AccountNotDeployedError'\n}\nexport class AccountNotDeployedError extends BaseError {\n  static message = /aa20/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Smart Account is not deployed.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- No `factory`/`factoryData` or `initCode` properties are provided for Smart Account deployment.',\n        '- An incorrect `sender` address is provided.',\n      ],\n      name: 'AccountNotDeployedError',\n    })\n  }\n}\n\nexport type ExecutionRevertedErrorType = ExecutionRevertedError & {\n  code: -32521\n  name: 'ExecutionRevertedError'\n}\nexport class ExecutionRevertedError extends BaseError {\n  static code = -32521\n  static message = /execution reverted/\n\n  data?: { revertData?: Hex } | undefined\n\n  constructor({\n    cause,\n    data,\n    message,\n  }: {\n    cause?: BaseError | undefined\n    data?: { revertData?: Hex } | undefined\n    message?: string | undefined\n  } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n        name: 'ExecutionRevertedError',\n      },\n    )\n\n    this.data = data\n  }\n}\n\nexport type FailedToSendToBeneficiaryErrorType =\n  FailedToSendToBeneficiaryError & {\n    name: 'FailedToSendToBeneficiaryError'\n  }\nexport class FailedToSendToBeneficiaryError extends BaseError {\n  static message = /aa91/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Failed to send funds to beneficiary.', {\n      cause,\n      name: 'FailedToSendToBeneficiaryError',\n    })\n  }\n}\n\nexport type GasValuesOverflowErrorType = GasValuesOverflowError & {\n  name: 'GasValuesOverflowError'\n}\nexport class GasValuesOverflowError extends BaseError {\n  static message = /aa94/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Gas value overflowed.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- one of the gas values exceeded 2**120 (uint120)',\n      ].filter(Boolean) as string[],\n      name: 'GasValuesOverflowError',\n    })\n  }\n}\n\nexport type HandleOpsOutOfGasErrorType = HandleOpsOutOfGasError & {\n  name: 'HandleOpsOutOfGasError'\n}\nexport class HandleOpsOutOfGasError extends BaseError {\n  static message = /aa95/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'The `handleOps` function was called by the Bundler with a gas limit too low.',\n      {\n        cause,\n        name: 'HandleOpsOutOfGasError',\n      },\n    )\n  }\n}\n\nexport type InitCodeFailedErrorType = InitCodeFailedError & {\n  name: 'InitCodeFailedError'\n}\nexport class InitCodeFailedError extends BaseError {\n  static message = /aa13/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super('Failed to simulate deployment for Smart Account.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- Invalid `factory`/`factoryData` or `initCode` properties are present',\n        '- Smart Account deployment execution ran out of gas (low `verificationGasLimit` value)',\n        '- Smart Account deployment execution reverted with an error\\n',\n        factory && `factory: ${factory}`,\n        factoryData && `factoryData: ${factoryData}`,\n        initCode && `initCode: ${initCode}`,\n      ].filter(Boolean) as string[],\n      name: 'InitCodeFailedError',\n    })\n  }\n}\n\nexport type InitCodeMustCreateSenderErrorType =\n  InitCodeMustCreateSenderError & {\n    name: 'InitCodeMustCreateSenderError'\n  }\nexport class InitCodeMustCreateSenderError extends BaseError {\n  static message = /aa15/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super(\n      'Smart Account initialization implementation did not create an account.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          '- `factory`/`factoryData` or `initCode` properties are invalid',\n          '- Smart Account initialization implementation is incorrect\\n',\n          factory && `factory: ${factory}`,\n          factoryData && `factoryData: ${factoryData}`,\n          initCode && `initCode: ${initCode}`,\n        ].filter(Boolean) as string[],\n        name: 'InitCodeMustCreateSenderError',\n      },\n    )\n  }\n}\n\nexport type InitCodeMustReturnSenderErrorType =\n  InitCodeMustReturnSenderError & {\n    name: 'InitCodeMustReturnSenderError'\n  }\nexport class InitCodeMustReturnSenderError extends BaseError {\n  static message = /aa14/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n    sender,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n    sender?: Address | undefined\n  }) {\n    super(\n      'Smart Account initialization implementation does not return the expected sender.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          'Smart Account initialization implementation does not return a sender address\\n',\n          factory && `factory: ${factory}`,\n          factoryData && `factoryData: ${factoryData}`,\n          initCode && `initCode: ${initCode}`,\n          sender && `sender: ${sender}`,\n        ].filter(Boolean) as string[],\n        name: 'InitCodeMustReturnSenderError',\n      },\n    )\n  }\n}\n\nexport type InsufficientPrefundErrorType = InsufficientPrefundError & {\n  name: 'InsufficientPrefundError'\n}\nexport class InsufficientPrefundError extends BaseError {\n  static message = /aa21/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'Smart Account does not have sufficient funds to execute the User Operation.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          '- the Smart Account does not have sufficient funds to cover the required prefund, or',\n          '- a Paymaster was not provided',\n        ].filter(Boolean) as string[],\n        name: 'InsufficientPrefundError',\n      },\n    )\n  }\n}\n\nexport type InternalCallOnlyErrorType = InternalCallOnlyError & {\n  name: 'InternalCallOnlyError'\n}\nexport class InternalCallOnlyError extends BaseError {\n  static message = /aa92/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Bundler attempted to call an invalid function on the EntryPoint.', {\n      cause,\n      name: 'InternalCallOnlyError',\n    })\n  }\n}\n\nexport type InvalidAggregatorErrorType = InvalidAggregatorError & {\n  name: 'InvalidAggregatorError'\n}\nexport class InvalidAggregatorError extends BaseError {\n  static message = /aa96/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'Bundler used an invalid aggregator for handling aggregated User Operations.',\n      {\n        cause,\n        name: 'InvalidAggregatorError',\n      },\n    )\n  }\n}\n\nexport type InvalidAccountNonceErrorType = InvalidAccountNonceError & {\n  name: 'InvalidAccountNonceError'\n}\nexport class InvalidAccountNonceError extends BaseError {\n  static message = /aa25/\n  constructor({\n    cause,\n    nonce,\n  }: {\n    cause?: BaseError | undefined\n    nonce?: bigint | undefined\n  }) {\n    super('Invalid Smart Account nonce used for User Operation.', {\n      cause,\n      metaMessages: [nonce && `nonce: ${nonce}`].filter(Boolean) as string[],\n      name: 'InvalidAccountNonceError',\n    })\n  }\n}\n\nexport type InvalidBeneficiaryErrorType = InvalidBeneficiaryError & {\n  name: 'InvalidBeneficiaryError'\n}\nexport class InvalidBeneficiaryError extends BaseError {\n  static message = /aa90/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Bundler has not set a beneficiary address.', {\n      cause,\n      name: 'InvalidBeneficiaryError',\n    })\n  }\n}\n\nexport type InvalidFieldsErrorType = InvalidFieldsError & {\n  name: 'InvalidFieldsError'\n}\nexport class InvalidFieldsError extends BaseError {\n  static code = -32602\n\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Invalid fields set on User Operation.', {\n      cause,\n      name: 'InvalidFieldsError',\n    })\n  }\n}\n\nexport type InvalidPaymasterAndDataErrorType = InvalidPaymasterAndDataError & {\n  name: 'InvalidPaymasterAndDataError'\n}\nexport class InvalidPaymasterAndDataError extends BaseError {\n  static message = /aa93/\n  constructor({\n    cause,\n    paymasterAndData,\n  }: {\n    cause?: BaseError | undefined\n    paymasterAndData?: Hex | undefined\n  }) {\n    super('Paymaster properties provided are invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `paymasterAndData` property is of an incorrect length\\n',\n        paymasterAndData && `paymasterAndData: ${paymasterAndData}`,\n      ].filter(Boolean) as string[],\n      name: 'InvalidPaymasterAndDataError',\n    })\n  }\n}\n\nexport type PaymasterDepositTooLowErrorType = PaymasterDepositTooLowError & {\n  code: -32508\n  name: 'PaymasterDepositTooLowError'\n}\nexport class PaymasterDepositTooLowError extends BaseError {\n  static code = -32508\n  static message = /aa31/\n\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster deposit for the User Operation is too low.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the Paymaster has deposited less than the expected amount via the `deposit` function',\n      ].filter(Boolean) as string[],\n      name: 'PaymasterDepositTooLowError',\n    })\n  }\n}\n\nexport type PaymasterFunctionRevertedErrorType =\n  PaymasterFunctionRevertedError & {\n    name: 'PaymasterFunctionRevertedError'\n  }\nexport class PaymasterFunctionRevertedError extends BaseError {\n  static message = /aa33/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The `validatePaymasterUserOp` function on the Paymaster reverted.', {\n      cause,\n      name: 'PaymasterFunctionRevertedError',\n    })\n  }\n}\n\nexport type PaymasterNotDeployedErrorType = PaymasterNotDeployedError & {\n  name: 'PaymasterNotDeployedError'\n}\nexport class PaymasterNotDeployedError extends BaseError {\n  static message = /aa30/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The Paymaster contract has not been deployed.', {\n      cause,\n      name: 'PaymasterNotDeployedError',\n    })\n  }\n}\n\nexport type PaymasterRateLimitErrorType = PaymasterRateLimitError & {\n  code: -32504\n  name: 'PaymasterRateLimitError'\n}\nexport class PaymasterRateLimitError extends BaseError {\n  static code = -32504\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.',\n      {\n        cause,\n        name: 'PaymasterRateLimitError',\n      },\n    )\n  }\n}\n\nexport type PaymasterStakeTooLowErrorType = PaymasterStakeTooLowError & {\n  code: -32505\n  name: 'PaymasterStakeTooLowError'\n}\nexport class PaymasterStakeTooLowError extends BaseError {\n  static code = -32505\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.',\n      {\n        cause,\n        name: 'PaymasterStakeTooLowError',\n      },\n    )\n  }\n}\n\nexport type PaymasterPostOpFunctionRevertedErrorType =\n  PaymasterPostOpFunctionRevertedError & {\n    name: 'PaymasterPostOpFunctionRevertedError'\n  }\nexport class PaymasterPostOpFunctionRevertedError extends BaseError {\n  static message = /aa50/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster `postOp` function reverted.', {\n      cause,\n      name: 'PaymasterPostOpFunctionRevertedError',\n    })\n  }\n}\n\nexport type SenderAlreadyConstructedErrorType =\n  SenderAlreadyConstructedError & {\n    name: 'SenderAlreadyConstructedError'\n  }\nexport class SenderAlreadyConstructedError extends BaseError {\n  static message = /aa10/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super('Smart Account has already been deployed.', {\n      cause,\n      metaMessages: [\n        'Remove the following properties and try again:',\n        factory && '`factory`',\n        factoryData && '`factoryData`',\n        initCode && '`initCode`',\n      ].filter(Boolean) as string[],\n      name: 'SenderAlreadyConstructedError',\n    })\n  }\n}\n\nexport type SignatureCheckFailedErrorType = SignatureCheckFailedError & {\n  code: -32507\n  name: 'SignatureCheckFailedError'\n}\nexport class SignatureCheckFailedError extends BaseError {\n  static code = -32507\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because account signature check failed (or paymaster signature, if the paymaster uses its data as signature).',\n      {\n        cause,\n        name: 'SignatureCheckFailedError',\n      },\n    )\n  }\n}\n\nexport type SmartAccountFunctionRevertedErrorType =\n  SmartAccountFunctionRevertedError & {\n    name: 'SmartAccountFunctionRevertedError'\n  }\nexport class SmartAccountFunctionRevertedError extends BaseError {\n  static message = /aa23/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The `validateUserOp` function on the Smart Account reverted.', {\n      cause,\n      name: 'SmartAccountFunctionRevertedError',\n    })\n  }\n}\n\nexport type UnsupportedSignatureAggregatorErrorType =\n  UnsupportedSignatureAggregatorError & {\n    code: -32506\n    name: 'UnsupportedSignatureAggregatorError'\n  }\nexport class UnsupportedSignatureAggregatorError extends BaseError {\n  static code = -32506\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because account specified unsupported signature aggregator.',\n      {\n        cause,\n        name: 'UnsupportedSignatureAggregatorError',\n      },\n    )\n  }\n}\n\nexport type UserOperationExpiredErrorType = UserOperationExpiredError & {\n  name: 'UserOperationExpiredError'\n}\nexport class UserOperationExpiredError extends BaseError {\n  static message = /aa22/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation expired.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `validAfter` or `validUntil` values returned from `validateUserOp` on the Smart Account are not satisfied',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationExpiredError',\n    })\n  }\n}\n\nexport type UserOperationPaymasterExpiredErrorType =\n  UserOperationPaymasterExpiredError & {\n    name: 'UserOperationPaymasterExpiredError'\n  }\nexport class UserOperationPaymasterExpiredError extends BaseError {\n  static message = /aa32/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster for User Operation expired.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `validAfter` or `validUntil` values returned from `validatePaymasterUserOp` on the Paymaster are not satisfied',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationPaymasterExpiredError',\n    })\n  }\n}\n\nexport type UserOperationSignatureErrorType = UserOperationSignatureError & {\n  name: 'UserOperationSignatureError'\n}\nexport class UserOperationSignatureError extends BaseError {\n  static message = /aa24/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Signature provided for the User Operation is invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Smart Account',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationSignatureError',\n    })\n  }\n}\n\nexport type UserOperationPaymasterSignatureErrorType =\n  UserOperationPaymasterSignatureError & {\n    name: 'UserOperationPaymasterSignatureError'\n  }\nexport class UserOperationPaymasterSignatureError extends BaseError {\n  static message = /aa34/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Signature provided for the User Operation is invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Paymaster',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationPaymasterSignatureError',\n    })\n  }\n}\n\nexport type UserOperationRejectedByEntryPointErrorType =\n  UserOperationRejectedByEntryPointError & {\n    code: -32500\n    name: 'UserOperationRejectedByEntryPointError'\n  }\nexport class UserOperationRejectedByEntryPointError extends BaseError {\n  static code = -32500\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      \"User Operation rejected by EntryPoint's `simulateValidation` during account creation or validation.\",\n      {\n        cause,\n        name: 'UserOperationRejectedByEntryPointError',\n      },\n    )\n  }\n}\n\nexport type UserOperationRejectedByPaymasterErrorType =\n  UserOperationRejectedByPaymasterError & {\n    code: -32501\n    name: 'UserOperationRejectedByPaymasterError'\n  }\nexport class UserOperationRejectedByPaymasterError extends BaseError {\n  static code = -32501\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\"User Operation rejected by Paymaster's `validatePaymasterUserOp`.\", {\n      cause,\n      name: 'UserOperationRejectedByPaymasterError',\n    })\n  }\n}\n\nexport type UserOperationRejectedByOpCodeErrorType =\n  UserOperationRejectedByOpCodeError & {\n    code: -32502\n    name: 'UserOperationRejectedByOpCodeError'\n  }\nexport class UserOperationRejectedByOpCodeError extends BaseError {\n  static code = -32502\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super('User Operation rejected with op code validation error.', {\n      cause,\n      name: 'UserOperationRejectedByOpCodeError',\n    })\n  }\n}\n\nexport type UserOperationOutOfTimeRangeErrorType =\n  UserOperationOutOfTimeRangeError & {\n    code: -32503\n    name: 'UserOperationOutOfTimeRangeError'\n  }\nexport class UserOperationOutOfTimeRangeError extends BaseError {\n  static code = -32503\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation out of time-range: either wallet or paymaster returned a time-range, and it is already expired (or will expire soon).',\n      {\n        cause,\n        name: 'UserOperationOutOfTimeRangeError',\n      },\n    )\n  }\n}\n\nexport type UnknownBundlerErrorType = UnknownBundlerError & {\n  name: 'UnknownBundlerError'\n}\nexport class UnknownBundlerError extends BaseError {\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      `An error occurred while executing user operation: ${cause?.shortMessage}`,\n      {\n        cause,\n        name: 'UnknownBundlerError',\n      },\n    )\n  }\n}\n\nexport type VerificationGasLimitExceededErrorType =\n  VerificationGasLimitExceededError & {\n    name: 'VerificationGasLimitExceededError'\n  }\nexport class VerificationGasLimitExceededError extends BaseError {\n  static message = /aa40/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation verification gas limit exceeded.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the gas used for verification exceeded the `verificationGasLimit`',\n      ].filter(Boolean) as string[],\n      name: 'VerificationGasLimitExceededError',\n    })\n  }\n}\n\nexport type VerificationGasLimitTooLowErrorType =\n  VerificationGasLimitTooLowError & {\n    name: 'VerificationGasLimitTooLowError'\n  }\nexport class VerificationGasLimitTooLowError extends BaseError {\n  static message = /aa41/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation verification gas limit is too low.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `verificationGasLimit` is too low to verify the User Operation',\n      ].filter(Boolean) as string[],\n      name: 'VerificationGasLimitTooLowError',\n    })\n  }\n}\n", "import { BaseError } from '../../errors/base.js'\nimport { prettyPrint } from '../../errors/transaction.js'\nimport type { Hash } from '../../types/misc.js'\nimport { formatGwei } from '../../utils/index.js'\nimport type { UserOperation } from '../types/userOperation.js'\n\nexport type UserOperationExecutionErrorType = UserOperationExecutionError & {\n  name: 'UserOperationExecutionError'\n}\nexport class UserOperationExecutionError extends BaseError {\n  override cause: BaseError\n\n  constructor(\n    cause: BaseError,\n    {\n      callData,\n      callGasLimit,\n      docsPath,\n      factory,\n      factoryData,\n      initCode,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      paymaster,\n      paymasterAndData,\n      paymasterData,\n      paymasterPostOpGasLimit,\n      paymasterVerificationGasLimit,\n      preVerificationGas,\n      sender,\n      signature,\n      verificationGasLimit,\n    }: UserOperation & {\n      docsPath?: string | undefined\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      callData,\n      callGasLimit,\n      factory,\n      factoryData,\n      initCode,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n      paymaster,\n      paymasterAndData,\n      paymasterData,\n      paymasterPostOpGasLimit,\n      paymasterVerificationGasLimit,\n      preVerificationGas,\n      sender,\n      signature,\n      verificationGasLimit,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n      name: 'UserOperationExecutionError',\n    })\n    this.cause = cause\n  }\n}\n\nexport type UserOperationReceiptNotFoundErrorType =\n  UserOperationReceiptNotFoundError & {\n    name: 'UserOperationReceiptNotFoundError'\n  }\nexport class UserOperationReceiptNotFoundError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `User Operation receipt with hash \"${hash}\" could not be found. The User Operation may not have been processed yet.`,\n      { name: 'UserOperationReceiptNotFoundError' },\n    )\n  }\n}\n\nexport type UserOperationNotFoundErrorType = UserOperationNotFoundError & {\n  name: 'UserOperationNotFoundError'\n}\nexport class UserOperationNotFoundError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(`User Operation with hash \"${hash}\" could not be found.`, {\n      name: 'UserOperationNotFoundError',\n    })\n  }\n}\n\nexport type WaitForUserOperationReceiptTimeoutErrorType =\n  WaitForUserOperationReceiptTimeoutError & {\n    name: 'WaitForUserOperationReceiptTimeoutError'\n  }\nexport class WaitForUserOperationReceiptTimeoutError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for User Operation with hash \"${hash}\" to be confirmed.`,\n      { name: 'WaitForUserOperationReceiptTimeoutError' },\n    )\n  }\n}\n", "import type { BaseError } from '../../../errors/base.js'\nimport type { ExactPartial } from '../../../types/utils.js'\nimport {\n  AccountNotDeployedError,\n  type AccountNotDeployedErrorType,\n  ExecutionRevertedError,\n  type ExecutionRevertedErrorType,\n  FailedToSendToBeneficiaryError,\n  type FailedToSendToBeneficiaryErrorType,\n  GasValuesOverflowError,\n  type GasValuesOverflowErrorType,\n  HandleOpsOutOfGasError,\n  type HandleOpsOutOfGasErrorType,\n  InitCodeFailedError,\n  type InitCodeFailedErrorType,\n  InitCodeMustCreateSenderError,\n  type InitCodeMustCreateSenderErrorType,\n  InitCodeMustReturnSenderError,\n  type InitCodeMustReturnSenderErrorType,\n  InsufficientPrefundError,\n  type InsufficientPrefundErrorType,\n  InternalCallOnlyError,\n  type InternalCallOnlyErrorType,\n  InvalidAccountNonceError,\n  type InvalidAccountNonceErrorType,\n  InvalidAggregatorError,\n  type InvalidAggregatorErrorType,\n  InvalidBeneficiaryError,\n  type InvalidBeneficiaryErrorType,\n  InvalidFieldsError,\n  type InvalidFieldsErrorType,\n  InvalidPaymasterAndDataError,\n  type InvalidPaymasterAndDataErrorType,\n  PaymasterDepositTooLowError,\n  type PaymasterDepositTooLowErrorType,\n  PaymasterFunctionRevertedError,\n  type PaymasterFunctionRevertedErrorType,\n  PaymasterNotDeployedError,\n  type PaymasterNotDeployedErrorType,\n  PaymasterPostOpFunctionRevertedError,\n  type PaymasterPostOpFunctionRevertedErrorType,\n  PaymasterRateLimitError,\n  type PaymasterRateLimitErrorType,\n  PaymasterStakeTooLowError,\n  type PaymasterStakeTooLowErrorType,\n  SenderAlreadyConstructedError,\n  type SenderAlreadyConstructedErrorType,\n  SignatureCheckFailedError,\n  type SignatureCheckFailedErrorType,\n  SmartAccountFunctionRevertedError,\n  type SmartAccountFunctionRevertedErrorType,\n  UnknownBundlerError,\n  type UnknownBundlerErrorType,\n  UnsupportedSignatureAggregatorError,\n  type UnsupportedSignatureAggregatorErrorType,\n  UserOperationExpiredError,\n  type UserOperationExpiredErrorType,\n  UserOperationOutOfTimeRangeError,\n  type UserOperationOutOfTimeRangeErrorType,\n  UserOperationPaymasterExpiredError,\n  type UserOperationPaymasterExpiredErrorType,\n  UserOperationPaymasterSignatureError,\n  type UserOperationPaymasterSignatureErrorType,\n  UserOperationRejectedByEntryPointError,\n  type UserOperationRejectedByEntryPointErrorType,\n  UserOperationRejectedByOpCodeError,\n  type UserOperationRejectedByOpCodeErrorType,\n  UserOperationRejectedByPaymasterError,\n  type UserOperationRejectedByPaymasterErrorType,\n  UserOperationSignatureError,\n  type UserOperationSignatureErrorType,\n  VerificationGasLimitExceededError,\n  type VerificationGasLimitExceededErrorType,\n  VerificationGasLimitTooLowError,\n  type VerificationGasLimitTooLowErrorType,\n} from '../../errors/bundler.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nconst bundlerErrors = [\n  ExecutionRevertedError,\n  InvalidFieldsError,\n  PaymasterDepositTooLowError,\n  PaymasterRateLimitError,\n  PaymasterStakeTooLowError,\n  SignatureCheckFailedError,\n  UnsupportedSignatureAggregatorError,\n  UserOperationOutOfTimeRangeError,\n  UserOperationRejectedByEntryPointError,\n  UserOperationRejectedByPaymasterError,\n  UserOperationRejectedByOpCodeError,\n]\n\nexport type GetBundlerErrorParameters = ExactPartial<UserOperation>\n\nexport type GetBundlerErrorReturnType =\n  | AccountNotDeployedErrorType\n  | ExecutionRevertedErrorType\n  | FailedToSendToBeneficiaryErrorType\n  | GasValuesOverflowErrorType\n  | HandleOpsOutOfGasErrorType\n  | InitCodeFailedErrorType\n  | InitCodeMustCreateSenderErrorType\n  | InitCodeMustReturnSenderErrorType\n  | InsufficientPrefundErrorType\n  | InternalCallOnlyErrorType\n  | InvalidAccountNonceErrorType\n  | InvalidAggregatorErrorType\n  | InvalidBeneficiaryErrorType\n  | InvalidFieldsErrorType\n  | InvalidPaymasterAndDataErrorType\n  | PaymasterDepositTooLowErrorType\n  | PaymasterFunctionRevertedErrorType\n  | PaymasterNotDeployedErrorType\n  | PaymasterPostOpFunctionRevertedErrorType\n  | PaymasterRateLimitErrorType\n  | PaymasterStakeTooLowErrorType\n  | SignatureCheckFailedErrorType\n  | SenderAlreadyConstructedErrorType\n  | SmartAccountFunctionRevertedErrorType\n  | UnsupportedSignatureAggregatorErrorType\n  | UserOperationOutOfTimeRangeErrorType\n  | UserOperationRejectedByEntryPointErrorType\n  | UserOperationRejectedByOpCodeErrorType\n  | UserOperationRejectedByPaymasterErrorType\n  | UnknownBundlerErrorType\n  | UserOperationExpiredErrorType\n  | UserOperationPaymasterExpiredErrorType\n  | UserOperationPaymasterSignatureErrorType\n  | UserOperationSignatureErrorType\n  | VerificationGasLimitExceededErrorType\n  | VerificationGasLimitTooLowErrorType\n\nexport function getBundlerError(\n  err: BaseError,\n  args: GetBundlerErrorParameters,\n): GetBundlerErrorReturnType {\n  const message = (err.details || '').toLowerCase()\n\n  if (AccountNotDeployedError.message.test(message))\n    return new AccountNotDeployedError({\n      cause: err,\n    }) as any\n  if (FailedToSendToBeneficiaryError.message.test(message))\n    return new FailedToSendToBeneficiaryError({\n      cause: err,\n    }) as any\n  if (GasValuesOverflowError.message.test(message))\n    return new GasValuesOverflowError({\n      cause: err,\n    }) as any\n  if (HandleOpsOutOfGasError.message.test(message))\n    return new HandleOpsOutOfGasError({\n      cause: err,\n    }) as any\n  if (InitCodeFailedError.message.test(message))\n    return new InitCodeFailedError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (InitCodeMustCreateSenderError.message.test(message))\n    return new InitCodeMustCreateSenderError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (InitCodeMustReturnSenderError.message.test(message))\n    return new InitCodeMustReturnSenderError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n      sender: args.sender,\n    }) as any\n  if (InsufficientPrefundError.message.test(message))\n    return new InsufficientPrefundError({\n      cause: err,\n    }) as any\n  if (InternalCallOnlyError.message.test(message))\n    return new InternalCallOnlyError({\n      cause: err,\n    }) as any\n  if (InvalidAccountNonceError.message.test(message))\n    return new InvalidAccountNonceError({\n      cause: err,\n      nonce: args.nonce,\n    }) as any\n  if (InvalidAggregatorError.message.test(message))\n    return new InvalidAggregatorError({\n      cause: err,\n    }) as any\n  if (InvalidBeneficiaryError.message.test(message))\n    return new InvalidBeneficiaryError({\n      cause: err,\n    }) as any\n  if (InvalidPaymasterAndDataError.message.test(message))\n    return new InvalidPaymasterAndDataError({\n      cause: err,\n    }) as any\n  if (PaymasterDepositTooLowError.message.test(message))\n    return new PaymasterDepositTooLowError({\n      cause: err,\n    }) as any\n  if (PaymasterFunctionRevertedError.message.test(message))\n    return new PaymasterFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (PaymasterNotDeployedError.message.test(message))\n    return new PaymasterNotDeployedError({\n      cause: err,\n    }) as any\n  if (PaymasterPostOpFunctionRevertedError.message.test(message))\n    return new PaymasterPostOpFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (SmartAccountFunctionRevertedError.message.test(message))\n    return new SmartAccountFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (SenderAlreadyConstructedError.message.test(message))\n    return new SenderAlreadyConstructedError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (UserOperationExpiredError.message.test(message))\n    return new UserOperationExpiredError({\n      cause: err,\n    }) as any\n  if (UserOperationPaymasterExpiredError.message.test(message))\n    return new UserOperationPaymasterExpiredError({\n      cause: err,\n    }) as any\n  if (UserOperationPaymasterSignatureError.message.test(message))\n    return new UserOperationPaymasterSignatureError({\n      cause: err,\n    }) as any\n  if (UserOperationSignatureError.message.test(message))\n    return new UserOperationSignatureError({\n      cause: err,\n    }) as any\n  if (VerificationGasLimitExceededError.message.test(message))\n    return new VerificationGasLimitExceededError({\n      cause: err,\n    }) as any\n  if (VerificationGasLimitTooLowError.message.test(message))\n    return new VerificationGasLimitTooLowError({\n      cause: err,\n    }) as any\n\n  const error = err.walk((e) =>\n    bundlerErrors.some((error) => error.code === (e as { code: number }).code),\n  ) as BaseError & { code: number; data: any }\n\n  if (error) {\n    if (error.code === ExecutionRevertedError.code)\n      return new ExecutionRevertedError({\n        cause: err,\n        data: error.data,\n        message: error.details,\n      }) as any\n    if (error.code === InvalidFieldsError.code)\n      return new InvalidFieldsError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterDepositTooLowError.code)\n      return new PaymasterDepositTooLowError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterRateLimitError.code)\n      return new PaymasterRateLimitError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterStakeTooLowError.code)\n      return new PaymasterStakeTooLowError({\n        cause: err,\n      }) as any\n    if (error.code === SignatureCheckFailedError.code)\n      return new SignatureCheckFailedError({\n        cause: err,\n      }) as any\n    if (error.code === UnsupportedSignatureAggregatorError.code)\n      return new UnsupportedSignatureAggregatorError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationOutOfTimeRangeError.code)\n      return new UserOperationOutOfTimeRangeError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByEntryPointError.code)\n      return new UserOperationRejectedByEntryPointError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByPaymasterError.code)\n      return new UserOperationRejectedByPaymasterError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByOpCodeError.code)\n      return new UserOperationRejectedByOpCodeError({\n        cause: err,\n      }) as any\n  }\n\n  return new UnknownBundlerError({\n    cause: err,\n  }) as any\n}\n", "import type { Abi, Address } from 'abitype'\nimport { BaseError } from '../../../errors/base.js'\nimport {\n  ContractFunctionExecutionError,\n  ContractFunctionRevertedError,\n  ContractFunctionZeroDataError,\n} from '../../../errors/contract.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Call } from '../../../types/calls.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { decodeErrorResult } from '../../../utils/abi/decodeErrorResult.js'\nimport type { GetContractErrorReturnType } from '../../../utils/errors/getContractError.js'\nimport { ExecutionRevertedError } from '../../errors/bundler.js'\nimport {\n  UserOperationExecutionError,\n  type UserOperationExecutionErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type GetBundlerErrorParameters,\n  getBundlerError,\n} from './getBundlerError.js'\n\ntype GetNodeErrorReturnType = ErrorType\n\nexport type GetUserOperationErrorParameters = UserOperation & {\n  calls?: readonly unknown[] | undefined\n  docsPath?: string | undefined\n}\n\nexport type GetUserOperationErrorReturnType<cause = ErrorType> = Omit<\n  UserOperationExecutionErrorType,\n  'cause'\n> & { cause: cause | GetNodeErrorReturnType }\n\nexport type GetUserOperationErrorErrorType = ErrorType\n\nexport function getUserOperationError<err extends ErrorType<string>>(\n  err: err,\n  { calls, docsPath, ...args }: GetUserOperationErrorParameters,\n): GetUserOperationErrorReturnType<err> {\n  const cause = (() => {\n    const cause = getBundlerError(\n      err as {} as BaseError,\n      args as GetBundlerErrorParameters,\n    )\n    if (calls && cause instanceof ExecutionRevertedError) {\n      const revertData = getRevertData(cause)\n      const contractCalls = calls?.filter(\n        (call: any) => call.abi,\n      ) as readonly Call[]\n      if (revertData && contractCalls.length > 0)\n        return getContractError({ calls: contractCalls, revertData })\n    }\n    return cause\n  })()\n  return new UserOperationExecutionError(cause, {\n    docsPath,\n    ...args,\n  }) as GetUserOperationErrorReturnType<err>\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n\nfunction getRevertData(error: BaseError) {\n  let revertData: Hex | undefined\n  error.walk((e) => {\n    const error = e as any\n    if (\n      typeof error.data === 'string' ||\n      typeof error.data?.revertData === 'string' ||\n      (!(error instanceof BaseError) && typeof error.message === 'string')\n    ) {\n      const match = (\n        error.data?.revertData ||\n        error.data ||\n        error.message\n      ).match?.(/(0x[A-Za-z0-9]*)/)\n      if (match) {\n        revertData = match[1]\n        return true\n      }\n    }\n    return false\n  })\n  return revertData\n}\n\nfunction getContractError(parameters: {\n  calls: readonly Call[]\n  revertData: Hex\n}) {\n  const { calls, revertData } = parameters\n\n  const { abi, functionName, args, to } = (() => {\n    const contractCalls = calls?.filter((call) =>\n      Boolean(call.abi),\n    ) as readonly Call[]\n\n    if (contractCalls.length === 1) return contractCalls[0]\n\n    const compatContractCalls = contractCalls.filter((call) => {\n      try {\n        return Boolean(\n          decodeErrorResult({\n            abi: call.abi,\n            data: revertData,\n          }),\n        )\n      } catch {\n        return false\n      }\n    })\n    if (compatContractCalls.length === 1) return compatContractCalls[0]\n\n    return {\n      abi: [],\n      functionName: contractCalls.reduce(\n        (acc, call) => `${acc ? `${acc} | ` : ''}${call.functionName}`,\n        '',\n      ),\n      args: undefined,\n      to: undefined,\n    }\n  })() as {\n    abi: Abi\n    functionName: string\n    args: unknown[]\n    to: Address\n  }\n\n  const cause = (() => {\n    if (revertData === '0x')\n      return new ContractFunctionZeroDataError({ functionName })\n    return new ContractFunctionRevertedError({\n      abi,\n      data: revertData,\n      functionName,\n    })\n  })()\n  return new ContractFunctionExecutionError(cause as BaseError, {\n    abi,\n    args,\n    contractAddress: to,\n    functionName,\n  }) as GetContractErrorReturnType\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { RpcEstimateUserOperationGasReturnType } from '../../types/rpc.js'\nimport type { EstimateUserOperationGasReturnType } from '../../types/userOperation.js'\n\nexport type FormatUserOperationGasErrorType = ErrorType\n\nexport function formatUserOperationGas(\n  parameters: RpcEstimateUserOperationGasReturnType,\n): EstimateUserOperationGasReturnType {\n  const gas = {} as EstimateUserOperationGasReturnType\n\n  if (parameters.callGasLimit)\n    gas.callGasLimit = BigInt(parameters.callGasLimit)\n  if (parameters.preVerificationGas)\n    gas.preVerificationGas = BigInt(parameters.preVerificationGas)\n  if (parameters.verificationGasLimit)\n    gas.verificationGasLimit = BigInt(parameters.verificationGasLimit)\n  if (parameters.paymasterPostOpGasLimit)\n    gas.paymasterPostOpGasLimit = BigInt(parameters.paymasterPostOpGasLimit)\n  if (parameters.paymasterVerificationGasLimit)\n    gas.paymasterVerificationGasLimit = BigInt(\n      parameters.paymasterVerificationGasLimit,\n    )\n\n  return gas\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { SignedAuthorization } from '../../../types/authorization.js'\nimport type { ExactPartial } from '../../../types/utils.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport { pad } from '../../../utils/index.js'\nimport type { RpcUserOperation } from '../../types/rpc.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nexport type FormatUserOperationRequestErrorType = ErrorType\n\nexport function formatUserOperationRequest(\n  request: ExactPartial<UserOperation>,\n) {\n  const rpcRequest = {} as RpcUserOperation\n\n  if (typeof request.callData !== 'undefined')\n    rpcRequest.callData = request.callData\n  if (typeof request.callGasLimit !== 'undefined')\n    rpcRequest.callGasLimit = numberToHex(request.callGasLimit)\n  if (typeof request.factory !== 'undefined')\n    rpcRequest.factory = request.factory\n  if (typeof request.factoryData !== 'undefined')\n    rpcRequest.factoryData = request.factoryData\n  if (typeof request.initCode !== 'undefined')\n    rpcRequest.initCode = request.initCode\n  if (typeof request.maxFeePerGas !== 'undefined')\n    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas)\n  if (typeof request.maxPriorityFeePerGas !== 'undefined')\n    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas)\n  if (typeof request.nonce !== 'undefined')\n    rpcRequest.nonce = numberToHex(request.nonce)\n  if (typeof request.paymaster !== 'undefined')\n    rpcRequest.paymaster = request.paymaster\n  if (typeof request.paymasterAndData !== 'undefined')\n    rpcRequest.paymasterAndData = request.paymasterAndData || '0x'\n  if (typeof request.paymasterData !== 'undefined')\n    rpcRequest.paymasterData = request.paymasterData\n  if (typeof request.paymasterPostOpGasLimit !== 'undefined')\n    rpcRequest.paymasterPostOpGasLimit = numberToHex(\n      request.paymasterPostOpGasLimit,\n    )\n  if (typeof request.paymasterVerificationGasLimit !== 'undefined')\n    rpcRequest.paymasterVerificationGasLimit = numberToHex(\n      request.paymasterVerificationGasLimit,\n    )\n  if (typeof request.preVerificationGas !== 'undefined')\n    rpcRequest.preVerificationGas = numberToHex(request.preVerificationGas)\n  if (typeof request.sender !== 'undefined') rpcRequest.sender = request.sender\n  if (typeof request.signature !== 'undefined')\n    rpcRequest.signature = request.signature\n  if (typeof request.verificationGasLimit !== 'undefined')\n    rpcRequest.verificationGasLimit = numberToHex(request.verificationGasLimit)\n  if (typeof request.authorization !== 'undefined')\n    rpcRequest.eip7702Auth = formatAuthorization(request.authorization)\n\n  return rpcRequest\n}\n\nfunction formatAuthorization(authorization: SignedAuthorization) {\n  return {\n    address: authorization.address,\n    chainId: numberToHex(authorization.chainId),\n    nonce: numberToHex(authorization.nonce),\n    r: authorization.r\n      ? numberToHex(BigInt(authorization.r), { size: 32 })\n      : pad('0x', { size: 32 }),\n    s: authorization.s\n      ? numberToHex(BigInt(authorization.s), { size: 32 })\n      : pad('0x', { size: 32 }),\n    yParity: authorization.yParity\n      ? numberToHex(authorization.yParity, { size: 1 })\n      : pad('0x', { size: 32 }),\n  }\n}\n", "import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { OneOf, PartialBy, Prettify } from '../../../types/utils.js'\nimport { hexToBigInt } from '../../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\n\nexport type GetPaymasterDataParameters = OneOf<\n  | PartialBy<\n      Pick<\n        UserOperation<'0.6'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'initCode'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'initCode'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.7'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n        | 'paymasterPostOpGasLimit'\n        | 'paymasterVerificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.8'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n        | 'paymasterPostOpGasLimit'\n        | 'paymasterVerificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n> & {\n  context?: unknown | undefined\n  chainId: number\n  entryPointAddress: Address\n}\n\nexport type GetPaymasterDataReturnType = Prettify<\n  OneOf<\n    | { paymasterAndData: Hex }\n    | {\n        paymaster: Address\n        paymasterData: Hex\n        paymasterPostOpGasLimit?: bigint | undefined\n        paymasterVerificationGasLimit?: bigint | undefined\n      }\n  >\n>\n\nexport type GetPaymasterDataErrorType =\n  | FormatUserOperationRequestErrorType\n  | ErrorType\n\n/**\n * Retrieves paymaster-related User Operation properties to be used for sending the User Operation.\n *\n * - Docs: https://viem.sh/account-abstraction/actions/paymaster/getPaymasterData\n *\n * @param client - Client to use\n * @param parameters - {@link GetPaymasterDataParameters}\n * @returns Paymaster-related User Operation properties. {@link GetPaymasterDataReturnType}\n *\n * @example\n * import { http } from 'viem'\n * import { createPaymasterClient, getPaymasterData } from 'viem/account-abstraction'\n *\n * const paymasterClient = createPaymasterClient({\n *   transport: http('https://...'),\n * })\n *\n * const userOperation = { ... }\n *\n * const values = await getPaymasterData(paymasterClient, {\n *   chainId: 1,\n *   entryPointAddress: '0x...',\n *   ...userOperation,\n * })\n */\nexport async function getPaymasterData(\n  client: Client<Transport>,\n  parameters: GetPaymasterDataParameters,\n): Promise<GetPaymasterDataReturnType> {\n  const { chainId, entryPointAddress, context, ...userOperation } = parameters\n  const request = formatUserOperationRequest(userOperation)\n  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } =\n    await client.request({\n      method: 'pm_getPaymasterData',\n      params: [\n        {\n          ...request,\n          callGasLimit: request.callGasLimit ?? '0x0',\n          verificationGasLimit: request.verificationGasLimit ?? '0x0',\n          preVerificationGas: request.preVerificationGas ?? '0x0',\n        },\n        entryPointAddress,\n        numberToHex(chainId),\n        context,\n      ],\n    })\n  return {\n    ...rest,\n    ...(paymasterPostOpGasLimit && {\n      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit),\n    }),\n    ...(paymasterVerificationGasLimit && {\n      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit),\n    }),\n  } as unknown as GetPaymasterDataReturnType\n}\n", "import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { OneOf, PartialBy, Prettify } from '../../../types/utils.js'\nimport { hexToBigInt } from '../../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\n\nexport type GetPaymasterStubDataParameters = OneOf<\n  | PartialBy<\n      Pick<\n        UserOperation<'0.6'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'initCode'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'initCode'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.7'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n> & {\n  context?: unknown | undefined\n  chainId: number\n  entryPointAddress: Address\n}\n\nexport type GetPaymasterStubDataReturnType = Prettify<\n  OneOf<\n    | { paymasterAndData: Hex }\n    | {\n        paymaster: Address\n        paymasterData: Hex\n        paymasterVerificationGasLimit?: bigint | undefined\n        paymasterPostOpGasLimit: bigint\n      }\n  > & {\n    sponsor?: { name: string; icon?: string | undefined } | undefined\n    isFinal?: boolean | undefined\n  }\n>\n\nexport type GetPaymasterStubDataErrorType =\n  | FormatUserOperationRequestErrorType\n  | ErrorType\n\n/**\n * Retrieves paymaster-related User Operation properties to be used for gas estimation.\n *\n * - Docs: https://viem.sh/account-abstraction/actions/paymaster/getPaymasterStubData\n *\n * @param client - Client to use\n * @param parameters - {@link GetPaymasterStubDataParameters}\n * @returns Paymaster-related User Operation properties. {@link GetPaymasterStubDataReturnType}\n *\n * @example\n * import { http } from 'viem'\n * import { createPaymasterClient, getPaymasterStubData } from 'viem/account-abstraction'\n *\n * const paymasterClient = createPaymasterClient({\n *   transport: http('https://...'),\n * })\n *\n * const userOperation = { ... }\n *\n * const values = await getPaymasterStubData(paymasterClient, {\n *   chainId: 1,\n *   entryPointAddress: '0x...',\n *   ...userOperation,\n * })\n */\nexport async function getPaymasterStubData(\n  client: Client<Transport>,\n  parameters: GetPaymasterStubDataParameters,\n): Promise<GetPaymasterStubDataReturnType> {\n  const { chainId, entryPointAddress, context, ...userOperation } = parameters\n  const request = formatUserOperationRequest(userOperation)\n  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } =\n    await client.request({\n      method: 'pm_getPaymasterStubData',\n      params: [\n        {\n          ...request,\n          callGasLimit: request.callGasLimit ?? '0x0',\n          verificationGasLimit: request.verificationGasLimit ?? '0x0',\n          preVerificationGas: request.preVerificationGas ?? '0x0',\n        },\n        entryPointAddress,\n        numberToHex(chainId),\n        context,\n      ],\n    })\n  return {\n    ...rest,\n    ...(paymasterPostOpGasLimit && {\n      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit),\n    }),\n    ...(paymasterVerificationGasLimit && {\n      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit),\n    }),\n  } as unknown as GetPaymasterStubDataReturnType\n}\n", "import type { Address, Narrow } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport { prepareAuthorization } from '../../../actions/index.js'\nimport {\n  type EstimateFeesPerGasErrorType,\n  estimateFeesPerGas,\n} from '../../../actions/public/estimateFeesPerGas.js'\nimport { getChainId as getChainId_ } from '../../../actions/public/getChainId.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { SignedAuthorization } from '../../../types/authorization.js'\nimport type { Call, Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { StateOverride } from '../../../types/stateOverride.js'\nimport type {\n  Assign,\n  OneOf,\n  Prettify,\n  UnionOmit,\n} from '../../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport { type ConcatErrorType, concat } from '../../../utils/data/concat.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { BundlerClient } from '../../clients/createBundlerClient.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport {\n  type GetPaymasterDataErrorType,\n  getPaymasterData as getPaymasterData_,\n} from '../paymaster/getPaymasterData.js'\nimport {\n  type GetPaymasterStubDataErrorType,\n  getPaymasterStubData as getPaymasterStubData_,\n} from '../paymaster/getPaymasterStubData.js'\nimport {\n  type EstimateUserOperationGasParameters,\n  estimateUserOperationGas,\n} from './estimateUserOperationGas.js'\n\nconst defaultParameters = [\n  'factory',\n  'fees',\n  'gas',\n  'paymaster',\n  'nonce',\n  'signature',\n  'authorization',\n] as const\n\nexport type PrepareUserOperationParameterType =\n  | 'factory'\n  | 'fees'\n  | 'gas'\n  | 'paymaster'\n  | 'nonce'\n  | 'signature'\n  | 'authorization'\n\ntype FactoryProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          factory: UserOperation['factory']\n          factoryData: UserOperation['factoryData']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          factory: UserOperation['factory']\n          factoryData: UserOperation['factoryData']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          initCode: UserOperation['initCode']\n        }\n      : never)\n\ntype GasProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n        }\n      : never)\n\ntype FeeProperties = {\n  maxFeePerGas: UserOperation['maxFeePerGas']\n  maxPriorityFeePerGas: UserOperation['maxPriorityFeePerGas']\n}\n\ntype NonceProperties = {\n  nonce: UserOperation['nonce']\n}\n\ntype PaymasterProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          paymaster: UserOperation['paymaster']\n          paymasterData: UserOperation['paymasterData']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          paymaster: UserOperation['paymaster']\n          paymasterData: UserOperation['paymasterData']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          paymasterAndData: UserOperation['paymasterAndData']\n        }\n      : never)\n\ntype SignatureProperties = {\n  signature: UserOperation['signature']\n}\n\ntype AuthorizationProperties = {\n  authorization: UserOperation['authorization']\n}\n\nexport type PrepareUserOperationRequest<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Assign<\n  UserOperationRequest<_derivedVersion>,\n  OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n    parameters?: readonly PrepareUserOperationParameterType[] | undefined\n    paymaster?:\n      | Address\n      | true\n      | {\n          /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n          getPaymasterData?: PaymasterActions['getPaymasterData'] | undefined\n          /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n          getPaymasterStubData?:\n            | PaymasterActions['getPaymasterStubData']\n            | undefined\n        }\n      | undefined\n    /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n    paymasterContext?: unknown | undefined\n    /** State overrides for the User Operation call. */\n    stateOverride?: StateOverride | undefined\n  }\n>\n\nexport type PrepareUserOperationParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  > = PrepareUserOperationRequest<account, accountOverride, calls>,\n> = request & GetSmartAccountParameter<account, accountOverride>\n\nexport type PrepareUserOperationReturnType<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  > = PrepareUserOperationRequest<account, accountOverride, calls>,\n  //\n  _parameters extends\n    PrepareUserOperationParameterType = request['parameters'] extends readonly PrepareUserOperationParameterType[]\n    ? request['parameters'][number]\n    : (typeof defaultParameters)[number],\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Prettify<\n  UnionOmit<request, 'calls' | 'parameters'> & {\n    callData: Hex\n    paymasterAndData: _derivedVersion extends '0.6' ? Hex : undefined\n    sender: UserOperation['sender']\n  } & (Extract<_parameters, 'authorization'> extends never\n      ? {}\n      : AuthorizationProperties) &\n    (Extract<_parameters, 'factory'> extends never\n      ? {}\n      : FactoryProperties<_derivedVersion>) &\n    (Extract<_parameters, 'nonce'> extends never ? {} : NonceProperties) &\n    (Extract<_parameters, 'fees'> extends never ? {} : FeeProperties) &\n    (Extract<_parameters, 'gas'> extends never\n      ? {}\n      : GasProperties<_derivedVersion>) &\n    (Extract<_parameters, 'paymaster'> extends never\n      ? {}\n      : PaymasterProperties<_derivedVersion>) &\n    (Extract<_parameters, 'signature'> extends never ? {} : SignatureProperties)\n>\n\nexport type PrepareUserOperationErrorType =\n  | ParseAccountErrorType\n  | GetPaymasterStubDataErrorType\n  | GetPaymasterDataErrorType\n  | EncodeFunctionDataErrorType\n  | ConcatErrorType\n  | EstimateFeesPerGasErrorType\n  | ErrorType\n\n/**\n * Prepares a User Operation and fills in missing properties.\n *\n * - Docs: https://viem.sh/actions/bundler/prepareUserOperation\n *\n * @param args - {@link PrepareUserOperationParameters}\n * @returns The User Operation. {@link PrepareUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const request = await prepareUserOperation(client, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function prepareUserOperation<\n  account extends SmartAccount | undefined,\n  const calls extends readonly unknown[],\n  const request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  >,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters_: PrepareUserOperationParameters<\n    account,\n    accountOverride,\n    calls,\n    request\n  >,\n): Promise<\n  PrepareUserOperationReturnType<account, accountOverride, calls, request>\n> {\n  const parameters = parameters_ as PrepareUserOperationParameters\n  const {\n    account: account_ = client.account,\n    parameters: properties = defaultParameters,\n    stateOverride,\n  } = parameters\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Assert that an Account is defined.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (!account_) throw new AccountNotFoundError()\n  const account = parseAccount(account_)\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare typed Bundler Client.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const bundlerClient = client as unknown as BundlerClient\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare Paymaster properties.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const paymaster = parameters.paymaster ?? bundlerClient?.paymaster\n  const paymasterAddress = typeof paymaster === 'string' ? paymaster : undefined\n  const { getPaymasterStubData, getPaymasterData } = (() => {\n    // If `paymaster: true`, we will assume the Bundler Client supports Paymaster Actions.\n    if (paymaster === true)\n      return {\n        getPaymasterStubData: (parameters: any) =>\n          getAction(\n            bundlerClient,\n            getPaymasterStubData_,\n            'getPaymasterStubData',\n          )(parameters),\n        getPaymasterData: (parameters: any) =>\n          getAction(\n            bundlerClient,\n            getPaymasterData_,\n            'getPaymasterData',\n          )(parameters),\n      }\n\n    // If Actions are passed to `paymaster` (via Paymaster Client or directly), we will use them.\n    if (typeof paymaster === 'object') {\n      const { getPaymasterStubData, getPaymasterData } = paymaster\n      return {\n        getPaymasterStubData: (getPaymasterData && getPaymasterStubData\n          ? getPaymasterStubData\n          : getPaymasterData) as typeof getPaymasterStubData,\n        getPaymasterData:\n          getPaymasterData && getPaymasterStubData\n            ? getPaymasterData\n            : undefined,\n      }\n    }\n\n    // No Paymaster functions.\n    return {\n      getPaymasterStubData: undefined,\n      getPaymasterData: undefined,\n    }\n  })()\n  const paymasterContext = parameters.paymasterContext\n    ? parameters.paymasterContext\n    : bundlerClient?.paymasterContext\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Set up the User Operation request.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  let request = {\n    ...parameters,\n    paymaster: paymasterAddress,\n    sender: account.address,\n  } as PrepareUserOperationRequest\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Concurrently prepare properties required to fill the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const [callData, factory, fees, nonce, authorization] = await Promise.all([\n    (async () => {\n      if (parameters.calls)\n        return account.encodeCalls(\n          parameters.calls.map((call_) => {\n            const call = call_ as Call\n            if (call.abi)\n              return {\n                data: encodeFunctionData(call),\n                to: call.to,\n                value: call.value,\n              } as Call\n            return call as Call\n          }),\n        )\n      return parameters.callData\n    })(),\n    (async () => {\n      if (!properties.includes('factory')) return undefined\n      if (parameters.initCode) return { initCode: parameters.initCode }\n      if (parameters.factory && parameters.factoryData) {\n        return {\n          factory: parameters.factory,\n          factoryData: parameters.factoryData,\n        }\n      }\n\n      const { factory, factoryData } = await account.getFactoryArgs()\n\n      if (account.entryPoint.version === '0.6')\n        return {\n          initCode:\n            factory && factoryData ? concat([factory, factoryData]) : undefined,\n        }\n      return {\n        factory,\n        factoryData,\n      }\n    })(),\n    (async () => {\n      if (!properties.includes('fees')) return undefined\n\n      // If we have sufficient properties for fees, return them.\n      if (\n        typeof parameters.maxFeePerGas === 'bigint' &&\n        typeof parameters.maxPriorityFeePerGas === 'bigint'\n      )\n        return request\n\n      // If the Bundler Client has a `estimateFeesPerGas` hook, run it.\n      if (bundlerClient?.userOperation?.estimateFeesPerGas) {\n        const fees = await bundlerClient.userOperation.estimateFeesPerGas({\n          account,\n          bundlerClient,\n          userOperation: request as UserOperation,\n        })\n        return {\n          ...request,\n          ...fees,\n        }\n      }\n\n      // Otherwise, we will need to estimate the fees to fill the fee properties.\n      try {\n        const client_ = bundlerClient.client ?? client\n        const fees = await getAction(\n          client_,\n          estimateFeesPerGas,\n          'estimateFeesPerGas',\n        )({\n          chain: client_.chain,\n          type: 'eip1559',\n        })\n        return {\n          maxFeePerGas:\n            typeof parameters.maxFeePerGas === 'bigint'\n              ? parameters.maxFeePerGas\n              : BigInt(\n                  // Bundlers unfortunately have strict rules on fee prechecks – we will need to set a generous buffer.\n                  2n * fees.maxFeePerGas,\n                ),\n          maxPriorityFeePerGas:\n            typeof parameters.maxPriorityFeePerGas === 'bigint'\n              ? parameters.maxPriorityFeePerGas\n              : BigInt(\n                  // Bundlers unfortunately have strict rules on fee prechecks – we will need to set a generous buffer.\n                  2n * fees.maxPriorityFeePerGas,\n                ),\n        }\n      } catch {\n        return undefined\n      }\n    })(),\n    (async () => {\n      if (!properties.includes('nonce')) return undefined\n      if (typeof parameters.nonce === 'bigint') return parameters.nonce\n      return account.getNonce()\n    })(),\n    (async () => {\n      if (!properties.includes('authorization')) return undefined\n      if (typeof parameters.authorization === 'object')\n        return parameters.authorization\n      if (account.authorization && !(await account.isDeployed())) {\n        const authorization = await prepareAuthorization(\n          account.client,\n          account.authorization,\n        )\n        return {\n          ...authorization,\n          r: '0xfffffffffffffffffffffffffffffff000000000000000000000000000000000',\n          s: '0x7aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n          yParity: 1,\n        } satisfies SignedAuthorization\n      }\n      return undefined\n    })(),\n  ])\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the prepared properties from above.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (typeof callData !== 'undefined') request.callData = callData\n  if (typeof factory !== 'undefined')\n    request = { ...request, ...(factory as any) }\n  if (typeof fees !== 'undefined') request = { ...request, ...(fees as any) }\n  if (typeof nonce !== 'undefined') request.nonce = nonce\n  if (typeof authorization !== 'undefined')\n    request.authorization = authorization\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the `signature` property.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (properties.includes('signature')) {\n    if (typeof parameters.signature !== 'undefined')\n      request.signature = parameters.signature\n    else\n      request.signature = await account.getStubSignature(\n        request as UserOperation,\n      )\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // `initCode` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If no `initCode` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.initCode)\n    request.initCode = '0x'\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **gas estimation**.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  let chainId: number | undefined\n  async function getChainId(): Promise<number> {\n    if (chainId) return chainId\n    if (client.chain) return client.chain.id\n    const chainId_ = await getAction(client, getChainId_, 'getChainId')({})\n    chainId = chainId_\n    return chainId\n  }\n\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to estimate the User Operation gas.\n  let isPaymasterPopulated = false\n  if (\n    properties.includes('paymaster') &&\n    getPaymasterStubData &&\n    !paymasterAddress &&\n    !parameters.paymasterAndData\n  ) {\n    const {\n      isFinal = false,\n      sponsor: _,\n      ...paymasterArgs\n    } = await getPaymasterStubData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...(request as UserOperation),\n    })\n    isPaymasterPopulated = isFinal\n    request = {\n      ...request,\n      ...paymasterArgs,\n    } as PrepareUserOperationRequest\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // `paymasterAndData` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If no `paymasterAndData` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.paymasterAndData)\n    request.paymasterAndData = '0x'\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with gas-related properties.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (properties.includes('gas')) {\n    // If the Account has opinionated gas estimation logic, run the `estimateGas` hook and\n    // fill the request with the prepared gas properties.\n    if (account.userOperation?.estimateGas) {\n      const gas = await account.userOperation.estimateGas(\n        request as UserOperation,\n      )\n      request = {\n        ...request,\n        ...gas,\n      } as PrepareUserOperationRequest\n    }\n\n    // If not all the gas properties are already populated, we will need to estimate the gas\n    // to fill the gas properties.\n    if (\n      typeof request.callGasLimit === 'undefined' ||\n      typeof request.preVerificationGas === 'undefined' ||\n      typeof request.verificationGasLimit === 'undefined' ||\n      (request.paymaster &&\n        typeof request.paymasterPostOpGasLimit === 'undefined') ||\n      (request.paymaster &&\n        typeof request.paymasterVerificationGasLimit === 'undefined')\n    ) {\n      const gas = await getAction(\n        bundlerClient,\n        estimateUserOperationGas,\n        'estimateUserOperationGas',\n      )({\n        account,\n        // Some Bundlers fail if nullish gas values are provided for gas estimation :') –\n        // so we will need to set a default zeroish value.\n        callGasLimit: 0n,\n        preVerificationGas: 0n,\n        verificationGasLimit: 0n,\n        stateOverride,\n        ...(request.paymaster\n          ? {\n              paymasterPostOpGasLimit: 0n,\n              paymasterVerificationGasLimit: 0n,\n            }\n          : {}),\n        ...request,\n      } as EstimateUserOperationGasParameters)\n      request = {\n        ...request,\n        callGasLimit: request.callGasLimit ?? gas.callGasLimit,\n        preVerificationGas:\n          request.preVerificationGas ?? gas.preVerificationGas,\n        verificationGasLimit:\n          request.verificationGasLimit ?? gas.verificationGasLimit,\n        paymasterPostOpGasLimit:\n          request.paymasterPostOpGasLimit ?? gas.paymasterPostOpGasLimit,\n        paymasterVerificationGasLimit:\n          request.paymasterVerificationGasLimit ??\n          gas.paymasterVerificationGasLimit,\n      } as PrepareUserOperationRequest\n    }\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **sending** the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to send the User Operation.\n  if (\n    properties.includes('paymaster') &&\n    getPaymasterData &&\n    !paymasterAddress &&\n    !parameters.paymasterAndData &&\n    !isPaymasterPopulated\n  ) {\n    // Retrieve paymaster-related User Operation properties to be used for **sending** the User Operation.\n    const paymaster = await getPaymasterData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...(request as UserOperation),\n    })\n    request = {\n      ...request,\n      ...paymaster,\n    } as PrepareUserOperationRequest\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Remove redundant properties that do not conform to the User Operation schema.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  delete request.calls\n  delete request.parameters\n  delete request.paymasterContext\n  if (typeof request.paymaster !== 'string') delete request.paymaster\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n  return request as unknown as PrepareUserOperationReturnType<\n    account,\n    accountOverride,\n    calls,\n    request\n  >\n}\n", "import type { Address, Narrow } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { StateOverride } from '../../../types/stateOverride.js'\nimport type {\n  Assign,\n  MaybeRequired,\n  OneOf,\n  Prettify,\n} from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { serializeStateOverride } from '../../../utils/stateOverride.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  EstimateUserOperationGasReturnType as EstimateUserOperationGasReturnType_,\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js'\nimport {\n  type FormatUserOperationGasErrorType,\n  formatUserOperationGas,\n} from '../../utils/formatters/userOperationGas.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\nimport {\n  type PrepareUserOperationErrorType,\n  type PrepareUserOperationParameters,\n  prepareUserOperation,\n} from './prepareUserOperation.js'\n\nexport type EstimateUserOperationGasParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = GetSmartAccountParameter<account, accountOverride, false> &\n  (\n    | UserOperation // Accept a full-formed User Operation.\n    | Assign<\n        // Accept a partially-formed User Operation (UserOperationRequest) to be filled.\n        UserOperationRequest<_derivedVersion>,\n        OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n          paymaster?:\n            | Address\n            | true\n            | {\n                /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n                getPaymasterData?:\n                  | PaymasterActions['getPaymasterData']\n                  | undefined\n                /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n                getPaymasterStubData?:\n                  | PaymasterActions['getPaymasterStubData']\n                  | undefined\n              }\n            | undefined\n          /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n          paymasterContext?: unknown | undefined\n        }\n      >\n  ) &\n  // Allow the EntryPoint address to be overridden, if no Account is provided, it will need to be required.\n  MaybeRequired<\n    { entryPointAddress?: Address },\n    _derivedAccount extends undefined ? true : false\n  > & {\n    /** State overrides for the User Operation call. */\n    stateOverride?: StateOverride | undefined\n  }\n\nexport type EstimateUserOperationGasReturnType<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Prettify<EstimateUserOperationGasReturnType_<_derivedVersion>>\n\nexport type EstimateUserOperationGasErrorType =\n  | ParseAccountErrorType\n  | PrepareUserOperationErrorType\n  | FormatUserOperationRequestErrorType\n  | FormatUserOperationGasErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns an estimate of gas values necessary to execute the User Operation.\n *\n * - Docs: https://viem.sh/actions/bundler/estimateUserOperationGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateUserOperationGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateUserOperationGasReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { estimateUserOperationGas } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await estimateUserOperationGas(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function estimateUserOperationGas<\n  const calls extends readonly unknown[],\n  account extends SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters: EstimateUserOperationGasParameters<\n    account,\n    accountOverride,\n    calls\n  >,\n): Promise<EstimateUserOperationGasReturnType<account, accountOverride>> {\n  const {\n    account: account_ = client.account,\n    entryPointAddress,\n    stateOverride,\n  } = parameters\n\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError()\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const rpcStateOverride = serializeStateOverride(stateOverride)\n\n  const request = account\n    ? await getAction(\n        client,\n        prepareUserOperation,\n        'prepareUserOperation',\n      )({\n        ...parameters,\n        parameters: [\n          'authorization',\n          'factory',\n          'nonce',\n          'paymaster',\n          'signature',\n        ],\n      } as unknown as PrepareUserOperationParameters)\n    : parameters\n\n  try {\n    const params = [\n      formatUserOperationRequest(request as UserOperation),\n      (entryPointAddress ?? account?.entryPoint?.address)!,\n    ] as const\n\n    const result = await client.request({\n      method: 'eth_estimateUserOperationGas',\n      params: rpcStateOverride ? [...params, rpcStateOverride] : [...params],\n    })\n    return formatUserOperationGas(result) as EstimateUserOperationGasReturnType<\n      account,\n      accountOverride\n    >\n  } catch (error) {\n    const calls = (parameters as any).calls\n    throw getUserOperationError(error as BaseError, {\n      ...(request as UserOperation),\n      ...(calls ? { calls } : {}),\n    })\n  }\n}\n", "import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\n\nexport type GetSupportedEntryPointsReturnType = readonly Address[]\nexport type GetSupportedEntryPointsErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the EntryPoints that the bundler supports.\n *\n * - Docs: https://viem.sh/actions/bundler/getSupportedEntryPoints\n *\n * @param client - Client to use\n * @param parameters - {@link GetSupportedEntryPointsParameters}\n * @returns Supported Entry Points. {@link GetSupportedEntryPointsReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getSupportedEntryPoints } from 'viem/actions'\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const addresses = await getSupportedEntryPoints(bundlerClient)\n */\nexport function getSupportedEntryPoints(client: Client<Transport>) {\n  return client.request({ method: 'eth_supportedEntryPoints' })\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { RpcUserOperation } from '../../types/rpc.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nexport type FormatUserOperationErrorType = ErrorType\n\nexport function formatUserOperation(parameters: RpcUserOperation) {\n  const userOperation = { ...parameters } as unknown as UserOperation\n\n  if (parameters.callGasLimit)\n    userOperation.callGasLimit = BigInt(parameters.callGasLimit)\n  if (parameters.maxFeePerGas)\n    userOperation.maxFeePerGas = BigInt(parameters.maxFeePerGas)\n  if (parameters.maxPriorityFeePerGas)\n    userOperation.maxPriorityFeePerGas = BigInt(parameters.maxPriorityFeePerGas)\n  if (parameters.nonce) userOperation.nonce = BigInt(parameters.nonce)\n  if (parameters.paymasterPostOpGasLimit)\n    userOperation.paymasterPostOpGasLimit = BigInt(\n      parameters.paymasterPostOpGasLimit,\n    )\n  if (parameters.paymasterVerificationGasLimit)\n    userOperation.paymasterVerificationGasLimit = BigInt(\n      parameters.paymasterVerificationGasLimit,\n    )\n  if (parameters.preVerificationGas)\n    userOperation.preVerificationGas = BigInt(parameters.preVerificationGas)\n  if (parameters.verificationGasLimit)\n    userOperation.verificationGasLimit = BigInt(parameters.verificationGasLimit)\n\n  return userOperation\n}\n", "import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport {\n  UserOperationNotFoundError,\n  type UserOperationNotFoundErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport { formatUserOperation } from '../../utils/formatters/userOperation.js'\n\nexport type GetUserOperationParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n}\n\nexport type GetUserOperationReturnType = Prettify<{\n  /** The block hash the User Operation was included on. */\n  blockHash: Hash\n  /** The block number the User Operation was included on. */\n  blockNumber: bigint\n  /** The EntryPoint which handled the User Operation. */\n  entryPoint: Address\n  /** The hash of the transaction which included the User Operation. */\n  transactionHash: Hash\n  /** The User Operation. */\n  userOperation: UserOperation\n}>\n\nexport type GetUserOperationErrorType =\n  | RequestErrorType\n  | UserOperationNotFoundErrorType\n  | ErrorType\n\n/**\n * Retrieves information about a User Operation given a hash.\n *\n * - Docs: https://viem.sh/account-abstraction/actions/bundler/getUserOperation\n *\n * @param client - Client to use\n * @param parameters - {@link GetUserOperationParameters}\n * @returns The receipt. {@link GetUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getUserOperation } from 'viem/actions\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getUserOperation(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getUserOperation(\n  client: Client<Transport>,\n  { hash }: GetUserOperationParameters,\n) {\n  const result = await client.request(\n    {\n      method: 'eth_getUserOperationByHash',\n      params: [hash],\n    },\n    { dedupe: true },\n  )\n\n  if (!result) throw new UserOperationNotFoundError({ hash })\n\n  const { blockHash, blockNumber, entryPoint, transactionHash, userOperation } =\n    result\n\n  return {\n    blockHash,\n    blockNumber: BigInt(blockNumber),\n    entryPoint,\n    transactionHash,\n    userOperation: formatUserOperation(userOperation),\n  }\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport { formatLog } from '../../../utils/formatters/log.js'\nimport { formatTransactionReceipt } from '../../../utils/formatters/transactionReceipt.js'\nimport type { RpcUserOperationReceipt } from '../../types/rpc.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\n\nexport type FormatUserOperationReceiptErrorType = ErrorType\n\nexport function formatUserOperationReceipt(\n  parameters: RpcUserOperationReceipt,\n) {\n  const receipt = { ...parameters } as unknown as UserOperationReceipt\n\n  if (parameters.actualGasCost)\n    receipt.actualGasCost = BigInt(parameters.actualGasCost)\n  if (parameters.actualGasUsed)\n    receipt.actualGasUsed = BigInt(parameters.actualGasUsed)\n  if (parameters.logs)\n    receipt.logs = parameters.logs.map((log) => formatLog(log)) as any\n  if (parameters.receipt)\n    receipt.receipt = formatTransactionReceipt(receipt.receipt as any)\n\n  return receipt\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport {\n  UserOperationReceiptNotFoundError,\n  type UserOperationReceiptNotFoundErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\nimport { formatUserOperationReceipt } from '../../utils/formatters/userOperationReceipt.js'\n\nexport type GetUserOperationReceiptParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n}\n\nexport type GetUserOperationReceiptReturnType = Prettify<UserOperationReceipt>\n\nexport type GetUserOperationReceiptErrorType =\n  | RequestErrorType\n  | UserOperationReceiptNotFoundErrorType\n  | ErrorType\n\n/**\n * Returns the User Operation Receipt given a User Operation hash.\n *\n * - Docs: https://viem.sh/docs/actions/bundler/getUserOperationReceipt\n *\n * @param client - Client to use\n * @param parameters - {@link GetUserOperationReceiptParameters}\n * @returns The receipt. {@link GetUserOperationReceiptReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getUserOperationReceipt } from 'viem/actions\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getUserOperationReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getUserOperationReceipt(\n  client: Client<Transport>,\n  { hash }: GetUserOperationReceiptParameters,\n) {\n  const receipt = await client.request(\n    {\n      method: 'eth_getUserOperationReceipt',\n      params: [hash],\n    },\n    { dedupe: true },\n  )\n\n  if (!receipt) throw new UserOperationReceiptNotFoundError({ hash })\n\n  return formatUserOperationReceipt(receipt)\n}\n", "import type { Address, Narrow } from 'abitype'\nimport { parseAccount } from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { Assign, MaybeRequired, OneOf } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\nimport {\n  type PrepareUserOperationErrorType,\n  type PrepareUserOperationParameters,\n  prepareUserOperation,\n} from './prepareUserOperation.js'\n\nexport type SendUserOperationParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = GetSmartAccountParameter<account, accountOverride, false> &\n  (\n    | UserOperation // Accept a full-formed User Operation.\n    | Assign<\n        // Accept a partially-formed User Operation (UserOperationRequest) to be filled.\n        UserOperationRequest<_derivedVersion>,\n        OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n          paymaster?:\n            | Address\n            | true\n            | {\n                /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n                getPaymasterData?:\n                  | PaymasterActions['getPaymasterData']\n                  | undefined\n                /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n                getPaymasterStubData?:\n                  | PaymasterActions['getPaymasterStubData']\n                  | undefined\n              }\n            | undefined\n          /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n          paymasterContext?: unknown | undefined\n        }\n      >\n  ) &\n  // Allow the EntryPoint address to be overridden, if no Account is provided, it will need to be required.\n  MaybeRequired<\n    { entryPointAddress?: Address },\n    _derivedAccount extends undefined ? true : false\n  >\nexport type SendUserOperationReturnType = Hex\n\nexport type SendUserOperationErrorType =\n  | FormatUserOperationRequestErrorType\n  | PrepareUserOperationErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Broadcasts a User Operation to the Bundler.\n *\n * - Docs: https://viem.sh/actions/bundler/sendUserOperation\n *\n * @param client - Client to use\n * @param parameters - {@link SendUserOperationParameters}\n * @returns The User Operation hash. {@link SendUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { toSmartAccount } from 'viem/accounts'\n * import { sendUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await sendUserOperation(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function sendUserOperation<\n  const calls extends readonly unknown[],\n  account extends SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters: SendUserOperationParameters<account, accountOverride, calls>,\n) {\n  const { account: account_ = client.account, entryPointAddress } = parameters\n\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError()\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const request = account\n    ? await getAction(\n        client,\n        prepareUserOperation,\n        'prepareUserOperation',\n      )(parameters as unknown as PrepareUserOperationParameters)\n    : parameters\n\n  const signature = (parameters.signature ||\n    (await account?.signUserOperation?.(request as UserOperation)))!\n\n  const rpcParameters = formatUserOperationRequest({\n    ...request,\n    signature,\n  } as UserOperation)\n\n  try {\n    return await client.request(\n      {\n        method: 'eth_sendUserOperation',\n        params: [\n          rpcParameters,\n          (entryPointAddress ?? account?.entryPoint?.address)!,\n        ],\n      },\n      { retryCount: 0 },\n    )\n  } catch (error) {\n    const calls = (parameters as any).calls\n    throw getUserOperationError(error as BaseError, {\n      ...(request as UserOperation),\n      ...(calls ? { calls } : {}),\n      signature,\n    })\n  }\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../../utils/poll.js'\nimport { stringify } from '../../../utils/stringify.js'\nimport {\n  WaitForUserOperationReceiptTimeoutError,\n  type WaitForUserOperationReceiptTimeoutErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\nimport {\n  type GetUserOperationReceiptErrorType,\n  getUserOperationReceipt,\n} from './getUserOperationReceipt.js'\n\nexport type WaitForUserOperationReceiptParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * The number of times to retry.\n   * @default 6\n   */\n  retryCount?: number | undefined\n  /** Optional timeout (in ms) to wait before stopping polling. */\n  timeout?: number | undefined\n}\n\nexport type WaitForUserOperationReceiptReturnType =\n  Prettify<UserOperationReceipt>\n\nexport type WaitForUserOperationReceiptErrorType =\n  | WaitForUserOperationReceiptTimeoutErrorType\n  | PollErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the User Operation receipt.\n *\n * - Docs: https://viem.sh/docs/actions/bundler/waitForUserOperationReceipt\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForUserOperationReceiptParameters}\n * @returns The receipt. {@link WaitForUserOperationReceiptReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForUserOperationReceipt } from 'viem/actions'\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await waitForUserOperationReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport function waitForUserOperationReceipt(\n  client: Client<Transport>,\n  parameters: WaitForUserOperationReceiptParameters,\n): Promise<WaitForUserOperationReceiptReturnType> {\n  const {\n    hash,\n    pollingInterval = client.pollingInterval,\n    retryCount,\n    timeout = 120_000,\n  } = parameters\n\n  let count = 0\n  const observerId = stringify([\n    'waitForUserOperationReceipt',\n    client.uid,\n    hash,\n  ])\n\n  return new Promise((resolve, reject) => {\n    const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n      const done = (fn: () => void) => {\n        unpoll()\n        fn()\n        unobserve()\n      }\n\n      const unpoll = poll(\n        async () => {\n          if (retryCount && count >= retryCount)\n            done(() =>\n              emit.reject(\n                new WaitForUserOperationReceiptTimeoutError({ hash }),\n              ),\n            )\n\n          try {\n            const receipt = await getAction(\n              client,\n              getUserOperationReceipt,\n              'getUserOperationReceipt',\n            )({ hash })\n            done(() => emit.resolve(receipt))\n          } catch (err) {\n            const error = err as GetUserOperationReceiptErrorType\n            if (error.name !== 'UserOperationReceiptNotFoundError')\n              done(() => emit.reject(error))\n          }\n\n          count++\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      if (timeout)\n        setTimeout(\n          () =>\n            done(() =>\n              emit.reject(\n                new WaitForUserOperationReceiptTimeoutError({ hash }),\n              ),\n            ),\n          timeout,\n        )\n\n      return unpoll\n    })\n  })\n}\n", "import {\n  type GetChainIdReturnType,\n  getChainId,\n} from '../../../actions/public/getChainId.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport {\n  type EstimateUserOperationGasParameters,\n  type EstimateUserOperationGasReturnType,\n  estimateUserOperationGas,\n} from '../../actions/bundler/estimateUserOperationGas.js'\nimport {\n  type GetSupportedEntryPointsReturnType,\n  getSupportedEntryPoints,\n} from '../../actions/bundler/getSupportedEntryPoints.js'\nimport {\n  type GetUserOperationParameters,\n  type GetUserOperationReturnType,\n  getUserOperation,\n} from '../../actions/bundler/getUserOperation.js'\nimport {\n  type GetUserOperationReceiptParameters,\n  type GetUserOperationReceiptReturnType,\n  getUserOperationReceipt,\n} from '../../actions/bundler/getUserOperationReceipt.js'\nimport {\n  type PrepareUserOperationParameters,\n  type PrepareUserOperationRequest,\n  type PrepareUserOperationReturnType,\n  prepareUserOperation,\n} from '../../actions/bundler/prepareUserOperation.js'\nimport {\n  type SendUserOperationParameters,\n  type SendUserOperationReturnType,\n  sendUserOperation,\n} from '../../actions/bundler/sendUserOperation.js'\nimport {\n  type WaitForUserOperationReceiptParameters,\n  type WaitForUserOperationReceiptReturnType,\n  waitForUserOperationReceipt,\n} from '../../actions/bundler/waitForUserOperationReceipt.js'\n\nexport type BundlerActions<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n> = {\n  /**\n   * Returns an estimate of gas values necessary to execute the User Operation.\n   *\n   * - Docs: https://viem.sh/actions/bundler/estimateUserOperationGas\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateUserOperationGasParameters}\n   * @returns The gas estimate (in wei). {@link EstimateUserOperationGasReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = await toSmartAccount({ ... })\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const values = await bundlerClient.estimateUserOperationGas({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  estimateUserOperationGas: <\n    const calls extends readonly unknown[],\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: EstimateUserOperationGasParameters<\n      account,\n      accountOverride,\n      calls\n    >,\n  ) => Promise<EstimateUserOperationGasReturnType<account, accountOverride>>\n  /**\n   * Returns the chain ID associated with the bundler.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getChainId\n   * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n   *\n   * @returns The current chain ID. {@link GetChainIdReturnType}\n   *\n   * @example\n   * import { http } from 'viem'\n   * import { createBundlerClient, mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const chainId = await client.getChainId()\n   * // 1\n   */\n  getChainId: () => Promise<GetChainIdReturnType>\n  /**\n   * Returns the EntryPoints that the bundler supports.\n   *\n   * - Docs: https://viem.sh/actions/bundler/getSupportedEntryPoints\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetSupportedEntryPointsParameters}\n   * @returns Supported Entry Points. {@link GetSupportedEntryPointsReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const addresses = await bundlerClient.getSupportedEntryPoints()\n   */\n  getSupportedEntryPoints: () => Promise<GetSupportedEntryPointsReturnType>\n  /**\n   * Returns the information about a User Operation given a hash.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/getUserOperation\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetUserOperationParameters}\n   * @returns The receipt. {@link GetUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.getUserOperation({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getUserOperation: (\n    parameters: GetUserOperationParameters,\n  ) => Promise<GetUserOperationReturnType>\n  /**\n   * Returns the User Operation Receipt given a User Operation hash.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/getUserOperationReceipt\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetUserOperationReceiptParameters}\n   * @returns The receipt. {@link GetUserOperationReceiptReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.getUserOperationReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getUserOperationReceipt: (\n    parameters: GetUserOperationReceiptParameters,\n  ) => Promise<GetUserOperationReceiptReturnType>\n  /**\n   * Prepares a User Operation and fills in missing properties.\n   *\n   * - Docs: https://viem.sh/actions/bundler/prepareUserOperation\n   *\n   * @param args - {@link PrepareUserOperationParameters}\n   * @returns The User Operation. {@link PrepareUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = await toSmartAccount({ ... })\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const request = await client.prepareUserOperation({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  prepareUserOperation: <\n    const calls extends readonly unknown[],\n    const request extends PrepareUserOperationRequest<\n      account,\n      accountOverride,\n      calls\n    >,\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: PrepareUserOperationParameters<\n      account,\n      accountOverride,\n      calls,\n      request\n    >,\n  ) => Promise<\n    PrepareUserOperationReturnType<account, accountOverride, calls, request>\n  >\n  /**\n   * Broadcasts a User Operation to the Bundler.\n   *\n   * - Docs: https://viem.sh/actions/bundler/sendUserOperation\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SendUserOperationParameters}\n   * @returns The User Operation hash. {@link SendUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = toSmartAccount({ ... })\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const values = await bundlerClient.sendUserOperation({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  sendUserOperation: <\n    const calls extends readonly unknown[],\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: SendUserOperationParameters<account, accountOverride, calls>,\n  ) => Promise<SendUserOperationReturnType>\n  /**\n   * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the User Operation receipt.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/waitForUserOperationReceipt\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WaitForUserOperationReceiptParameters}\n   * @returns The receipt. {@link WaitForUserOperationReceiptReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.waitForUserOperationReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  waitForUserOperationReceipt: (\n    parameters: WaitForUserOperationReceiptParameters,\n  ) => Promise<WaitForUserOperationReceiptReturnType>\n}\n\nexport function bundlerActions<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n>(client: Client<transport, chain, account>): BundlerActions<account> {\n  return {\n    estimateUserOperationGas: (parameters) =>\n      estimateUserOperationGas(client, parameters),\n    getChainId: () => getChainId(client),\n    getSupportedEntryPoints: () => getSupportedEntryPoints(client),\n    getUserOperation: (parameters) => getUserOperation(client, parameters),\n    getUserOperationReceipt: (parameters) =>\n      getUserOperationReceipt(client, parameters),\n    prepareUserOperation: (parameters) =>\n      prepareUserOperation(client, parameters),\n    sendUserOperation: (parameters) => sendUserOperation(client, parameters),\n    waitForUserOperationReceipt: (parameters) =>\n      waitForUserOperationReceipt(client, parameters),\n  }\n}\n", "import type { EstimateFeesPerGasReturnType } from '../../actions/public/estimateFeesPerGas.js'\nimport {\n  type Client,\n  type ClientConfig,\n  type CreateClientErrorType,\n  createClient,\n} from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { BundlerRpcSchema, RpcSchema } from '../../types/eip1193.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { SmartAccount } from '../accounts/types.js'\nimport type { UserOperationRequest } from '../types/userOperation.js'\nimport { type BundlerActions, bundlerActions } from './decorators/bundler.js'\nimport type { PaymasterActions } from './decorators/paymaster.js'\n\nexport type BundlerClientConfig<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  client extends Client | undefined = Client | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Pick<\n    ClientConfig<transport, chain, account, rpcSchema>,\n    | 'account'\n    | 'cacheTime'\n    | 'chain'\n    | 'key'\n    | 'name'\n    | 'pollingInterval'\n    | 'rpcSchema'\n    | 'transport'\n  >\n> & {\n  /** Client that points to an Execution RPC URL. */\n  client?: client | Client | undefined\n  /** Paymaster configuration. */\n  paymaster?:\n    | true\n    | {\n        /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n        getPaymasterData?: PaymasterActions['getPaymasterData'] | undefined\n        /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n        getPaymasterStubData?:\n          | PaymasterActions['getPaymasterStubData']\n          | undefined\n      }\n    | undefined\n  /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n  paymasterContext?: unknown\n  /** User Operation configuration. */\n  userOperation?:\n    | {\n        /** Prepares fee properties for the User Operation request. */\n        estimateFeesPerGas?:\n          | ((parameters: {\n              account: account | SmartAccount\n              bundlerClient: Client\n              userOperation: UserOperationRequest\n            }) => Promise<EstimateFeesPerGasReturnType<'eip1559'>>)\n          | undefined\n      }\n    | undefined\n}\n\nexport type BundlerClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  client extends Client | undefined = Client | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Client<\n    transport,\n    chain extends Chain\n      ? chain\n      : client extends Client<any, infer chain>\n        ? chain\n        : undefined,\n    account,\n    rpcSchema extends RpcSchema\n      ? [...BundlerRpcSchema, ...rpcSchema]\n      : BundlerRpcSchema,\n    BundlerActions<account>\n  >\n> & {\n  client: client\n  paymaster: BundlerClientConfig['paymaster'] | undefined\n  paymasterContext: BundlerClientConfig['paymasterContext'] | undefined\n  userOperation: BundlerClientConfig['userOperation'] | undefined\n}\n\nexport type CreateBundlerClientErrorType = CreateClientErrorType | ErrorType\n\n/**\n * Creates a Bundler Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).\n *\n * - Docs: https://viem.sh/account-abstraction/clients/bundler\n *\n * @param config - {@link BundlerClientConfig}\n * @returns A Bundler Client. {@link BundlerClient}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { createBundlerClient } from 'viem/account-abstraction'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const bundlerClient = createBundlerClient({\n *   client,\n *   transport: http('https://public.pimlico.io/v2/1/rpc'),\n * })\n */\nexport function createBundlerClient<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  account extends SmartAccount | undefined = undefined,\n  client extends Client | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n>(\n  parameters: BundlerClientConfig<transport, chain, account, client, rpcSchema>,\n): BundlerClient<transport, chain, account, client, rpcSchema>\n\nexport function createBundlerClient(\n  parameters: BundlerClientConfig,\n): BundlerClient {\n  const {\n    client: client_,\n    key = 'bundler',\n    name = 'Bundler Client',\n    paymaster,\n    paymasterContext,\n    transport,\n    userOperation,\n  } = parameters\n  const client = Object.assign(\n    createClient({\n      ...parameters,\n      chain: parameters.chain ?? client_?.chain,\n      key,\n      name,\n      transport,\n      type: 'bundlerClient',\n    }),\n    { client: client_, paymaster, paymasterContext, userOperation },\n  )\n  return client.extend(bundlerActions) as any\n}\n", "export const entryPoint06Abi = [\n  {\n    inputs: [\n      { name: 'preOpGas', type: 'uint256' },\n      { name: 'paid', type: 'uint256' },\n      { name: 'validAfter', type: 'uint48' },\n      { name: 'validUntil', type: 'uint48' },\n      { name: 'targetSuccess', type: 'bool' },\n      { name: 'targetResult', type: 'bytes' },\n    ],\n    name: 'ExecutionResult',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'preOpGas', type: 'uint256' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'sigFailed', type: 'bool' },\n          { name: 'validAfter', type: 'uint48' },\n          { name: 'validUntil', type: 'uint48' },\n          { name: 'paymasterContext', type: 'bytes' },\n        ],\n\n        name: 'returnInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'senderInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'factoryInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'paymasterInfo',\n        type: 'tuple',\n      },\n    ],\n    name: 'ValidationResult',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'preOpGas', type: 'uint256' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'sigFailed', type: 'bool' },\n          { name: 'validAfter', type: 'uint48' },\n          { name: 'validUntil', type: 'uint48' },\n          { name: 'paymasterContext', type: 'bytes' },\n        ],\n\n        name: 'returnInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'senderInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'factoryInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'paymasterInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'aggregator', type: 'address' },\n          {\n            components: [\n              { name: 'stake', type: 'uint256' },\n              {\n                name: 'unstakeDelaySec',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'stakeInfo',\n            type: 'tuple',\n          },\n        ],\n\n        name: 'aggregatorInfo',\n        type: 'tuple',\n      },\n    ],\n    name: 'ValidationResultWithAggregation',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'success', type: 'bool' },\n      {\n        indexed: false,\n\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'SIG_VALIDATION_FAILED',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'initCode', type: 'bytes' },\n      { name: 'sender', type: 'address' },\n      { name: 'paymasterAndData', type: 'bytes' },\n    ],\n    name: '_validateSenderAndPaymaster',\n    outputs: [],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'unstakeDelaySec', type: 'uint32' }],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: '', type: 'address' }],\n    name: 'deposits',\n    outputs: [\n      { name: 'deposit', type: 'uint112' },\n      { name: 'staked', type: 'bool' },\n      { name: 'stake', type: 'uint112' },\n      { name: 'unstakeDelaySec', type: 'uint32' },\n      { name: 'withdrawTime', type: 'uint48' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { name: 'deposit', type: 'uint112' },\n          { name: 'staked', type: 'bool' },\n          { name: 'stake', type: 'uint112' },\n          { name: 'unstakeDelaySec', type: 'uint32' },\n          { name: 'withdrawTime', type: 'uint48' },\n        ],\n\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'sender', type: 'address' },\n      { name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              { name: 'initCode', type: 'bytes' },\n              { name: 'callData', type: 'bytes' },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { name: 'signature', type: 'bytes' },\n            ],\n\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            name: 'aggregator',\n            type: 'address',\n          },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'paymaster', type: 'address' },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { name: 'userOpHash', type: 'bytes32' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'contextOffset', type: 'uint256' },\n          { name: 'preOpGas', type: 'uint256' },\n        ],\n\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [{ name: 'actualGasCost', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: '', type: 'address' },\n      { name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'op',\n        type: 'tuple',\n      },\n      { name: 'target', type: 'address' },\n      { name: 'targetCallData', type: 'bytes' },\n    ],\n    name: 'simulateHandleOp',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'simulateValidation',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\nexport const entryPoint07Abi = [\n  {\n    inputs: [\n      { name: 'success', type: 'bool' },\n      { name: 'ret', type: 'bytes' },\n    ],\n    name: 'DelegateAndRevert',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n      { name: 'inner', type: 'bytes' },\n    ],\n    name: 'FailedOpWithRevert',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'returnData', type: 'bytes' }],\n    name: 'PostOpReverted',\n    type: 'error',\n  },\n  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },\n  {\n    inputs: [{ name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'PostOpRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'success', type: 'bool' },\n      {\n        indexed: false,\n\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationPrefundTooLow',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [{ name: 'unstakeDelaySec', type: 'uint32' }],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'target', type: 'address' },\n      { name: 'data', type: 'bytes' },\n    ],\n    name: 'delegateAndRevert',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: '', type: 'address' }],\n    name: 'deposits',\n    outputs: [\n      { name: 'deposit', type: 'uint256' },\n      { name: 'staked', type: 'bool' },\n      { name: 'stake', type: 'uint112' },\n      { name: 'unstakeDelaySec', type: 'uint32' },\n      { name: 'withdrawTime', type: 'uint48' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { name: 'deposit', type: 'uint256' },\n          { name: 'staked', type: 'bool' },\n          { name: 'stake', type: 'uint112' },\n          { name: 'unstakeDelaySec', type: 'uint32' },\n          { name: 'withdrawTime', type: 'uint48' },\n        ],\n\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'sender', type: 'address' },\n      { name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          {\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'gasFees', type: 'bytes32' },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              { name: 'initCode', type: 'bytes' },\n              { name: 'callData', type: 'bytes' },\n              {\n                name: 'accountGasLimits',\n                type: 'bytes32',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'gasFees', type: 'bytes32' },\n              {\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { name: 'signature', type: 'bytes' },\n            ],\n\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            name: 'aggregator',\n            type: 'address',\n          },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          {\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'gasFees', type: 'bytes32' },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterVerificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterPostOpGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'paymaster', type: 'address' },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { name: 'userOpHash', type: 'bytes32' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'contextOffset', type: 'uint256' },\n          { name: 'preOpGas', type: 'uint256' },\n        ],\n\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [{ name: 'actualGasCost', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: '', type: 'address' },\n      { name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'interfaceId', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\nexport const entryPoint08Abi = [\n  { inputs: [], stateMutability: 'nonpayable', type: 'constructor' },\n  {\n    inputs: [\n      { internalType: 'bool', name: 'success', type: 'bool' },\n      { internalType: 'bytes', name: 'ret', type: 'bytes' },\n    ],\n    name: 'DelegateAndRevert',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'opIndex', type: 'uint256' },\n      { internalType: 'string', name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'opIndex', type: 'uint256' },\n      { internalType: 'string', name: 'reason', type: 'string' },\n      { internalType: 'bytes', name: 'inner', type: 'bytes' },\n    ],\n    name: 'FailedOpWithRevert',\n    type: 'error',\n  },\n  { inputs: [], name: 'InvalidShortString', type: 'error' },\n  {\n    inputs: [{ internalType: 'bytes', name: 'returnData', type: 'bytes' }],\n    name: 'PostOpReverted',\n    type: 'error',\n  },\n  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },\n  {\n    inputs: [{ internalType: 'address', name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    inputs: [{ internalType: 'string', name: 'str', type: 'string' }],\n    name: 'StringTooLong',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'EIP712DomainChanged', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'PostOpRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, internalType: 'bool', name: 'success', type: 'bool' },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationPrefundTooLow',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [\n      { internalType: 'uint32', name: 'unstakeDelaySec', type: 'uint32' },\n    ],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'target', type: 'address' },\n      { internalType: 'bytes', name: 'data', type: 'bytes' },\n    ],\n    name: 'delegateAndRevert',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'eip712Domain',\n    outputs: [\n      { internalType: 'bytes1', name: 'fields', type: 'bytes1' },\n      { internalType: 'string', name: 'name', type: 'string' },\n      { internalType: 'string', name: 'version', type: 'string' },\n      { internalType: 'uint256', name: 'chainId', type: 'uint256' },\n      { internalType: 'address', name: 'verifyingContract', type: 'address' },\n      { internalType: 'bytes32', name: 'salt', type: 'bytes32' },\n      { internalType: 'uint256[]', name: 'extensions', type: 'uint256[]' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { internalType: 'uint256', name: 'deposit', type: 'uint256' },\n          { internalType: 'bool', name: 'staked', type: 'bool' },\n          { internalType: 'uint112', name: 'stake', type: 'uint112' },\n          { internalType: 'uint32', name: 'unstakeDelaySec', type: 'uint32' },\n          { internalType: 'uint48', name: 'withdrawTime', type: 'uint48' },\n        ],\n        internalType: 'struct IStakeManager.DepositInfo',\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getDomainSeparatorV4',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'sender', type: 'address' },\n      { internalType: 'uint192', name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ internalType: 'uint256', name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getPackedUserOpTypeHash',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes', name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'sender', type: 'address' },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n          {\n            internalType: 'bytes32',\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n          { internalType: 'bytes', name: 'paymasterAndData', type: 'bytes' },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct PackedUserOperation',\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { internalType: 'address', name: 'sender', type: 'address' },\n              { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n              { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n              { internalType: 'bytes', name: 'callData', type: 'bytes' },\n              {\n                internalType: 'bytes32',\n                name: 'accountGasLimits',\n                type: 'bytes32',\n              },\n              {\n                internalType: 'uint256',\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n              {\n                internalType: 'bytes',\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { internalType: 'bytes', name: 'signature', type: 'bytes' },\n            ],\n            internalType: 'struct PackedUserOperation[]',\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            internalType: 'contract IAggregator',\n            name: 'aggregator',\n            type: 'address',\n          },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct IEntryPoint.UserOpsPerAggregator[]',\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { internalType: 'address payable', name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'sender', type: 'address' },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n          {\n            internalType: 'bytes32',\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n          { internalType: 'bytes', name: 'paymasterAndData', type: 'bytes' },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct PackedUserOperation[]',\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { internalType: 'address payable', name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint192', name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes', name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { internalType: 'address', name: 'sender', type: 'address' },\n              { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n              {\n                internalType: 'uint256',\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'paymasterVerificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'paymasterPostOpGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { internalType: 'address', name: 'paymaster', type: 'address' },\n              {\n                internalType: 'uint256',\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n            internalType: 'struct EntryPoint.MemoryUserOp',\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { internalType: 'bytes32', name: 'userOpHash', type: 'bytes32' },\n          { internalType: 'uint256', name: 'prefund', type: 'uint256' },\n          { internalType: 'uint256', name: 'contextOffset', type: 'uint256' },\n          { internalType: 'uint256', name: 'preOpGas', type: 'uint256' },\n        ],\n        internalType: 'struct EntryPoint.UserOpInfo',\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { internalType: 'bytes', name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [\n      { internalType: 'uint256', name: 'actualGasCost', type: 'uint256' },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '', type: 'address' },\n      { internalType: 'uint192', name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'senderCreator',\n    outputs: [\n      { internalType: 'contract ISenderCreator', name: '', type: 'address' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes4', name: 'interfaceId', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address payable',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address payable',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { internalType: 'uint256', name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n", "import { concat } from '../../../utils/data/concat.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nexport function getInitCode(\n  userOperation: Pick<\n    UserOperation,\n    'authorization' | 'factory' | 'factoryData'\n  >,\n) {\n  const { authorization, factory, factoryData } = userOperation\n  if (\n    factory === '0x7702' ||\n    factory === '0x7702000000000000000000000000000000000000'\n  ) {\n    if (!authorization) return '0x7702000000000000000000000000000000000000'\n    const delegation = authorization.address\n    return concat([delegation, factoryData ?? '0x'])\n  }\n  if (!factory) return '0x'\n  return concat([factory, factoryData ?? '0x'])\n}\n", "import { concat } from '../../../utils/data/concat.js'\nimport { pad } from '../../../utils/data/pad.js'\nimport { numberToHex } from '../../../utils/index.js'\nimport type {\n  PackedUserOperation,\n  UserOperation,\n} from '../../types/userOperation.js'\nimport { getInitCode } from './getInitCode.js'\n\nexport function toPackedUserOperation(\n  userOperation: UserOperation,\n): PackedUserOperation {\n  const {\n    callGasLimit,\n    callData,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    paymaster,\n    paymasterData,\n    paymasterPostOpGasLimit,\n    paymasterVerificationGasLimit,\n    sender,\n    signature = '0x',\n    verificationGasLimit,\n  } = userOperation\n\n  const accountGasLimits = concat([\n    pad(numberToHex(verificationGasLimit || 0n), { size: 16 }),\n    pad(numberToHex(callGasLimit || 0n), { size: 16 }),\n  ])\n  const initCode = getInitCode(userOperation)\n  const gasFees = concat([\n    pad(numberToHex(maxPriorityFeePerGas || 0n), { size: 16 }),\n    pad(numberToHex(maxFeePerGas || 0n), { size: 16 }),\n  ])\n  const nonce = userOperation.nonce ?? 0n\n  const paymasterAndData = paymaster\n    ? concat([\n        paymaster,\n        pad(numberToHex(paymasterVerificationGasLimit || 0n), {\n          size: 16,\n        }),\n        pad(numberToHex(paymasterPostOpGasLimit || 0n), {\n          size: 16,\n        }),\n        paymasterData || '0x',\n      ])\n    : '0x'\n  const preVerificationGas = userOperation.preVerificationGas ?? 0n\n\n  return {\n    accountGasLimits,\n    callData,\n    initCode,\n    gasFees,\n    nonce,\n    paymasterAndData,\n    preVerificationGas,\n    sender,\n    signature,\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport type { TypedDataDefinition } from '../../../types/typedData.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport { toPackedUserOperation } from './toPackedUserOperation.js'\n\nexport type GetUserOperationTypedDataParameters = {\n  chainId: number\n  entryPointAddress: Address\n  userOperation: UserOperation<'0.8'>\n}\n\nexport type GetUserOperationTypedDataReturnType = TypedDataDefinition<\n  typeof types,\n  'PackedUserOperation'\n>\n\nconst types = {\n  PackedUserOperation: [\n    { type: 'address', name: 'sender' },\n    { type: 'uint256', name: 'nonce' },\n    { type: 'bytes', name: 'initCode' },\n    { type: 'bytes', name: 'callData' },\n    { type: 'bytes32', name: 'accountGasLimits' },\n    { type: 'uint256', name: 'preVerificationGas' },\n    { type: 'bytes32', name: 'gasFees' },\n    { type: 'bytes', name: 'paymasterAndData' },\n  ],\n} as const\n\nexport function getUserOperationTypedData(\n  parameters: GetUserOperationTypedDataParameters,\n): GetUserOperationTypedDataReturnType {\n  const { chainId, entryPointAddress, userOperation } = parameters\n\n  const packedUserOp = toPackedUserOperation(userOperation)\n\n  return {\n    types,\n    primaryType: 'PackedUserOperation',\n    domain: {\n      name: 'ERC4337',\n      version: '1',\n      chainId,\n      verifyingContract: entryPointAddress,\n    },\n    message: packedUserOp,\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport type { Hash, Hex } from '../../../types/misc.js'\nimport { encodeAbiParameters } from '../../../utils/abi/encodeAbiParameters.js'\nimport { keccak256 } from '../../../utils/hash/keccak256.js'\nimport { hashTypedData } from '../../../utils/signature/hashTypedData.js'\nimport type { EntryPointVersion } from '../../types/entryPointVersion.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport { getInitCode } from './getInitCode.js'\nimport { getUserOperationTypedData } from './getUserOperationTypedData.js'\nimport { toPackedUserOperation } from './toPackedUserOperation.js'\n\nexport type GetUserOperationHashParameters<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> = {\n  chainId: number\n  entryPointAddress: Address\n  entryPointVersion: entryPointVersion | EntryPointVersion\n  userOperation: UserOperation<entryPointVersion>\n}\n\nexport type GetUserOperationHashReturnType = Hash\n\nexport function getUserOperationHash<\n  entryPointVersion extends EntryPointVersion,\n>(\n  parameters: GetUserOperationHashParameters<entryPointVersion>,\n): GetUserOperationHashReturnType {\n  const { chainId, entryPointAddress, entryPointVersion } = parameters\n  const userOperation = parameters.userOperation as UserOperation\n  const {\n    authorization,\n    callData = '0x',\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymasterAndData = '0x',\n    preVerificationGas,\n    sender,\n    verificationGasLimit,\n  } = userOperation\n\n  if (entryPointVersion === '0.8')\n    return hashTypedData(\n      getUserOperationTypedData({\n        chainId,\n        entryPointAddress,\n        userOperation,\n      }),\n    )\n\n  const packedUserOp = (() => {\n    if (entryPointVersion === '0.6') {\n      const factory = userOperation.initCode?.slice(0, 42) as Hex\n      const factoryData = userOperation.initCode?.slice(42) as Hex | undefined\n      const initCode = getInitCode({\n        authorization,\n        factory,\n        factoryData,\n      })\n      return encodeAbiParameters(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n        ],\n        [\n          sender,\n          nonce,\n          keccak256(initCode),\n          keccak256(callData),\n          callGasLimit,\n          verificationGasLimit,\n          preVerificationGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          keccak256(paymasterAndData),\n        ],\n      )\n    }\n\n    if (entryPointVersion === '0.7') {\n      const packedUserOp = toPackedUserOperation(userOperation)\n      return encodeAbiParameters(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n        ],\n        [\n          packedUserOp.sender,\n          packedUserOp.nonce,\n          keccak256(packedUserOp.initCode),\n          keccak256(packedUserOp.callData),\n          packedUserOp.accountGasLimits,\n          packedUserOp.preVerificationGas,\n          packedUserOp.gasFees,\n          keccak256(packedUserOp.paymasterAndData),\n        ],\n      )\n    }\n\n    throw new Error(`entryPointVersion \"${entryPointVersion}\" not supported.`)\n  })()\n\n  return keccak256(\n    encodeAbiParameters(\n      [{ type: 'bytes32' }, { type: 'address' }, { type: 'uint256' }],\n      [keccak256(packedUserOp), entryPointAddress, BigInt(chainId)],\n    ),\n  )\n}\n", "import { type Abi, parseAbi } from 'abitype'\n\nimport { getCode } from '../../actions/public/getCode.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { createNonceManager } from '../../utils/nonceManager.js'\nimport { serializeErc6492Signature } from '../../utils/signature/serializeErc6492Signature.js'\nimport type { EntryPointVersion } from '../types/entryPointVersion.js'\nimport type { SmartAccount, SmartAccountImplementation } from './types.js'\n\nexport type ToSmartAccountParameters<\n  entryPointAbi extends Abi | readonly unknown[] = Abi,\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n  extend extends object = object,\n> = SmartAccountImplementation<entryPointAbi, entryPointVersion, extend>\n\nexport type ToSmartAccountReturnType<\n  implementation extends\n    SmartAccountImplementation = SmartAccountImplementation,\n> = Prettify<SmartAccount<implementation>>\n\n/**\n * @description Creates a Smart Account with a provided account implementation.\n *\n * @param parameters - {@link ToSmartAccountParameters}\n * @returns A Smart Account. {@link ToSmartAccountReturnType}\n */\nexport async function toSmartAccount<\n  implementation extends SmartAccountImplementation,\n>(\n  implementation: implementation,\n): Promise<ToSmartAccountReturnType<implementation>> {\n  const {\n    extend,\n    nonceKeyManager = createNonceManager({\n      source: {\n        get() {\n          return Date.now()\n        },\n        set() {},\n      },\n    }),\n    ...rest\n  } = implementation\n\n  let deployed = false\n\n  const address = await implementation.getAddress()\n\n  return {\n    ...extend,\n    ...rest,\n    address,\n    async getFactoryArgs() {\n      if ('isDeployed' in this && (await this.isDeployed()))\n        return { factory: undefined, factoryData: undefined }\n      return implementation.getFactoryArgs()\n    },\n    async getNonce(parameters) {\n      const key =\n        parameters?.key ??\n        BigInt(\n          await nonceKeyManager.consume({\n            address,\n            chainId: implementation.client.chain!.id!,\n            client: implementation.client,\n          }),\n        )\n\n      if (implementation.getNonce)\n        return await implementation.getNonce({ ...parameters, key })\n\n      const nonce = await readContract(implementation.client, {\n        abi: parseAbi([\n          'function getNonce(address, uint192) pure returns (uint256)',\n        ]),\n        address: implementation.entryPoint.address,\n        functionName: 'getNonce',\n        args: [address, key],\n      })\n      return nonce\n    },\n    async isDeployed() {\n      if (deployed) return true\n      const code = await getAction(\n        implementation.client,\n        getCode,\n        'getCode',\n      )({\n        address,\n      })\n      deployed = Boolean(code)\n      return deployed\n    },\n    ...(implementation.sign\n      ? {\n          async sign(parameters) {\n            const [{ factory, factoryData }, signature] = await Promise.all([\n              this.getFactoryArgs(),\n              implementation.sign!(parameters),\n            ])\n            if (factory && factoryData)\n              return serializeErc6492Signature({\n                address: factory,\n                data: factoryData,\n                signature,\n              })\n            return signature\n          },\n        }\n      : {}),\n    async signMessage(parameters) {\n      const [{ factory, factoryData }, signature] = await Promise.all([\n        this.getFactoryArgs(),\n        implementation.signMessage(parameters),\n      ])\n      if (factory && factoryData && factory !== '0x7702')\n        return serializeErc6492Signature({\n          address: factory,\n          data: factoryData,\n          signature,\n        })\n      return signature\n    },\n    async signTypedData(parameters) {\n      const [{ factory, factoryData }, signature] = await Promise.all([\n        this.getFactoryArgs(),\n        implementation.signTypedData(parameters),\n      ])\n      if (factory && factoryData && factory !== '0x7702')\n        return serializeErc6492Signature({\n          address: factory,\n          data: factoryData,\n          signature,\n        })\n      return signature\n    },\n    type: 'smart',\n  } as ToSmartAccountReturnType<implementation>\n}\n", "export const entryPoint06Address =\n  '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789' as const\nexport const entryPoint07Address =\n  '0x0000000071727De22E5E9d8BAf0edAc6f37da032' as const\nexport const entryPoint08Address =\n  '0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108' as const\n", "import * as AbiParameters from '../core/AbiParameters.js'\nimport type * as Address from '../core/Address.js'\nimport type * as Authorization from '../core/Authorization.js'\nimport type * as Errors from '../core/Errors.js'\nimport * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\nimport type { Assign, Compute, OneOf } from '../core/internal/types.js'\nimport * as Signature from '../core/Signature.js'\nimport * as TypedData from '../core/TypedData.js'\nimport type * as EntryPoint from './EntryPoint.js'\n\n/** User Operation. */\nexport type UserOperation<\n  entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = OneOf<\n  | (entryPointVersion extends '0.6' ? V06<signed, bigintType> : never)\n  | (entryPointVersion extends '0.7' ? V07<signed, bigintType> : never)\n  | (entryPointVersion extends '0.8'\n      ? V08<signed, bigintType, numberType>\n      : never)\n>\n\n/**\n * Packed User Operation.\n *\n * @see https://eips.ethereum.org/EIPS/eip-4337#entrypoint-definition\n */\nexport type Packed = {\n  /** Concatenation of `verificationGasLimit` (16 bytes) and `callGasLimit` (16 bytes) */\n  accountGasLimits: Hex.Hex\n  /** The data to pass to the `sender` during the main execution call. */\n  callData: Hex.Hex\n  /** Concatenation of `factory` and `factoryData`. */\n  initCode: Hex.Hex\n  /** Concatenation of `maxPriorityFee` (16 bytes) and `maxFeePerGas` (16 bytes) */\n  gasFees: Hex.Hex\n  /** Anti-replay parameter. */\n  nonce: bigint\n  /** Concatenation of paymaster fields (or empty). */\n  paymasterAndData: Hex.Hex\n  /** Extra gas to pay the Bundler. */\n  preVerificationGas: bigint\n  /** The account making the operation. */\n  sender: Address.Address\n  /** Data passed into the account to verify authorization. */\n  signature: Hex.Hex\n}\n\n/** RPC User Operation type. */\nexport type Rpc<\n  entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n  signed extends boolean = true,\n> = OneOf<\n  | (entryPointVersion extends '0.6' ? V06<signed, Hex.Hex> : never)\n  | (entryPointVersion extends '0.7' ? V07<signed, Hex.Hex> : never)\n  | (entryPointVersion extends '0.8' ? V08<signed, Hex.Hex, Hex.Hex> : never)\n>\n\n/** Transaction Info. */\nexport type TransactionInfo<\n  entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n  bigintType = bigint,\n> = {\n  blockHash: Hex.Hex\n  blockNumber: bigintType\n  entryPoint: Address.Address\n  transactionHash: Hex.Hex\n  userOperation: UserOperation<entryPointVersion, true, bigintType>\n}\n\n/** RPC Transaction Info. */\nexport type RpcTransactionInfo<\n  entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n> = TransactionInfo<entryPointVersion, Hex.Hex>\n\n/** Type for User Operation on EntryPoint 0.6 */\nexport type V06<signed extends boolean = boolean, bigintType = bigint> = {\n  /** The data to pass to the `sender` during the main execution call. */\n  callData: Hex.Hex\n  /** The amount of gas to allocate the main execution call */\n  callGasLimit: bigintType\n  /** Account init code. Only for new accounts. */\n  initCode?: Hex.Hex | undefined\n  /** Maximum fee per gas. */\n  maxFeePerGas: bigintType\n  /** Maximum priority fee per gas. */\n  maxPriorityFeePerGas: bigintType\n  /** Anti-replay parameter. */\n  nonce: bigintType\n  /** Paymaster address with calldata. */\n  paymasterAndData?: Hex.Hex | undefined\n  /** Extra gas to pay the Bundler. */\n  preVerificationGas: bigintType\n  /** The account making the operation. */\n  sender: Address.Address\n  /** Data passed into the account to verify authorization. */\n  signature?: Hex.Hex | undefined\n  /** The amount of gas to allocate for the verification step. */\n  verificationGasLimit: bigintType\n} & (signed extends true ? { signature: Hex.Hex } : {})\n\n/** RPC User Operation on EntryPoint 0.6 */\nexport type RpcV06<signed extends boolean = true> = V06<signed, Hex.Hex>\n\n/** Type for User Operation on EntryPoint 0.7 */\nexport type V07<signed extends boolean = boolean, bigintType = bigint> = {\n  /** The data to pass to the `sender` during the main execution call. */\n  callData: Hex.Hex\n  /** The amount of gas to allocate the main execution call */\n  callGasLimit: bigintType\n  /** Account factory. Only for new accounts. */\n  factory?: Address.Address | undefined\n  /** Data for account factory. */\n  factoryData?: Hex.Hex | undefined\n  /** Maximum fee per gas. */\n  maxFeePerGas: bigintType\n  /** Maximum priority fee per gas. */\n  maxPriorityFeePerGas: bigintType\n  /** Anti-replay parameter. */\n  nonce: bigintType\n  /** Address of paymaster contract. */\n  paymaster?: Address.Address | undefined\n  /** Data for paymaster. */\n  paymasterData?: Hex.Hex | undefined\n  /** The amount of gas to allocate for the paymaster post-operation code. */\n  paymasterPostOpGasLimit?: bigintType | undefined\n  /** The amount of gas to allocate for the paymaster validation code. */\n  paymasterVerificationGasLimit?: bigintType | undefined\n  /** Extra gas to pay the Bundler. */\n  preVerificationGas: bigintType\n  /** The account making the operation. */\n  sender: Address.Address\n  /** Data passed into the account to verify authorization. */\n  signature?: Hex.Hex | undefined\n  /** The amount of gas to allocate for the verification step. */\n  verificationGasLimit: bigintType\n} & (signed extends true ? { signature: Hex.Hex } : {})\n\n/** RPC User Operation on EntryPoint 0.7 */\nexport type RpcV07<signed extends boolean = true> = V07<signed, Hex.Hex>\n\n/** Type for User Operation on EntryPoint 0.8 */\nexport type V08<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = {\n  /** Authorization data. */\n  authorization?: Authorization.Signed<bigintType, numberType> | undefined\n  /** The data to pass to the `sender` during the main execution call. */\n  callData: Hex.Hex\n  /** The amount of gas to allocate the main execution call */\n  callGasLimit: bigintType\n  /** Account factory. Only for new accounts. */\n  factory?: Address.Address | undefined\n  /** Data for account factory. */\n  factoryData?: Hex.Hex | undefined\n  /** Maximum fee per gas. */\n  maxFeePerGas: bigintType\n  /** Maximum priority fee per gas. */\n  maxPriorityFeePerGas: bigintType\n  /** Anti-replay parameter. */\n  nonce: bigintType\n  /** Address of paymaster contract. */\n  paymaster?: Address.Address | undefined\n  /** Data for paymaster. */\n  paymasterData?: Hex.Hex | undefined\n  /** The amount of gas to allocate for the paymaster post-operation code. */\n  paymasterPostOpGasLimit?: bigintType | undefined\n  /** The amount of gas to allocate for the paymaster validation code. */\n  paymasterVerificationGasLimit?: bigintType | undefined\n  /** Extra gas to pay the Bundler. */\n  preVerificationGas: bigintType\n  /** The account making the operation. */\n  sender: Address.Address\n  /** Data passed into the account to verify authorization. */\n  signature?: Hex.Hex | undefined\n  /** The amount of gas to allocate for the verification step. */\n  verificationGasLimit: bigintType\n} & (signed extends true ? { signature: Hex.Hex } : {})\n\n/** RPC User Operation on EntryPoint 0.8 */\nexport type RpcV08<signed extends boolean = true> = V08<\n  signed,\n  Hex.Hex,\n  Hex.Hex\n>\n\n/**\n * Instantiates a {@link ox#UserOperation.UserOperation} from a provided input.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.from({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   verificationGasLimit: 100_000n,\n * })\n * ```\n *\n * @example\n * ### From Packed User Operation\n *\n * ```ts twoslash\n * import { UserOperation } from 'ox/erc4337'\n *\n * const packed: UserOperation.Packed = {\n *   accountGasLimits: '0x...',\n *   callData: '0xdeadbeef',\n *   initCode: '0x',\n *   gasFees: '0x...',\n *   nonce: 69n,\n *   paymasterAndData: '0x',\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   signature: '0x',\n * }\n *\n * const userOperation = UserOperation.from(packed)\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * ```ts twoslash\n * import { Secp256k1, Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.from({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   verificationGasLimit: 100_000n,\n * })\n *\n * const payload = UserOperation.getSignPayload(userOperation, {\n *   chainId: 1,\n *   entryPointAddress: '0x1234567890123456789012345678901234567890',\n *   entryPointVersion: '0.7',\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n *\n * const userOperation_signed = UserOperation.from(userOperation, { signature }) // [!code focus]\n * ```\n *\n * @param userOperation - The user operation to instantiate (structured or packed format).\n * @returns User Operation.\n */\nexport function from<\n  const userOperation extends UserOperation | Packed,\n  const signature extends Hex.Hex | undefined = undefined,\n>(\n  userOperation: userOperation | UserOperation | Packed,\n  options: from.Options<signature> = {},\n): from.ReturnType<userOperation, signature> {\n  const signature = (() => {\n    if (typeof options.signature === 'string') return options.signature\n    if (typeof options.signature === 'object')\n      return Signature.toHex(options.signature)\n    if (userOperation.signature) return userOperation.signature\n    return undefined\n  })()\n\n  const packed =\n    'accountGasLimits' in userOperation && 'gasFees' in userOperation\n\n  const userOp = packed ? fromPacked(userOperation) : userOperation\n  return { ...userOp, signature } as never\n}\n\nexport declare namespace from {\n  export type Options<\n    signature extends Signature.Signature | Hex.Hex | undefined = undefined,\n  > = {\n    signature?: signature | Signature.Signature | Hex.Hex | undefined\n  }\n\n  export type ReturnType<\n    userOperation extends UserOperation | Packed = UserOperation | Packed,\n    signature extends Signature.Signature | Hex.Hex | undefined = undefined,\n  > = Compute<\n    Assign<\n      userOperation,\n      signature extends Signature.Signature | Hex.Hex\n        ? Readonly<{ signature: Hex.Hex }>\n        : {}\n    >\n  >\n\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#UserOperation.Rpc} to an {@link ox#UserOperation.UserOperation}.\n *\n * @example\n * ```ts twoslash\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.fromRpc({\n *   callData: '0xdeadbeef',\n *   callGasLimit: '0x69420',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   nonce: '0x357',\n *   preVerificationGas: '0x69420',\n *   signature: '0x',\n *   sender: '0x1234567890123456789012345678901234567890',\n *   verificationGasLimit: '0x69420',\n * })\n * ```\n *\n * @param rpc - The RPC user operation to convert.\n * @returns An instantiated {@link ox#UserOperation.UserOperation}.\n */\nexport function fromRpc(rpc: Rpc): UserOperation {\n  return {\n    ...rpc,\n    callGasLimit: BigInt(rpc.callGasLimit),\n    maxFeePerGas: BigInt(rpc.maxFeePerGas),\n    maxPriorityFeePerGas: BigInt(rpc.maxPriorityFeePerGas),\n    nonce: BigInt(rpc.nonce),\n    preVerificationGas: BigInt(rpc.preVerificationGas),\n    verificationGasLimit: BigInt(rpc.verificationGasLimit),\n    ...(rpc.paymasterPostOpGasLimit && {\n      paymasterPostOpGasLimit: BigInt(rpc.paymasterPostOpGasLimit),\n    }),\n    ...(rpc.paymasterVerificationGasLimit && {\n      paymasterVerificationGasLimit: BigInt(rpc.paymasterVerificationGasLimit),\n    }),\n  } as UserOperation\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Obtains the signing payload for a {@link ox#UserOperation.UserOperation}.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.from({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   verificationGasLimit: 100_000n,\n * })\n *\n * const payload = UserOperation.getSignPayload(userOperation, { // [!code focus]\n *   chainId: 1, // [!code focus]\n *   entryPointAddress: '0x1234567890123456789012345678901234567890', // [!code focus]\n *   entryPointVersion: '0.6', // [!code focus]\n * }) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param userOperation - The user operation to get the sign payload for.\n * @returns The signing payload for the user operation.\n */\nexport function getSignPayload<\n  entrypointVersion extends EntryPoint.Version = EntryPoint.Version,\n>(\n  userOperation: UserOperation<entrypointVersion>,\n  options: getSignPayload.Options<entrypointVersion>,\n): Hex.Hex {\n  return hash(userOperation, options)\n}\n\nexport declare namespace getSignPayload {\n  type Options<\n    entrypointVersion extends EntryPoint.Version = EntryPoint.Version,\n  > = hash.Options<entrypointVersion>\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#UserOperation.UserOperation}. This is the \"user operation hash\".\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.hash({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   verificationGasLimit: 100_000n,\n * }, {\n *   chainId: 1,\n *   entryPointAddress: '0x1234567890123456789012345678901234567890',\n *   entryPointVersion: '0.6',\n * })\n * ```\n *\n * @param userOperation - The user operation to hash.\n * @returns The hash of the user operation.\n */\nexport function hash<\n  entrypointVersion extends EntryPoint.Version = EntryPoint.Version,\n>(\n  userOperation: UserOperation<entrypointVersion>,\n  options: hash.Options<entrypointVersion>,\n): Hex.Hex {\n  const { chainId, entryPointAddress, entryPointVersion } = options\n  const {\n    callData,\n    callGasLimit,\n    initCode,\n    factory,\n    factoryData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymaster,\n    paymasterAndData,\n    paymasterData,\n    paymasterPostOpGasLimit,\n    paymasterVerificationGasLimit,\n    preVerificationGas,\n    sender,\n    verificationGasLimit,\n  } = userOperation as UserOperation\n\n  if (entryPointVersion === '0.8') {\n    const typedData = toTypedData(userOperation as UserOperation<'0.8', true>, {\n      chainId,\n      entryPointAddress,\n    })\n    return TypedData.getSignPayload(typedData)\n  }\n\n  const packedUserOp = (() => {\n    if (entryPointVersion === '0.6') {\n      return AbiParameters.encode(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n        ],\n        [\n          sender,\n          nonce,\n          Hash.keccak256(initCode ?? '0x'),\n          Hash.keccak256(callData),\n          callGasLimit,\n          verificationGasLimit,\n          preVerificationGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          Hash.keccak256(paymasterAndData ?? '0x'),\n        ],\n      )\n    }\n\n    if (entryPointVersion === '0.7') {\n      const accountGasLimits = Hex.concat(\n        Hex.padLeft(Hex.fromNumber(verificationGasLimit), 16),\n        Hex.padLeft(Hex.fromNumber(callGasLimit), 16),\n      )\n      const gasFees = Hex.concat(\n        Hex.padLeft(Hex.fromNumber(maxPriorityFeePerGas), 16),\n        Hex.padLeft(Hex.fromNumber(maxFeePerGas), 16),\n      )\n      const initCode_hashed = Hash.keccak256(\n        factory && factoryData ? Hex.concat(factory, factoryData) : '0x',\n      )\n      const paymasterAndData_hashed = Hash.keccak256(\n        paymaster\n          ? Hex.concat(\n              paymaster,\n              Hex.padLeft(\n                Hex.fromNumber(paymasterVerificationGasLimit || 0),\n                16,\n              ),\n              Hex.padLeft(Hex.fromNumber(paymasterPostOpGasLimit || 0), 16),\n              paymasterData || '0x',\n            )\n          : '0x',\n      )\n\n      return AbiParameters.encode(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n        ],\n        [\n          sender,\n          nonce,\n          initCode_hashed,\n          Hash.keccak256(callData),\n          accountGasLimits,\n          preVerificationGas,\n          gasFees,\n          paymasterAndData_hashed,\n        ],\n      )\n    }\n\n    throw new Error(`entryPointVersion \"${entryPointVersion}\" not supported.`)\n  })()\n\n  return Hash.keccak256(\n    AbiParameters.encode(\n      [{ type: 'bytes32' }, { type: 'address' }, { type: 'uint256' }],\n      [Hash.keccak256(packedUserOp), entryPointAddress, BigInt(chainId)],\n    ),\n  )\n}\n\nexport declare namespace hash {\n  type Options<\n    entrypointVersion extends EntryPoint.Version = EntryPoint.Version,\n  > = {\n    chainId: number\n    entryPointAddress: Address.Address\n    entryPointVersion: entrypointVersion | EntryPoint.Version\n  }\n\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#UserOperation.UserOperation} to `initCode`.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const initCode = UserOperation.toInitCode({\n *   authorization: {\n *     address: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *     chainId: 1,\n *     nonce: 69n,\n *     yParity: 0,\n *     r: 1n,\n *     s: 2n,\n *   },\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   factory: '0x7702',\n *   factoryData: '0xdeadbeef',\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n * })\n * ```\n *\n * @param userOperation - The user operation to convert.\n * @returns The init code.\n */\nexport function toInitCode(userOperation: Partial<UserOperation>): Hex.Hex {\n  const { authorization, factory, factoryData } = userOperation\n  if (\n    factory === '0x7702' ||\n    factory === '0x7702000000000000000000000000000000000000'\n  ) {\n    if (!authorization) return '0x7702000000000000000000000000000000000000'\n    const delegation = authorization.address\n    return Hex.concat(delegation, factoryData ?? '0x')\n  }\n  if (!factory) return '0x'\n  return Hex.concat(factory, factoryData ?? '0x')\n}\n\n/**\n * Transforms a User Operation into \"packed\" format.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const packed = UserOperation.toPacked({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   signature: '0x...',\n *   verificationGasLimit: 100_000n,\n * })\n * ```\n *\n * @param userOperation - The user operation to transform.\n * @returns The packed user operation.\n */\nexport function toPacked(\n  userOperation: UserOperation<'0.7' | '0.8', true>,\n): Packed {\n  const {\n    callGasLimit,\n    callData,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    nonce,\n    paymaster,\n    paymasterData,\n    paymasterPostOpGasLimit,\n    paymasterVerificationGasLimit,\n    sender,\n    signature,\n    verificationGasLimit,\n  } = userOperation\n\n  const accountGasLimits = Hex.concat(\n    Hex.padLeft(Hex.fromNumber(verificationGasLimit || 0n), 16),\n    Hex.padLeft(Hex.fromNumber(callGasLimit || 0n), 16),\n  )\n  const initCode = toInitCode(userOperation)\n  const gasFees = Hex.concat(\n    Hex.padLeft(Hex.fromNumber(maxPriorityFeePerGas || 0n), 16),\n    Hex.padLeft(Hex.fromNumber(maxFeePerGas || 0n), 16),\n  )\n  const paymasterAndData = paymaster\n    ? Hex.concat(\n        paymaster,\n        Hex.padLeft(Hex.fromNumber(paymasterVerificationGasLimit || 0n), 16),\n        Hex.padLeft(Hex.fromNumber(paymasterPostOpGasLimit || 0n), 16),\n        paymasterData || '0x',\n      )\n    : '0x'\n  const preVerificationGas = userOperation.preVerificationGas ?? 0n\n\n  return {\n    accountGasLimits,\n    callData,\n    initCode,\n    gasFees,\n    nonce,\n    paymasterAndData,\n    preVerificationGas,\n    sender,\n    signature,\n  }\n}\n\nexport declare namespace toPacked {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Transforms a \"packed\" User Operation into a structured {@link ox#UserOperation.UserOperation}.\n *\n * @example\n * ```ts twoslash\n * import { UserOperation } from 'ox/erc4337'\n *\n * const packed: UserOperation.Packed = {\n *   accountGasLimits: '0x...',\n *   callData: '0xdeadbeef',\n *   initCode: '0x...',\n *   gasFees: '0x...',\n *   nonce: 69n,\n *   paymasterAndData: '0x',\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   signature: '0x...',\n * }\n *\n * const userOperation = UserOperation.fromPacked(packed)\n * ```\n *\n * @param packed - The packed user operation to transform.\n * @returns The structured user operation.\n */\nexport function fromPacked(packed: Packed): UserOperation<'0.7' | '0.8', true> {\n  const {\n    accountGasLimits,\n    callData,\n    initCode,\n    gasFees,\n    nonce,\n    paymasterAndData,\n    preVerificationGas,\n    sender,\n    signature,\n  } = packed\n\n  const verificationGasLimit = BigInt(Hex.slice(accountGasLimits, 0, 16))\n  const callGasLimit = BigInt(Hex.slice(accountGasLimits, 16, 32))\n\n  const { factory, factoryData } = (() => {\n    if (initCode === '0x') return { factory: undefined, factoryData: undefined }\n\n    const factory = Hex.slice(initCode, 0, 20)\n    const factoryData =\n      Hex.size(initCode) > 20 ? Hex.slice(initCode, 20) : undefined\n\n    return { factory, factoryData }\n  })()\n\n  const maxPriorityFeePerGas = BigInt(Hex.slice(gasFees, 0, 16))\n  const maxFeePerGas = BigInt(Hex.slice(gasFees, 16, 32))\n\n  const {\n    paymaster,\n    paymasterVerificationGasLimit,\n    paymasterPostOpGasLimit,\n    paymasterData,\n  } = (() => {\n    if (paymasterAndData === '0x')\n      return {\n        paymaster: undefined,\n        paymasterVerificationGasLimit: undefined,\n        paymasterPostOpGasLimit: undefined,\n        paymasterData: undefined,\n      }\n\n    const paymaster = Hex.slice(paymasterAndData, 0, 20)\n    const paymasterVerificationGasLimit = BigInt(\n      Hex.slice(paymasterAndData, 20, 36),\n    )\n    const paymasterPostOpGasLimit = BigInt(Hex.slice(paymasterAndData, 36, 52))\n    const paymasterData =\n      Hex.size(paymasterAndData) > 52\n        ? Hex.slice(paymasterAndData, 52)\n        : undefined\n\n    return {\n      paymaster,\n      paymasterVerificationGasLimit,\n      paymasterPostOpGasLimit,\n      paymasterData,\n    }\n  })()\n\n  return {\n    callData,\n    callGasLimit,\n    ...(factory && { factory }),\n    ...(factoryData && { factoryData }),\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    ...(paymaster && { paymaster }),\n    ...(paymasterData && { paymasterData }),\n    ...(typeof paymasterPostOpGasLimit === 'bigint' && {\n      paymasterPostOpGasLimit,\n    }),\n    ...(typeof paymasterVerificationGasLimit === 'bigint' && {\n      paymasterVerificationGasLimit,\n    }),\n    preVerificationGas,\n    sender,\n    signature,\n    verificationGasLimit,\n  }\n}\n\nexport declare namespace fromPacked {\n  export type ErrorType = Hex.slice.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#UserOperation.UserOperation} to a {@link ox#UserOperation.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.toRpc({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   verificationGasLimit: 100_000n,\n * })\n * ```\n *\n * @param userOperation - The user operation to convert.\n * @returns An RPC-formatted user operation.\n */\nexport function toRpc(userOperation: UserOperation): Rpc {\n  const rpc = {} as Rpc\n\n  rpc.callData = userOperation.callData\n  rpc.callGasLimit = Hex.fromNumber(userOperation.callGasLimit)\n  rpc.maxFeePerGas = Hex.fromNumber(userOperation.maxFeePerGas)\n  rpc.maxPriorityFeePerGas = Hex.fromNumber(userOperation.maxPriorityFeePerGas)\n  rpc.nonce = Hex.fromNumber(userOperation.nonce)\n  rpc.preVerificationGas = Hex.fromNumber(userOperation.preVerificationGas)\n  rpc.sender = userOperation.sender\n  rpc.verificationGasLimit = Hex.fromNumber(userOperation.verificationGasLimit)\n\n  if (userOperation.factory) rpc.factory = userOperation.factory\n  if (userOperation.factoryData) rpc.factoryData = userOperation.factoryData\n  if (userOperation.initCode) rpc.initCode = userOperation.initCode\n  if (userOperation.paymaster) rpc.paymaster = userOperation.paymaster\n  if (userOperation.paymasterData)\n    rpc.paymasterData = userOperation.paymasterData\n  if (typeof userOperation.paymasterPostOpGasLimit === 'bigint')\n    rpc.paymasterPostOpGasLimit = Hex.fromNumber(\n      userOperation.paymasterPostOpGasLimit,\n    )\n  if (typeof userOperation.paymasterVerificationGasLimit === 'bigint')\n    rpc.paymasterVerificationGasLimit = Hex.fromNumber(\n      userOperation.paymasterVerificationGasLimit,\n    )\n  if (userOperation.signature) rpc.signature = userOperation.signature\n\n  return rpc\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a signed {@link ox#UserOperation.UserOperation} to a {@link ox#TypedData.Definition}.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const typedData = UserOperation.toTypedData({\n *   authorization: {\n *     chainId: 1,\n *     address: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *     nonce: 69n,\n *     yParity: 0,\n *     r: 1n,\n *     s: 2n,\n *   },\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   signature: '0x...',\n *   verificationGasLimit: 100_000n,\n * }, {\n *   chainId: 1,\n *   entryPointAddress: '0x1234567890123456789012345678901234567890',\n * })\n * ```\n *\n * @param userOperation - The user operation to convert.\n * @returns A Typed Data definition.\n */\nexport function toTypedData(\n  userOperation: UserOperation<'0.8', true>,\n  options: toTypedData.Options,\n): TypedData.Definition<typeof toTypedData.types, 'PackedUserOperation'> {\n  const { chainId, entryPointAddress } = options\n\n  const packedUserOp = toPacked(userOperation)\n\n  return {\n    domain: {\n      name: 'ERC4337',\n      version: '1',\n      chainId,\n      verifyingContract: entryPointAddress,\n    },\n    message: packedUserOp,\n    primaryType: 'PackedUserOperation',\n    types: toTypedData.types,\n  }\n}\n\nexport namespace toTypedData {\n  export type Options = {\n    chainId: number\n    entryPointAddress: Address.Address\n  }\n\n  export type ErrorType = Errors.GlobalErrorType\n\n  export const types = {\n    PackedUserOperation: [\n      { type: 'address', name: 'sender' },\n      { type: 'uint256', name: 'nonce' },\n      { type: 'bytes', name: 'initCode' },\n      { type: 'bytes', name: 'callData' },\n      { type: 'bytes32', name: 'accountGasLimits' },\n      { type: 'uint256', name: 'preVerificationGas' },\n      { type: 'bytes32', name: 'gasFees' },\n      { type: 'bytes', name: 'paymasterAndData' },\n    ],\n  } as const\n}\n", "import { UserOperation } from 'ox/erc4337'\n\nexport const toUserOperation = UserOperation.from\n", "export const abi = [\n  {\n    type: 'fallback',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'receive',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'execute',\n    inputs: [\n      {\n        name: 'mode',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n      {\n        name: 'executionData',\n        type: 'bytes',\n        internalType: 'bytes',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'supportsExecutionMode',\n    inputs: [\n      {\n        name: 'mode',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: 'result',\n        type: 'bool',\n        internalType: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'error',\n    name: 'FnSelectorNotRecognized',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'UnsupportedExecutionMode',\n    inputs: [],\n  },\n] as const\n\nexport const executionMode = {\n  default: '0x0100000000000000000000000000000000000000000000000000000000000000',\n  opData: '0x0100000000007821000100000000000000000000000000000000000000000000',\n  batchOfBatches:\n    '0x0100000000007821000200000000000000000000000000000000000000000000',\n} as const\n", "import type { Address } from '../../../accounts/index.js'\nimport { readContract } from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { withCache } from '../../../utils/promise/withCache.js'\nimport { abi, executionMode } from '../constants.js'\n\nexport type SupportsExecutionModeParameters = {\n  address: Address\n  mode?: 'default' | 'opData' | 'batchOfBatches' | Hex\n}\n\nexport type SupportsExecutionModeReturnType = boolean\n\nexport type SupportsExecutionModeErrorType = ErrorType\n\nconst toSerializedMode = {\n  default: executionMode.default,\n  opData: executionMode.opData,\n  batchOfBatches: executionMode.batchOfBatches,\n} as const\n\n/**\n * Checks if the contract supports the ERC-7821 execution mode.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { supportsExecutionMode } from 'viem/experimental/erc7821'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const supported = await supportsExecutionMode(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link SupportsExecutionModeParameters}\n * @returns If the execution mode is supported. {@link SupportsExecutionModeReturnType}\n */\nexport async function supportsExecutionMode<\n  chain extends Chain | undefined = Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: SupportsExecutionModeParameters,\n): Promise<SupportsExecutionModeReturnType> {\n  const { address, mode: m = 'default' } = parameters\n  const mode = m.startsWith('0x') ? m : (toSerializedMode as any)[m]\n  try {\n    return await withCache(\n      () =>\n        readContract(client, {\n          abi,\n          address,\n          functionName: 'supportsExecutionMode',\n          args: [mode],\n        }),\n      {\n        cacheKey: `supportsExecutionMode.${address}.${mode}`,\n      },\n    )\n  } catch {\n    return false\n  }\n}\n"],
  "mappings": "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",
  "names": ["p256", "Fp2", "Fp12", "msg", "Fp", "Fp6", "sign", "_0n", "_1n", "_2n", "_3n", "Fp", "Fp2", "G2psi", "G2psi2", "Fp6", "Fp12", "_0n", "_1n", "_2n", "_3n", "from", "hash", "error", "cause", "error", "abi", "getPaymasterStubData", "getPaymasterData", "parameters", "factory", "fees", "authorization", "getChainId", "paymaster", "hash", "hash", "hash", "packedUserOp", "entryPoint06Address", "getSignPayload", "getSignPayload", "keccak256", "concat", "factory", "factoryData", "paymaster", "paymasterVerificationGasLimit", "paymasterPostOpGasLimit", "paymasterData", "toTypedData"]
}
