import {
  CaipNetworksUtil,
  ConstantsUtil as ConstantsUtil3,
  ErrorUtil,
  HelpersUtil,
  LoggerUtil,
  PresetsUtil,
  ProviderUtil,
  WalletUtil
} from "./chunk-EQGDVHB6.js";
import {
  AccountController,
  AlertController,
  ApiController,
  AssetUtil,
  BlockchainApiController,
  ChainController,
  ConnectionController,
  ConnectorController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  EnsController,
  EventsController,
  ModalController,
  NetworkUtil,
  OnRampController,
  OptionsController,
  ParseUtil,
  PublicStateController,
  RouterController,
  SIWXUtil,
  SendController,
  SnackController,
  StorageUtil,
  ThemeController,
  setColorTheme,
  setThemeVariables
} from "./chunk-2TGPJK24.js";
import {
  esm_default
} from "./chunk-QLI267SS.js";
import "./chunk-I3QO6FNY.js";
import "./chunk-KXOXRCJW.js";
import "./chunk-Y67CJDWE.js";
import {
  HashMD
} from "./chunk-K55FG4NU.js";
import {
  LruMap,
  checksumAddress,
  defineFormatter,
  hexToBigInt,
  hexToNumber,
  isHex,
  keccak256,
  numberToHex,
  toHex as toHex2
} from "./chunk-2KL2B4H3.js";
import {
  rotl,
  wrapConstructor
} from "./chunk-L2AIA43T.js";
import "./chunk-ICXFJ2CE.js";
import "./chunk-DF2FOQV5.js";
import {
  A,
  E,
  IEvents,
  esm_exports,
  f,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  getBigIntRpcId,
  h,
  i,
  import_pino,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isLocalhostUrl,
  isWsUrl,
  k,
  o,
  parseConnectionError,
  payloadId,
  r,
  safeJsonParse,
  safeJsonStringify,
  y
} from "./chunk-Q5AEF23C.js";
import {
  require_events
} from "./chunk-2YULO2GZ.js";
import {
  concat,
  detect,
  fromString,
  require_cjs,
  require_cjs2,
  require_cjs3,
  toString
} from "./chunk-7KOOD3VM.js";
import "./chunk-2LIPOBYQ.js";
import "./chunk-6RV5VQWN.js";
import "./chunk-45PA24V3.js";
import "./chunk-7HS75YHE.js";
import "./chunk-NP4V6G56.js";
import {
  toHex
} from "./chunk-WFYE5KNG.js";
import "./chunk-3NIYQQ3T.js";
import "./chunk-VKJLEXYM.js";
import "./chunk-U6O6RVJR.js";
import {
  __commonJS,
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/@reown/appkit/node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/@reown/appkit/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_events4 = __toESM(require_events());

// node_modules/@reown/appkit/node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());
var a = Object.defineProperty;
var u = (e, s, r2) => s in e ? a(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var c = (e, s, r2) => u(e, typeof s != "symbol" ? s + "" : s, r2);
var h2 = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, c(this, "protocol", "wc"), c(this, "version", 2);
  }
};
var p = Object.defineProperty;
var b = (e, s, r2) => s in e ? p(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var v = (e, s, r2) => b(e, typeof s != "symbol" ? s + "" : s, r2);
var I = class extends IEvents {
  constructor(s, r2) {
    super(), this.core = s, this.logger = r2, v(this, "records", /* @__PURE__ */ new Map());
  }
};
var y2 = class {
  constructor(s, r2) {
    this.logger = s, this.core = r2;
  }
};
var m = class extends IEvents {
  constructor(s, r2) {
    super(), this.relayer = s, this.logger = r2;
  }
};
var d = class extends IEvents {
  constructor(s) {
    super();
  }
};
var f2 = class {
  constructor(s, r2, t, q3) {
    this.core = s, this.logger = r2, this.name = t;
  }
};
var P = class extends IEvents {
  constructor(s, r2) {
    super(), this.relayer = s, this.logger = r2;
  }
};
var S = class extends IEvents {
  constructor(s, r2) {
    super(), this.core = s, this.logger = r2;
  }
};
var M = class {
  constructor(s, r2, t) {
    this.core = s, this.logger = r2, this.store = t;
  }
};
var O = class {
  constructor(s, r2) {
    this.projectId = s, this.logger = r2;
  }
};
var R = class {
  constructor(s, r2, t) {
    this.core = s, this.logger = r2, this.telemetryEnabled = t;
  }
};
var T = Object.defineProperty;
var k2 = (e, s, r2) => s in e ? T(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var i2 = (e, s, r2) => k2(e, typeof s != "symbol" ? s + "" : s, r2);
var J = class {
  constructor(s) {
    this.opts = s, i2(this, "protocol", "wc"), i2(this, "version", 2);
  }
};
var V = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_time3 = __toESM(require_cjs());

// node_modules/@reown/appkit/node_modules/@walletconnect/relay-auth/dist/index.es.js
var import_time = __toESM(require_cjs());
function En(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function fe(t, ...e) {
  if (!En(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function De(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function gn(t, e) {
  fe(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
var it = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var _t = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
function yn(t) {
  if (typeof t != "string") throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function de(t) {
  return typeof t == "string" && (t = yn(t)), fe(t), t;
}
var xn = class {
  clone() {
    return this._cloneInto();
  }
};
function Bn(t) {
  const e = (r2) => t().update(de(r2)).digest(), n2 = t();
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = () => t(), e;
}
function he(t = 32) {
  if (it && typeof it.getRandomValues == "function") return it.getRandomValues(new Uint8Array(t));
  if (it && typeof it.randomBytes == "function") return it.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
function Cn(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o2 = BigInt(32), s = BigInt(4294967295), a2 = Number(n2 >> o2 & s), u3 = Number(n2 & s), i3 = r2 ? 4 : 0, D2 = r2 ? 0 : 4;
  t.setUint32(e + i3, a2, r2), t.setUint32(e + D2, u3, r2);
}
var An = class extends xn {
  constructor(e, n2, r2, o2) {
    super(), this.blockLen = e, this.outputLen = n2, this.padOffset = r2, this.isLE = o2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = _t(this.buffer);
  }
  update(e) {
    De(this);
    const { view: n2, buffer: r2, blockLen: o2 } = this;
    e = de(e);
    const s = e.length;
    for (let a2 = 0; a2 < s; ) {
      const u3 = Math.min(o2 - this.pos, s - a2);
      if (u3 === o2) {
        const i3 = _t(e);
        for (; o2 <= s - a2; a2 += o2) this.process(i3, a2);
        continue;
      }
      r2.set(e.subarray(a2, a2 + u3), this.pos), this.pos += u3, a2 += u3, this.pos === o2 && (this.process(n2, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    De(this), gn(e, this), this.finished = true;
    const { buffer: n2, view: r2, blockLen: o2, isLE: s } = this;
    let { pos: a2 } = this;
    n2[a2++] = 128, this.buffer.subarray(a2).fill(0), this.padOffset > o2 - a2 && (this.process(r2, 0), a2 = 0);
    for (let l4 = a2; l4 < o2; l4++) n2[l4] = 0;
    Cn(r2, o2 - 8, BigInt(this.length * 8), s), this.process(r2, 0);
    const u3 = _t(e), i3 = this.outputLen;
    if (i3 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const D2 = i3 / 4, c3 = this.get();
    if (D2 > c3.length) throw new Error("_sha2: outputLen bigger than state");
    for (let l4 = 0; l4 < D2; l4++) u3.setUint32(4 * l4, c3[l4], s);
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n2, buffer: r2, length: o2, finished: s, destroyed: a2, pos: u3 } = this;
    return e.length = o2, e.pos = u3, e.finished = s, e.destroyed = a2, o2 % n2 && e.buffer.set(r2), e;
  }
};
var wt = BigInt(2 ** 32 - 1);
var St = BigInt(32);
function le(t, e = false) {
  return e ? { h: Number(t & wt), l: Number(t >> St & wt) } : { h: Number(t >> St & wt) | 0, l: Number(t & wt) | 0 };
}
function mn(t, e = false) {
  let n2 = new Uint32Array(t.length), r2 = new Uint32Array(t.length);
  for (let o2 = 0; o2 < t.length; o2++) {
    const { h: s, l: a2 } = le(t[o2], e);
    [n2[o2], r2[o2]] = [s, a2];
  }
  return [n2, r2];
}
var _n = (t, e) => BigInt(t >>> 0) << St | BigInt(e >>> 0);
var Sn = (t, e, n2) => t >>> n2;
var vn = (t, e, n2) => t << 32 - n2 | e >>> n2;
var In = (t, e, n2) => t >>> n2 | e << 32 - n2;
var Un = (t, e, n2) => t << 32 - n2 | e >>> n2;
var Tn = (t, e, n2) => t << 64 - n2 | e >>> n2 - 32;
var Fn = (t, e, n2) => t >>> n2 - 32 | e << 64 - n2;
var Nn = (t, e) => e;
var Ln = (t, e) => t;
var On = (t, e, n2) => t << n2 | e >>> 32 - n2;
var Hn = (t, e, n2) => e << n2 | t >>> 32 - n2;
var zn = (t, e, n2) => e << n2 - 32 | t >>> 64 - n2;
var Mn = (t, e, n2) => t << n2 - 32 | e >>> 64 - n2;
function qn(t, e, n2, r2) {
  const o2 = (e >>> 0) + (r2 >>> 0);
  return { h: t + n2 + (o2 / 2 ** 32 | 0) | 0, l: o2 | 0 };
}
var $n = (t, e, n2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0);
var kn = (t, e, n2, r2) => e + n2 + r2 + (t / 2 ** 32 | 0) | 0;
var Rn = (t, e, n2, r2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0) + (r2 >>> 0);
var jn = (t, e, n2, r2, o2) => e + n2 + r2 + o2 + (t / 2 ** 32 | 0) | 0;
var Zn = (t, e, n2, r2, o2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0) + (r2 >>> 0) + (o2 >>> 0);
var Gn = (t, e, n2, r2, o2, s) => e + n2 + r2 + o2 + s + (t / 2 ** 32 | 0) | 0;
var x = { fromBig: le, split: mn, toBig: _n, shrSH: Sn, shrSL: vn, rotrSH: In, rotrSL: Un, rotrBH: Tn, rotrBL: Fn, rotr32H: Nn, rotr32L: Ln, rotlSH: On, rotlSL: Hn, rotlBH: zn, rotlBL: Mn, add: qn, add3L: $n, add3H: kn, add4L: Rn, add4H: jn, add5H: Gn, add5L: Zn };
var [Vn, Yn] = (() => x.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t) => BigInt(t))))();
var P2 = new Uint32Array(80);
var Q = new Uint32Array(80);
var Jn = class extends An {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e, Al: n2, Bh: r2, Bl: o2, Ch: s, Cl: a2, Dh: u3, Dl: i3, Eh: D2, El: c3, Fh: l4, Fl: p3, Gh: w3, Gl: h5, Hh: g2, Hl: S4 } = this;
    return [e, n2, r2, o2, s, a2, u3, i3, D2, c3, l4, p3, w3, h5, g2, S4];
  }
  set(e, n2, r2, o2, s, a2, u3, i3, D2, c3, l4, p3, w3, h5, g2, S4) {
    this.Ah = e | 0, this.Al = n2 | 0, this.Bh = r2 | 0, this.Bl = o2 | 0, this.Ch = s | 0, this.Cl = a2 | 0, this.Dh = u3 | 0, this.Dl = i3 | 0, this.Eh = D2 | 0, this.El = c3 | 0, this.Fh = l4 | 0, this.Fl = p3 | 0, this.Gh = w3 | 0, this.Gl = h5 | 0, this.Hh = g2 | 0, this.Hl = S4 | 0;
  }
  process(e, n2) {
    for (let d4 = 0; d4 < 16; d4++, n2 += 4) P2[d4] = e.getUint32(n2), Q[d4] = e.getUint32(n2 += 4);
    for (let d4 = 16; d4 < 80; d4++) {
      const m2 = P2[d4 - 15] | 0, F4 = Q[d4 - 15] | 0, q3 = x.rotrSH(m2, F4, 1) ^ x.rotrSH(m2, F4, 8) ^ x.shrSH(m2, F4, 7), z2 = x.rotrSL(m2, F4, 1) ^ x.rotrSL(m2, F4, 8) ^ x.shrSL(m2, F4, 7), I3 = P2[d4 - 2] | 0, O4 = Q[d4 - 2] | 0, ot3 = x.rotrSH(I3, O4, 19) ^ x.rotrBH(I3, O4, 61) ^ x.shrSH(I3, O4, 6), tt3 = x.rotrSL(I3, O4, 19) ^ x.rotrBL(I3, O4, 61) ^ x.shrSL(I3, O4, 6), st2 = x.add4L(z2, tt3, Q[d4 - 7], Q[d4 - 16]), at3 = x.add4H(st2, q3, ot3, P2[d4 - 7], P2[d4 - 16]);
      P2[d4] = at3 | 0, Q[d4] = st2 | 0;
    }
    let { Ah: r2, Al: o2, Bh: s, Bl: a2, Ch: u3, Cl: i3, Dh: D2, Dl: c3, Eh: l4, El: p3, Fh: w3, Fl: h5, Gh: g2, Gl: S4, Hh: v5, Hl: L3 } = this;
    for (let d4 = 0; d4 < 80; d4++) {
      const m2 = x.rotrSH(l4, p3, 14) ^ x.rotrSH(l4, p3, 18) ^ x.rotrBH(l4, p3, 41), F4 = x.rotrSL(l4, p3, 14) ^ x.rotrSL(l4, p3, 18) ^ x.rotrBL(l4, p3, 41), q3 = l4 & w3 ^ ~l4 & g2, z2 = p3 & h5 ^ ~p3 & S4, I3 = x.add5L(L3, F4, z2, Yn[d4], Q[d4]), O4 = x.add5H(I3, v5, m2, q3, Vn[d4], P2[d4]), ot3 = I3 | 0, tt3 = x.rotrSH(r2, o2, 28) ^ x.rotrBH(r2, o2, 34) ^ x.rotrBH(r2, o2, 39), st2 = x.rotrSL(r2, o2, 28) ^ x.rotrBL(r2, o2, 34) ^ x.rotrBL(r2, o2, 39), at3 = r2 & s ^ r2 & u3 ^ s & u3, Ct3 = o2 & a2 ^ o2 & i3 ^ a2 & i3;
      v5 = g2 | 0, L3 = S4 | 0, g2 = w3 | 0, S4 = h5 | 0, w3 = l4 | 0, h5 = p3 | 0, { h: l4, l: p3 } = x.add(D2 | 0, c3 | 0, O4 | 0, ot3 | 0), D2 = u3 | 0, c3 = i3 | 0, u3 = s | 0, i3 = a2 | 0, s = r2 | 0, a2 = o2 | 0;
      const At3 = x.add3L(ot3, st2, Ct3);
      r2 = x.add3H(At3, O4, tt3, at3), o2 = At3 | 0;
    }
    ({ h: r2, l: o2 } = x.add(this.Ah | 0, this.Al | 0, r2 | 0, o2 | 0)), { h: s, l: a2 } = x.add(this.Bh | 0, this.Bl | 0, s | 0, a2 | 0), { h: u3, l: i3 } = x.add(this.Ch | 0, this.Cl | 0, u3 | 0, i3 | 0), { h: D2, l: c3 } = x.add(this.Dh | 0, this.Dl | 0, D2 | 0, c3 | 0), { h: l4, l: p3 } = x.add(this.Eh | 0, this.El | 0, l4 | 0, p3 | 0), { h: w3, l: h5 } = x.add(this.Fh | 0, this.Fl | 0, w3 | 0, h5 | 0), { h: g2, l: S4 } = x.add(this.Gh | 0, this.Gl | 0, g2 | 0, S4 | 0), { h: v5, l: L3 } = x.add(this.Hh | 0, this.Hl | 0, v5 | 0, L3 | 0), this.set(r2, o2, s, a2, u3, i3, D2, c3, l4, p3, w3, h5, g2, S4, v5, L3);
  }
  roundClean() {
    P2.fill(0), Q.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Kn = Bn(() => new Jn());
var vt = BigInt(0);
var be = BigInt(1);
var Wn = BigInt(2);
function It(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Ut(t) {
  if (!It(t)) throw new Error("Uint8Array expected");
}
function Tt(t, e) {
  if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e);
}
var Xn = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Ft(t) {
  Ut(t);
  let e = "";
  for (let n2 = 0; n2 < t.length; n2++) e += Xn[t[n2]];
  return e;
}
function pe(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? vt : BigInt("0x" + t);
}
var K = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function we(t) {
  if (t >= K._0 && t <= K._9) return t - K._0;
  if (t >= K.A && t <= K.F) return t - (K.A - 10);
  if (t >= K.a && t <= K.f) return t - (K.a - 10);
}
function Ee(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  const e = t.length, n2 = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r2 = new Uint8Array(n2);
  for (let o2 = 0, s = 0; o2 < n2; o2++, s += 2) {
    const a2 = we(t.charCodeAt(s)), u3 = we(t.charCodeAt(s + 1));
    if (a2 === void 0 || u3 === void 0) {
      const i3 = t[s] + t[s + 1];
      throw new Error('hex string expected, got non-hex character "' + i3 + '" at index ' + s);
    }
    r2[o2] = a2 * 16 + u3;
  }
  return r2;
}
function Pn(t) {
  return pe(Ft(t));
}
function Et(t) {
  return Ut(t), pe(Ft(Uint8Array.from(t).reverse()));
}
function ge(t, e) {
  return Ee(t.toString(16).padStart(e * 2, "0"));
}
function Nt(t, e) {
  return ge(t, e).reverse();
}
function W(t, e, n2) {
  let r2;
  if (typeof e == "string") try {
    r2 = Ee(e);
  } catch (s) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + s);
  }
  else if (It(e)) r2 = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o2 = r2.length;
  if (typeof n2 == "number" && o2 !== n2) throw new Error(t + " of length " + n2 + " expected, got " + o2);
  return r2;
}
function ye(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o2 = t[r2];
    Ut(o2), e += o2.length;
  }
  const n2 = new Uint8Array(e);
  for (let r2 = 0, o2 = 0; r2 < t.length; r2++) {
    const s = t[r2];
    n2.set(s, o2), o2 += s.length;
  }
  return n2;
}
var Lt = (t) => typeof t == "bigint" && vt <= t;
function Qn(t, e, n2) {
  return Lt(t) && Lt(e) && Lt(n2) && e <= t && t < n2;
}
function ft(t, e, n2, r2) {
  if (!Qn(e, n2, r2)) throw new Error("expected valid " + t + ": " + n2 + " <= n < " + r2 + ", got " + e);
}
function tr(t) {
  let e;
  for (e = 0; t > vt; t >>= be, e += 1) ;
  return e;
}
var er = (t) => (Wn << BigInt(t - 1)) - be;
var nr = { bigint: (t) => typeof t == "bigint", function: (t) => typeof t == "function", boolean: (t) => typeof t == "boolean", string: (t) => typeof t == "string", stringOrUint8Array: (t) => typeof t == "string" || It(t), isSafeInteger: (t) => Number.isSafeInteger(t), array: (t) => Array.isArray(t), field: (t, e) => e.Fp.isValid(t), hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen) };
function Ot(t, e, n2 = {}) {
  const r2 = (o2, s, a2) => {
    const u3 = nr[s];
    if (typeof u3 != "function") throw new Error("invalid validator function");
    const i3 = t[o2];
    if (!(a2 && i3 === void 0) && !u3(i3, t)) throw new Error("param " + String(o2) + " is invalid. Expected " + s + ", got " + i3);
  };
  for (const [o2, s] of Object.entries(e)) r2(o2, s, false);
  for (const [o2, s] of Object.entries(n2)) r2(o2, s, true);
  return t;
}
function xe(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n2, ...r2) => {
    const o2 = e.get(n2);
    if (o2 !== void 0) return o2;
    const s = t(n2, ...r2);
    return e.set(n2, s), s;
  };
}
var M2 = BigInt(0);
var N = BigInt(1);
var nt = BigInt(2);
var rr = BigInt(3);
var Ht = BigInt(4);
var Be = BigInt(5);
var Ce = BigInt(8);
function H(t, e) {
  const n2 = t % e;
  return n2 >= M2 ? n2 : e + n2;
}
function or(t, e, n2) {
  if (e < M2) throw new Error("invalid exponent, negatives unsupported");
  if (n2 <= M2) throw new Error("invalid modulus");
  if (n2 === N) return M2;
  let r2 = N;
  for (; e > M2; ) e & N && (r2 = r2 * t % n2), t = t * t % n2, e >>= N;
  return r2;
}
function J2(t, e, n2) {
  let r2 = t;
  for (; e-- > M2; ) r2 *= r2, r2 %= n2;
  return r2;
}
function Ae(t, e) {
  if (t === M2) throw new Error("invert: expected non-zero number");
  if (e <= M2) throw new Error("invert: expected positive modulus, got " + e);
  let n2 = H(t, e), r2 = e, o2 = M2, s = N;
  for (; n2 !== M2; ) {
    const u3 = r2 / n2, i3 = r2 % n2, D2 = o2 - s * u3;
    r2 = n2, n2 = i3, o2 = s, s = D2;
  }
  if (r2 !== N) throw new Error("invert: does not exist");
  return H(o2, e);
}
function sr(t) {
  const e = (t - N) / nt;
  let n2, r2, o2;
  for (n2 = t - N, r2 = 0; n2 % nt === M2; n2 /= nt, r2++) ;
  for (o2 = nt; o2 < t && or(o2, e, t) !== t - N; o2++) if (o2 > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r2 === 1) {
    const a2 = (t + N) / Ht;
    return function(i3, D2) {
      const c3 = i3.pow(D2, a2);
      if (!i3.eql(i3.sqr(c3), D2)) throw new Error("Cannot find square root");
      return c3;
    };
  }
  const s = (n2 + N) / nt;
  return function(u3, i3) {
    if (u3.pow(i3, e) === u3.neg(u3.ONE)) throw new Error("Cannot find square root");
    let D2 = r2, c3 = u3.pow(u3.mul(u3.ONE, o2), n2), l4 = u3.pow(i3, s), p3 = u3.pow(i3, n2);
    for (; !u3.eql(p3, u3.ONE); ) {
      if (u3.eql(p3, u3.ZERO)) return u3.ZERO;
      let w3 = 1;
      for (let g2 = u3.sqr(p3); w3 < D2 && !u3.eql(g2, u3.ONE); w3++) g2 = u3.sqr(g2);
      const h5 = u3.pow(c3, N << BigInt(D2 - w3 - 1));
      c3 = u3.sqr(h5), l4 = u3.mul(l4, h5), p3 = u3.mul(p3, c3), D2 = w3;
    }
    return l4;
  };
}
function ir(t) {
  if (t % Ht === rr) {
    const e = (t + N) / Ht;
    return function(r2, o2) {
      const s = r2.pow(o2, e);
      if (!r2.eql(r2.sqr(s), o2)) throw new Error("Cannot find square root");
      return s;
    };
  }
  if (t % Ce === Be) {
    const e = (t - Be) / Ce;
    return function(r2, o2) {
      const s = r2.mul(o2, nt), a2 = r2.pow(s, e), u3 = r2.mul(o2, a2), i3 = r2.mul(r2.mul(u3, nt), a2), D2 = r2.mul(u3, r2.sub(i3, r2.ONE));
      if (!r2.eql(r2.sqr(D2), o2)) throw new Error("Cannot find square root");
      return D2;
    };
  }
  return sr(t);
}
var ur = (t, e) => (H(t, e) & N) === N;
var cr = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function ar(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, n2 = cr.reduce((r2, o2) => (r2[o2] = "function", r2), e);
  return Ot(t, n2);
}
function fr(t, e, n2) {
  if (n2 < M2) throw new Error("invalid exponent, negatives unsupported");
  if (n2 === M2) return t.ONE;
  if (n2 === N) return e;
  let r2 = t.ONE, o2 = e;
  for (; n2 > M2; ) n2 & N && (r2 = t.mul(r2, o2)), o2 = t.sqr(o2), n2 >>= N;
  return r2;
}
function Dr(t, e) {
  const n2 = new Array(e.length), r2 = e.reduce((s, a2, u3) => t.is0(a2) ? s : (n2[u3] = s, t.mul(s, a2)), t.ONE), o2 = t.inv(r2);
  return e.reduceRight((s, a2, u3) => t.is0(a2) ? s : (n2[u3] = t.mul(s, n2[u3]), t.mul(s, a2)), o2), n2;
}
function me(t, e) {
  const n2 = e !== void 0 ? e : t.toString(2).length, r2 = Math.ceil(n2 / 8);
  return { nBitLength: n2, nByteLength: r2 };
}
function _e(t, e, n2 = false, r2 = {}) {
  if (t <= M2) throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: o2, nByteLength: s } = me(t, e);
  if (s > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a2;
  const u3 = Object.freeze({ ORDER: t, isLE: n2, BITS: o2, BYTES: s, MASK: er(o2), ZERO: M2, ONE: N, create: (i3) => H(i3, t), isValid: (i3) => {
    if (typeof i3 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof i3);
    return M2 <= i3 && i3 < t;
  }, is0: (i3) => i3 === M2, isOdd: (i3) => (i3 & N) === N, neg: (i3) => H(-i3, t), eql: (i3, D2) => i3 === D2, sqr: (i3) => H(i3 * i3, t), add: (i3, D2) => H(i3 + D2, t), sub: (i3, D2) => H(i3 - D2, t), mul: (i3, D2) => H(i3 * D2, t), pow: (i3, D2) => fr(u3, i3, D2), div: (i3, D2) => H(i3 * Ae(D2, t), t), sqrN: (i3) => i3 * i3, addN: (i3, D2) => i3 + D2, subN: (i3, D2) => i3 - D2, mulN: (i3, D2) => i3 * D2, inv: (i3) => Ae(i3, t), sqrt: r2.sqrt || ((i3) => (a2 || (a2 = ir(t)), a2(u3, i3))), invertBatch: (i3) => Dr(u3, i3), cmov: (i3, D2, c3) => c3 ? D2 : i3, toBytes: (i3) => n2 ? Nt(i3, s) : ge(i3, s), fromBytes: (i3) => {
    if (i3.length !== s) throw new Error("Field.fromBytes: expected " + s + " bytes, got " + i3.length);
    return n2 ? Et(i3) : Pn(i3);
  } });
  return Object.freeze(u3);
}
var Se = BigInt(0);
var gt = BigInt(1);
function zt(t, e) {
  const n2 = e.negate();
  return t ? n2 : e;
}
function ve(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function Mt(t, e) {
  ve(t, e);
  const n2 = Math.ceil(e / t) + 1, r2 = 2 ** (t - 1);
  return { windows: n2, windowSize: r2 };
}
function dr(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n2, r2) => {
    if (!(n2 instanceof e)) throw new Error("invalid point at index " + r2);
  });
}
function hr(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n2, r2) => {
    if (!e.isValid(n2)) throw new Error("invalid scalar at index " + r2);
  });
}
var qt = /* @__PURE__ */ new WeakMap();
var Ie = /* @__PURE__ */ new WeakMap();
function $t(t) {
  return Ie.get(t) || 1;
}
function lr(t, e) {
  return { constTimeNegate: zt, hasPrecomputes(n2) {
    return $t(n2) !== 1;
  }, unsafeLadder(n2, r2, o2 = t.ZERO) {
    let s = n2;
    for (; r2 > Se; ) r2 & gt && (o2 = o2.add(s)), s = s.double(), r2 >>= gt;
    return o2;
  }, precomputeWindow(n2, r2) {
    const { windows: o2, windowSize: s } = Mt(r2, e), a2 = [];
    let u3 = n2, i3 = u3;
    for (let D2 = 0; D2 < o2; D2++) {
      i3 = u3, a2.push(i3);
      for (let c3 = 1; c3 < s; c3++) i3 = i3.add(u3), a2.push(i3);
      u3 = i3.double();
    }
    return a2;
  }, wNAF(n2, r2, o2) {
    const { windows: s, windowSize: a2 } = Mt(n2, e);
    let u3 = t.ZERO, i3 = t.BASE;
    const D2 = BigInt(2 ** n2 - 1), c3 = 2 ** n2, l4 = BigInt(n2);
    for (let p3 = 0; p3 < s; p3++) {
      const w3 = p3 * a2;
      let h5 = Number(o2 & D2);
      o2 >>= l4, h5 > a2 && (h5 -= c3, o2 += gt);
      const g2 = w3, S4 = w3 + Math.abs(h5) - 1, v5 = p3 % 2 !== 0, L3 = h5 < 0;
      h5 === 0 ? i3 = i3.add(zt(v5, r2[g2])) : u3 = u3.add(zt(L3, r2[S4]));
    }
    return { p: u3, f: i3 };
  }, wNAFUnsafe(n2, r2, o2, s = t.ZERO) {
    const { windows: a2, windowSize: u3 } = Mt(n2, e), i3 = BigInt(2 ** n2 - 1), D2 = 2 ** n2, c3 = BigInt(n2);
    for (let l4 = 0; l4 < a2; l4++) {
      const p3 = l4 * u3;
      if (o2 === Se) break;
      let w3 = Number(o2 & i3);
      if (o2 >>= c3, w3 > u3 && (w3 -= D2, o2 += gt), w3 === 0) continue;
      let h5 = r2[p3 + Math.abs(w3) - 1];
      w3 < 0 && (h5 = h5.negate()), s = s.add(h5);
    }
    return s;
  }, getPrecomputes(n2, r2, o2) {
    let s = qt.get(r2);
    return s || (s = this.precomputeWindow(r2, n2), n2 !== 1 && qt.set(r2, o2(s))), s;
  }, wNAFCached(n2, r2, o2) {
    const s = $t(n2);
    return this.wNAF(s, this.getPrecomputes(s, n2, o2), r2);
  }, wNAFCachedUnsafe(n2, r2, o2, s) {
    const a2 = $t(n2);
    return a2 === 1 ? this.unsafeLadder(n2, r2, s) : this.wNAFUnsafe(a2, this.getPrecomputes(a2, n2, o2), r2, s);
  }, setWindowSize(n2, r2) {
    ve(r2, e), Ie.set(n2, r2), qt.delete(n2);
  } };
}
function br(t, e, n2, r2) {
  if (dr(n2, t), hr(r2, e), n2.length !== r2.length) throw new Error("arrays of points and scalars must have equal length");
  const o2 = t.ZERO, s = tr(BigInt(n2.length)), a2 = s > 12 ? s - 3 : s > 4 ? s - 2 : s ? 2 : 1, u3 = (1 << a2) - 1, i3 = new Array(u3 + 1).fill(o2), D2 = Math.floor((e.BITS - 1) / a2) * a2;
  let c3 = o2;
  for (let l4 = D2; l4 >= 0; l4 -= a2) {
    i3.fill(o2);
    for (let w3 = 0; w3 < r2.length; w3++) {
      const h5 = r2[w3], g2 = Number(h5 >> BigInt(l4) & BigInt(u3));
      i3[g2] = i3[g2].add(n2[w3]);
    }
    let p3 = o2;
    for (let w3 = i3.length - 1, h5 = o2; w3 > 0; w3--) h5 = h5.add(i3[w3]), p3 = p3.add(h5);
    if (c3 = c3.add(p3), l4 !== 0) for (let w3 = 0; w3 < a2; w3++) c3 = c3.double();
  }
  return c3;
}
function pr(t) {
  return ar(t.Fp), Ot(t, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...me(t.n, t.nBitLength), ...t, p: t.Fp.ORDER });
}
var G = BigInt(0);
var j = BigInt(1);
var yt = BigInt(2);
var wr = BigInt(8);
var Er = { zip215: true };
function gr(t) {
  const e = pr(t);
  return Ot(t, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...e });
}
function yr(t) {
  const e = gr(t), { Fp: n2, n: r2, prehash: o2, hash: s, randomBytes: a2, nByteLength: u3, h: i3 } = e, D2 = yt << BigInt(u3 * 8) - j, c3 = n2.create, l4 = _e(e.n, e.nBitLength), p3 = e.uvRatio || ((y5, f7) => {
    try {
      return { isValid: true, value: n2.sqrt(y5 * n2.inv(f7)) };
    } catch {
      return { isValid: false, value: G };
    }
  }), w3 = e.adjustScalarBytes || ((y5) => y5), h5 = e.domain || ((y5, f7, b5) => {
    if (Tt("phflag", b5), f7.length || b5) throw new Error("Contexts/pre-hash are not supported");
    return y5;
  });
  function g2(y5, f7) {
    ft("coordinate " + y5, f7, G, D2);
  }
  function S4(y5) {
    if (!(y5 instanceof d4)) throw new Error("ExtendedPoint expected");
  }
  const v5 = xe((y5, f7) => {
    const { ex: b5, ey: E5, ez: B3 } = y5, C5 = y5.is0();
    f7 == null && (f7 = C5 ? wr : n2.inv(B3));
    const A4 = c3(b5 * f7), U4 = c3(E5 * f7), _ = c3(B3 * f7);
    if (C5) return { x: G, y: j };
    if (_ !== j) throw new Error("invZ was invalid");
    return { x: A4, y: U4 };
  }), L3 = xe((y5) => {
    const { a: f7, d: b5 } = e;
    if (y5.is0()) throw new Error("bad point: ZERO");
    const { ex: E5, ey: B3, ez: C5, et: A4 } = y5, U4 = c3(E5 * E5), _ = c3(B3 * B3), T2 = c3(C5 * C5), $4 = c3(T2 * T2), R4 = c3(U4 * f7), V5 = c3(T2 * c3(R4 + _)), Y4 = c3($4 + c3(b5 * c3(U4 * _)));
    if (V5 !== Y4) throw new Error("bad point: equation left != right (1)");
    const Z2 = c3(E5 * B3), X3 = c3(C5 * A4);
    if (Z2 !== X3) throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class d4 {
    constructor(f7, b5, E5, B3) {
      this.ex = f7, this.ey = b5, this.ez = E5, this.et = B3, g2("x", f7), g2("y", b5), g2("z", E5), g2("t", B3), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(f7) {
      if (f7 instanceof d4) throw new Error("extended point not allowed");
      const { x: b5, y: E5 } = f7 || {};
      return g2("x", b5), g2("y", E5), new d4(b5, E5, j, c3(b5 * E5));
    }
    static normalizeZ(f7) {
      const b5 = n2.invertBatch(f7.map((E5) => E5.ez));
      return f7.map((E5, B3) => E5.toAffine(b5[B3])).map(d4.fromAffine);
    }
    static msm(f7, b5) {
      return br(d4, l4, f7, b5);
    }
    _setWindowSize(f7) {
      q3.setWindowSize(this, f7);
    }
    assertValidity() {
      L3(this);
    }
    equals(f7) {
      S4(f7);
      const { ex: b5, ey: E5, ez: B3 } = this, { ex: C5, ey: A4, ez: U4 } = f7, _ = c3(b5 * U4), T2 = c3(C5 * B3), $4 = c3(E5 * U4), R4 = c3(A4 * B3);
      return _ === T2 && $4 === R4;
    }
    is0() {
      return this.equals(d4.ZERO);
    }
    negate() {
      return new d4(c3(-this.ex), this.ey, this.ez, c3(-this.et));
    }
    double() {
      const { a: f7 } = e, { ex: b5, ey: E5, ez: B3 } = this, C5 = c3(b5 * b5), A4 = c3(E5 * E5), U4 = c3(yt * c3(B3 * B3)), _ = c3(f7 * C5), T2 = b5 + E5, $4 = c3(c3(T2 * T2) - C5 - A4), R4 = _ + A4, V5 = R4 - U4, Y4 = _ - A4, Z2 = c3($4 * V5), X3 = c3(R4 * Y4), et3 = c3($4 * Y4), pt4 = c3(V5 * R4);
      return new d4(Z2, X3, pt4, et3);
    }
    add(f7) {
      S4(f7);
      const { a: b5, d: E5 } = e, { ex: B3, ey: C5, ez: A4, et: U4 } = this, { ex: _, ey: T2, ez: $4, et: R4 } = f7;
      if (b5 === BigInt(-1)) {
        const re4 = c3((C5 - B3) * (T2 + _)), oe3 = c3((C5 + B3) * (T2 - _)), mt4 = c3(oe3 - re4);
        if (mt4 === G) return this.double();
        const se4 = c3(A4 * yt * R4), ie4 = c3(U4 * yt * $4), ue4 = ie4 + se4, ce4 = oe3 + re4, ae4 = ie4 - se4, Dn2 = c3(ue4 * mt4), dn3 = c3(ce4 * ae4), hn3 = c3(ue4 * ae4), ln3 = c3(mt4 * ce4);
        return new d4(Dn2, dn3, ln3, hn3);
      }
      const V5 = c3(B3 * _), Y4 = c3(C5 * T2), Z2 = c3(U4 * E5 * R4), X3 = c3(A4 * $4), et3 = c3((B3 + C5) * (_ + T2) - V5 - Y4), pt4 = X3 - Z2, ee4 = X3 + Z2, ne4 = c3(Y4 - b5 * V5), un3 = c3(et3 * pt4), cn3 = c3(ee4 * ne4), an3 = c3(et3 * ne4), fn3 = c3(pt4 * ee4);
      return new d4(un3, cn3, fn3, an3);
    }
    subtract(f7) {
      return this.add(f7.negate());
    }
    wNAF(f7) {
      return q3.wNAFCached(this, f7, d4.normalizeZ);
    }
    multiply(f7) {
      const b5 = f7;
      ft("scalar", b5, j, r2);
      const { p: E5, f: B3 } = this.wNAF(b5);
      return d4.normalizeZ([E5, B3])[0];
    }
    multiplyUnsafe(f7, b5 = d4.ZERO) {
      const E5 = f7;
      return ft("scalar", E5, G, r2), E5 === G ? F4 : this.is0() || E5 === j ? this : q3.wNAFCachedUnsafe(this, E5, d4.normalizeZ, b5);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(i3).is0();
    }
    isTorsionFree() {
      return q3.unsafeLadder(this, r2).is0();
    }
    toAffine(f7) {
      return v5(this, f7);
    }
    clearCofactor() {
      const { h: f7 } = e;
      return f7 === j ? this : this.multiplyUnsafe(f7);
    }
    static fromHex(f7, b5 = false) {
      const { d: E5, a: B3 } = e, C5 = n2.BYTES;
      f7 = W("pointHex", f7, C5), Tt("zip215", b5);
      const A4 = f7.slice(), U4 = f7[C5 - 1];
      A4[C5 - 1] = U4 & -129;
      const _ = Et(A4), T2 = b5 ? D2 : n2.ORDER;
      ft("pointHex.y", _, G, T2);
      const $4 = c3(_ * _), R4 = c3($4 - j), V5 = c3(E5 * $4 - B3);
      let { isValid: Y4, value: Z2 } = p3(R4, V5);
      if (!Y4) throw new Error("Point.fromHex: invalid y coordinate");
      const X3 = (Z2 & j) === j, et3 = (U4 & 128) !== 0;
      if (!b5 && Z2 === G && et3) throw new Error("Point.fromHex: x=0 and x_0=1");
      return et3 !== X3 && (Z2 = c3(-Z2)), d4.fromAffine({ x: Z2, y: _ });
    }
    static fromPrivateKey(f7) {
      return O4(f7).point;
    }
    toRawBytes() {
      const { x: f7, y: b5 } = this.toAffine(), E5 = Nt(b5, n2.BYTES);
      return E5[E5.length - 1] |= f7 & j ? 128 : 0, E5;
    }
    toHex() {
      return Ft(this.toRawBytes());
    }
  }
  d4.BASE = new d4(e.Gx, e.Gy, j, c3(e.Gx * e.Gy)), d4.ZERO = new d4(G, j, j, G);
  const { BASE: m2, ZERO: F4 } = d4, q3 = lr(d4, u3 * 8);
  function z2(y5) {
    return H(y5, r2);
  }
  function I3(y5) {
    return z2(Et(y5));
  }
  function O4(y5) {
    const f7 = n2.BYTES;
    y5 = W("private key", y5, f7);
    const b5 = W("hashed private key", s(y5), 2 * f7), E5 = w3(b5.slice(0, f7)), B3 = b5.slice(f7, 2 * f7), C5 = I3(E5), A4 = m2.multiply(C5), U4 = A4.toRawBytes();
    return { head: E5, prefix: B3, scalar: C5, point: A4, pointBytes: U4 };
  }
  function ot3(y5) {
    return O4(y5).pointBytes;
  }
  function tt3(y5 = new Uint8Array(), ...f7) {
    const b5 = ye(...f7);
    return I3(s(h5(b5, W("context", y5), !!o2)));
  }
  function st2(y5, f7, b5 = {}) {
    y5 = W("message", y5), o2 && (y5 = o2(y5));
    const { prefix: E5, scalar: B3, pointBytes: C5 } = O4(f7), A4 = tt3(b5.context, E5, y5), U4 = m2.multiply(A4).toRawBytes(), _ = tt3(b5.context, U4, C5, y5), T2 = z2(A4 + _ * B3);
    ft("signature.s", T2, G, r2);
    const $4 = ye(U4, Nt(T2, n2.BYTES));
    return W("result", $4, n2.BYTES * 2);
  }
  const at3 = Er;
  function Ct3(y5, f7, b5, E5 = at3) {
    const { context: B3, zip215: C5 } = E5, A4 = n2.BYTES;
    y5 = W("signature", y5, 2 * A4), f7 = W("message", f7), b5 = W("publicKey", b5, A4), C5 !== void 0 && Tt("zip215", C5), o2 && (f7 = o2(f7));
    const U4 = Et(y5.slice(A4, 2 * A4));
    let _, T2, $4;
    try {
      _ = d4.fromHex(b5, C5), T2 = d4.fromHex(y5.slice(0, A4), C5), $4 = m2.multiplyUnsafe(U4);
    } catch {
      return false;
    }
    if (!C5 && _.isSmallOrder()) return false;
    const R4 = tt3(B3, T2.toRawBytes(), _.toRawBytes(), f7);
    return T2.add(_.multiplyUnsafe(R4)).subtract($4).clearCofactor().equals(d4.ZERO);
  }
  return m2._setWindowSize(8), { CURVE: e, getPublicKey: ot3, sign: st2, verify: Ct3, ExtendedPoint: d4, utils: { getExtendedPublicKey: O4, randomPrivateKey: () => a2(n2.BYTES), precompute(y5 = 8, f7 = d4.BASE) {
    return f7._setWindowSize(y5), f7.multiply(BigInt(3)), f7;
  } } };
}
BigInt(0), BigInt(1);
var kt = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var Ue = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
var xr = BigInt(1);
var Te = BigInt(2);
BigInt(3);
var Br = BigInt(5);
var Cr = BigInt(8);
function Ar(t) {
  const e = BigInt(10), n2 = BigInt(20), r2 = BigInt(40), o2 = BigInt(80), s = kt, u3 = t * t % s * t % s, i3 = J2(u3, Te, s) * u3 % s, D2 = J2(i3, xr, s) * t % s, c3 = J2(D2, Br, s) * D2 % s, l4 = J2(c3, e, s) * c3 % s, p3 = J2(l4, n2, s) * l4 % s, w3 = J2(p3, r2, s) * p3 % s, h5 = J2(w3, o2, s) * w3 % s, g2 = J2(h5, o2, s) * w3 % s, S4 = J2(g2, e, s) * c3 % s;
  return { pow_p_5_8: J2(S4, Te, s) * t % s, b2: u3 };
}
function mr(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
function _r(t, e) {
  const n2 = kt, r2 = H(e * e * e, n2), o2 = H(r2 * r2 * e, n2), s = Ar(t * o2).pow_p_5_8;
  let a2 = H(t * r2 * s, n2);
  const u3 = H(e * a2 * a2, n2), i3 = a2, D2 = H(a2 * Ue, n2), c3 = u3 === t, l4 = u3 === H(-t, n2), p3 = u3 === H(-t * Ue, n2);
  return c3 && (a2 = i3), (l4 || p3) && (a2 = D2), ur(a2, n2) && (a2 = H(-a2, n2)), { isValid: c3 || l4, value: a2 };
}
var Sr = (() => _e(kt, void 0, true))();
var vr = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: Sr, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: Cr, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: Kn, randomBytes: he, adjustScalarBytes: mr, uvRatio: _r }))();
var Rt = (() => yr(vr))();
var jt = "EdDSA";
var Zt = "JWT";
var ut = ".";
var Dt = "base64url";
var Gt = "utf8";
var xt = "utf8";
var Vt = ":";
var Yt = "did";
var Jt = "key";
var dt = "base58btc";
var Kt = "z";
var Wt = "K36";
var Ne = 32;
function Xt(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function Le(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Xt(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function Oe(t, e) {
  e || (e = t.reduce((o2, s) => o2 + s.length, 0));
  const n2 = Le(e);
  let r2 = 0;
  for (const o2 of t) n2.set(o2, r2), r2 += o2.length;
  return Xt(n2);
}
function Ir(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var n2 = new Uint8Array(256), r2 = 0; r2 < n2.length; r2++) n2[r2] = 255;
  for (var o2 = 0; o2 < t.length; o2++) {
    var s = t.charAt(o2), a2 = s.charCodeAt(0);
    if (n2[a2] !== 255) throw new TypeError(s + " is ambiguous");
    n2[a2] = o2;
  }
  var u3 = t.length, i3 = t.charAt(0), D2 = Math.log(u3) / Math.log(256), c3 = Math.log(256) / Math.log(u3);
  function l4(h5) {
    if (h5 instanceof Uint8Array || (ArrayBuffer.isView(h5) ? h5 = new Uint8Array(h5.buffer, h5.byteOffset, h5.byteLength) : Array.isArray(h5) && (h5 = Uint8Array.from(h5))), !(h5 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (h5.length === 0) return "";
    for (var g2 = 0, S4 = 0, v5 = 0, L3 = h5.length; v5 !== L3 && h5[v5] === 0; ) v5++, g2++;
    for (var d4 = (L3 - v5) * c3 + 1 >>> 0, m2 = new Uint8Array(d4); v5 !== L3; ) {
      for (var F4 = h5[v5], q3 = 0, z2 = d4 - 1; (F4 !== 0 || q3 < S4) && z2 !== -1; z2--, q3++) F4 += 256 * m2[z2] >>> 0, m2[z2] = F4 % u3 >>> 0, F4 = F4 / u3 >>> 0;
      if (F4 !== 0) throw new Error("Non-zero carry");
      S4 = q3, v5++;
    }
    for (var I3 = d4 - S4; I3 !== d4 && m2[I3] === 0; ) I3++;
    for (var O4 = i3.repeat(g2); I3 < d4; ++I3) O4 += t.charAt(m2[I3]);
    return O4;
  }
  function p3(h5) {
    if (typeof h5 != "string") throw new TypeError("Expected String");
    if (h5.length === 0) return new Uint8Array();
    var g2 = 0;
    if (h5[g2] !== " ") {
      for (var S4 = 0, v5 = 0; h5[g2] === i3; ) S4++, g2++;
      for (var L3 = (h5.length - g2) * D2 + 1 >>> 0, d4 = new Uint8Array(L3); h5[g2]; ) {
        var m2 = n2[h5.charCodeAt(g2)];
        if (m2 === 255) return;
        for (var F4 = 0, q3 = L3 - 1; (m2 !== 0 || F4 < v5) && q3 !== -1; q3--, F4++) m2 += u3 * d4[q3] >>> 0, d4[q3] = m2 % 256 >>> 0, m2 = m2 / 256 >>> 0;
        if (m2 !== 0) throw new Error("Non-zero carry");
        v5 = F4, g2++;
      }
      if (h5[g2] !== " ") {
        for (var z2 = L3 - v5; z2 !== L3 && d4[z2] === 0; ) z2++;
        for (var I3 = new Uint8Array(S4 + (L3 - z2)), O4 = S4; z2 !== L3; ) I3[O4++] = d4[z2++];
        return I3;
      }
    }
  }
  function w3(h5) {
    var g2 = p3(h5);
    if (g2) return g2;
    throw new Error(`Non-${e} character`);
  }
  return { encode: l4, decodeUnsafe: p3, decode: w3 };
}
var Ur = Ir;
var Tr = Ur;
var He = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
  if (t instanceof ArrayBuffer) return new Uint8Array(t);
  if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Fr = (t) => new TextEncoder().encode(t);
var Nr = (t) => new TextDecoder().decode(t);
var Lr = class {
  constructor(e, n2, r2) {
    this.name = e, this.prefix = n2, this.baseEncode = r2;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Or = class {
  constructor(e, n2, r2) {
    if (this.name = e, this.prefix = n2, n2.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = n2.codePointAt(0), this.baseDecode = r2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ze(this, e);
  }
};
var Hr = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ze(this, e);
  }
  decode(e) {
    const n2 = e[0], r2 = this.decoders[n2];
    if (r2) return r2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ze = (t, e) => new Hr({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } });
var zr = class {
  constructor(e, n2, r2, o2) {
    this.name = e, this.prefix = n2, this.baseEncode = r2, this.baseDecode = o2, this.encoder = new Lr(e, n2, r2), this.decoder = new Or(e, n2, o2);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Bt = ({ name: t, prefix: e, encode: n2, decode: r2 }) => new zr(t, e, n2, r2);
var ht = ({ prefix: t, name: e, alphabet: n2 }) => {
  const { encode: r2, decode: o2 } = Tr(n2, e);
  return Bt({ prefix: t, name: e, encode: r2, decode: (s) => He(o2(s)) });
};
var Mr = (t, e, n2, r2) => {
  const o2 = {};
  for (let c3 = 0; c3 < e.length; ++c3) o2[e[c3]] = c3;
  let s = t.length;
  for (; t[s - 1] === "="; ) --s;
  const a2 = new Uint8Array(s * n2 / 8 | 0);
  let u3 = 0, i3 = 0, D2 = 0;
  for (let c3 = 0; c3 < s; ++c3) {
    const l4 = o2[t[c3]];
    if (l4 === void 0) throw new SyntaxError(`Non-${r2} character`);
    i3 = i3 << n2 | l4, u3 += n2, u3 >= 8 && (u3 -= 8, a2[D2++] = 255 & i3 >> u3);
  }
  if (u3 >= n2 || 255 & i3 << 8 - u3) throw new SyntaxError("Unexpected end of data");
  return a2;
};
var qr = (t, e, n2) => {
  const r2 = e[e.length - 1] === "=", o2 = (1 << n2) - 1;
  let s = "", a2 = 0, u3 = 0;
  for (let i3 = 0; i3 < t.length; ++i3) for (u3 = u3 << 8 | t[i3], a2 += 8; a2 > n2; ) a2 -= n2, s += e[o2 & u3 >> a2];
  if (a2 && (s += e[o2 & u3 << n2 - a2]), r2) for (; s.length * n2 & 7; ) s += "=";
  return s;
};
var k3 = ({ name: t, prefix: e, bitsPerChar: n2, alphabet: r2 }) => Bt({ prefix: e, name: t, encode(o2) {
  return qr(o2, r2, n2);
}, decode(o2) {
  return Mr(o2, r2, n2, t);
} });
var $r = Bt({ prefix: "\0", name: "identity", encode: (t) => Nr(t), decode: (t) => Fr(t) });
var kr = Object.freeze({ __proto__: null, identity: $r });
var Rr = k3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var jr = Object.freeze({ __proto__: null, base2: Rr });
var Zr = k3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Gr = Object.freeze({ __proto__: null, base8: Zr });
var Vr = ht({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Yr = Object.freeze({ __proto__: null, base10: Vr });
var Jr = k3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Kr = k3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Wr = Object.freeze({ __proto__: null, base16: Jr, base16upper: Kr });
var Xr = k3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Pr = k3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Qr = k3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var to = k3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var eo = k3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var no = k3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ro = k3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var oo = k3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var so = k3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var io = Object.freeze({ __proto__: null, base32: Xr, base32upper: Pr, base32pad: Qr, base32padupper: to, base32hex: eo, base32hexupper: no, base32hexpad: ro, base32hexpadupper: oo, base32z: so });
var uo = ht({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var co = ht({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var ao = Object.freeze({ __proto__: null, base36: uo, base36upper: co });
var fo = ht({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Do = ht({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ho = Object.freeze({ __proto__: null, base58btc: fo, base58flickr: Do });
var lo = k3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var bo = k3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var po = k3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var wo = k3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Eo = Object.freeze({ __proto__: null, base64: lo, base64pad: bo, base64url: po, base64urlpad: wo });
var Me = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var go = Me.reduce((t, e, n2) => (t[n2] = e, t), []);
var yo = Me.reduce((t, e, n2) => (t[e.codePointAt(0)] = n2, t), []);
function xo(t) {
  return t.reduce((e, n2) => (e += go[n2], e), "");
}
function Bo(t) {
  const e = [];
  for (const n2 of t) {
    const r2 = yo[n2.codePointAt(0)];
    if (r2 === void 0) throw new Error(`Non-base256emoji character: ${n2}`);
    e.push(r2);
  }
  return new Uint8Array(e);
}
var Co = Bt({ prefix: "🚀", name: "base256emoji", encode: xo, decode: Bo });
var Ao = Object.freeze({ __proto__: null, base256emoji: Co });
var mo = $e;
var qe = 128;
var _o = 127;
var So = ~_o;
var vo = Math.pow(2, 31);
function $e(t, e, n2) {
  e = e || [], n2 = n2 || 0;
  for (var r2 = n2; t >= vo; ) e[n2++] = t & 255 | qe, t /= 128;
  for (; t & So; ) e[n2++] = t & 255 | qe, t >>>= 7;
  return e[n2] = t | 0, $e.bytes = n2 - r2 + 1, e;
}
var Io = Pt;
var Uo = 128;
var ke = 127;
function Pt(t, r2) {
  var n2 = 0, r2 = r2 || 0, o2 = 0, s = r2, a2, u3 = t.length;
  do {
    if (s >= u3) throw Pt.bytes = 0, new RangeError("Could not decode varint");
    a2 = t[s++], n2 += o2 < 28 ? (a2 & ke) << o2 : (a2 & ke) * Math.pow(2, o2), o2 += 7;
  } while (a2 >= Uo);
  return Pt.bytes = s - r2, n2;
}
var To = Math.pow(2, 7);
var Fo = Math.pow(2, 14);
var No = Math.pow(2, 21);
var Lo = Math.pow(2, 28);
var Oo = Math.pow(2, 35);
var Ho = Math.pow(2, 42);
var zo = Math.pow(2, 49);
var Mo = Math.pow(2, 56);
var qo = Math.pow(2, 63);
var $o = function(t) {
  return t < To ? 1 : t < Fo ? 2 : t < No ? 3 : t < Lo ? 4 : t < Oo ? 5 : t < Ho ? 6 : t < zo ? 7 : t < Mo ? 8 : t < qo ? 9 : 10;
};
var ko = { encode: mo, decode: Io, encodingLength: $o };
var Re = ko;
var je = (t, e, n2 = 0) => (Re.encode(t, e, n2), e);
var Ze = (t) => Re.encodingLength(t);
var Qt = (t, e) => {
  const n2 = e.byteLength, r2 = Ze(t), o2 = r2 + Ze(n2), s = new Uint8Array(o2 + n2);
  return je(t, s, 0), je(n2, s, r2), s.set(e, o2), new Ro(t, n2, e, s);
};
var Ro = class {
  constructor(e, n2, r2, o2) {
    this.code = e, this.size = n2, this.digest = r2, this.bytes = o2;
  }
};
var Ge = ({ name: t, code: e, encode: n2 }) => new jo(t, e, n2);
var jo = class {
  constructor(e, n2, r2) {
    this.name = e, this.code = n2, this.encode = r2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const n2 = this.encode(e);
      return n2 instanceof Uint8Array ? Qt(this.code, n2) : n2.then((r2) => Qt(this.code, r2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var Ve = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e));
var Zo = Ge({ name: "sha2-256", code: 18, encode: Ve("SHA-256") });
var Go = Ge({ name: "sha2-512", code: 19, encode: Ve("SHA-512") });
var Vo = Object.freeze({ __proto__: null, sha256: Zo, sha512: Go });
var Ye = 0;
var Yo = "identity";
var Je = He;
var Jo = (t) => Qt(Ye, Je(t));
var Ko = { code: Ye, name: Yo, encode: Je, digest: Jo };
var Wo = Object.freeze({ __proto__: null, identity: Ko });
new TextEncoder(), new TextDecoder();
var Ke = { ...kr, ...jr, ...Gr, ...Yr, ...Wr, ...io, ...ao, ...ho, ...Eo, ...Ao };
({ ...Vo, ...Wo });
function We(t, e, n2, r2) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: n2 }, decoder: { decode: r2 } };
}
var Xe = We("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1)));
var te = We("ascii", "a", (t) => {
  let e = "a";
  for (let n2 = 0; n2 < t.length; n2++) e += String.fromCharCode(t[n2]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = Le(t.length);
  for (let n2 = 0; n2 < t.length; n2++) e[n2] = t.charCodeAt(n2);
  return e;
});
var Pe = { utf8: Xe, "utf-8": Xe, hex: Ke.base16, latin1: te, ascii: te, binary: te, ...Ke };
function ct(t, e = "utf8") {
  const n2 = Pe[e];
  if (!n2) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : n2.encoder.encode(t).substring(1);
}
function rt(t, e = "utf8") {
  const n2 = Pe[e];
  if (!n2) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Xt(globalThis.Buffer.from(t, "utf-8")) : n2.decoder.decode(`${n2.prefix}${t}`);
}
function lt(t) {
  return safeJsonParse(ct(rt(t, Dt), Gt));
}
function bt(t) {
  return ct(rt(safeJsonStringify(t), Gt), Dt);
}
function Qe(t) {
  const e = rt(Wt, dt), n2 = Kt + ct(Oe([e, t]), dt);
  return [Yt, Jt, n2].join(Vt);
}
function en(t) {
  return ct(t, Dt);
}
function nn(t) {
  return rt(t, Dt);
}
function rn(t) {
  return rt([bt(t.header), bt(t.payload)].join(ut), xt);
}
function on(t) {
  return [bt(t.header), bt(t.payload), en(t.signature)].join(ut);
}
function sn(t) {
  const e = t.split(ut), n2 = lt(e[0]), r2 = lt(e[1]), o2 = nn(e[2]), s = rt(e.slice(0, 2).join(ut), xt);
  return { header: n2, payload: r2, signature: o2, data: s };
}
function Po(t = he(Ne)) {
  const e = Rt.getPublicKey(t);
  return { secretKey: Oe([t, e]), publicKey: e };
}
async function Qo(t, e, n2, r2, o2 = (0, import_time.fromMiliseconds)(Date.now())) {
  const s = { alg: jt, typ: Zt }, a2 = Qe(r2.publicKey), u3 = o2 + n2, i3 = { iss: a2, sub: t, aud: e, iat: o2, exp: u3 }, D2 = rn({ header: s, payload: i3 }), c3 = Rt.sign(D2, r2.secretKey.slice(0, 32));
  return on({ header: s, payload: i3, signature: c3 });
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/dist/index.es.js
var import_time2 = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey({ hash, signature }) {
  const hashHex = isHex(hash) ? hash : toHex2(hash);
  const { secp256k1: secp256k12 } = await import("./secp256k1-K34S57RF.js");
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r: r2, s, v: v5, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v5);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r2), hexToBigInt(s)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex2(signature);
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash, signature }));
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber(count);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = new Uint8Array(new Array(16).fill(0).map((_, i3) => i3));
var Pi = Id.map((i3) => (9 * i3 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i3 = 0; i3 < 4; i3++)
  for (let j3 of [idxL, idxR])
    j3.push(j3[i3].map((k6) => Rho[k6]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i3) => new Uint8Array(i3));
var shiftsL = idxL.map((idx, i3) => idx.map((j3) => shifts[i3][j3]));
var shiftsR = idxR.map((idx, i3) => idx.map((j3) => shifts[i3][j3]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr2 = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f3(group, x3, y5, z2) {
  if (group === 0)
    return x3 ^ y5 ^ z2;
  else if (group === 1)
    return x3 & y5 | ~x3 & z2;
  else if (group === 2)
    return (x3 | ~y5) ^ z2;
  else if (group === 3)
    return x3 & z2 | y5 & ~z2;
  else
    return x3 ^ (y5 | ~z2);
}
var R_BUF = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
    return [h0, h1, h22, h32, h42];
  }
  set(h0, h1, h22, h32, h42) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h42 | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4)
      R_BUF[i3] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar4 = al, bl = this.h1 | 0, br4 = bl, cl = this.h2 | 0, cr4 = cl, dl = this.h3 | 0, dr4 = dl, el = this.h4 | 0, er4 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr2[group];
      const rl = idxL[group], rr4 = idxR[group];
      const sl = shiftsL[group], sr4 = shiftsR[group];
      for (let i3 = 0; i3 < 16; i3++) {
        const tl = rotl(al + f3(group, bl, cl, dl) + R_BUF[rl[i3]] + hbl, sl[i3]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i3 = 0; i3 < 16; i3++) {
        const tr4 = rotl(ar4 + f3(rGroup, br4, cr4, dr4) + R_BUF[rr4[i3]] + hbr, sr4[i3]) + er4 | 0;
        ar4 = er4, er4 = dr4, dr4 = rotl(cr4, 10) | 0, cr4 = br4, br4 = tr4;
      }
    }
    this.set(this.h1 + cl + dr4 | 0, this.h2 + dl + er4 | 0, this.h3 + el + ar4 | 0, this.h4 + al + br4 | 0, this.h0 + bl + cr4 | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@reown/appkit/node_modules/@noble/curves/esm/abstract/utils.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var hexes = Array.from({ length: 256 }, (_, i3) => i3.toString(16).padStart(2, "0"));

// node_modules/@reown/appkit/node_modules/ox/_esm/core/version.js
var version = "0.1.1";

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/errors.js
function getVersion() {
  return version;
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Errors.js
var BaseError2 = class _BaseError extends Error {
  constructor(shortMessage, options = {}) {
    const details = (() => {
      if (options.cause instanceof _BaseError) {
        if (options.cause.details)
          return options.cause.details;
        if (options.cause.shortMessage)
          return options.cause.shortMessage;
      }
      if (options.cause?.message)
        return options.cause.message;
      return options.details;
    })();
    const docsPath = (() => {
      if (options.cause instanceof _BaseError)
        return options.cause.docsPath || options.docsPath;
      return options.docsPath;
    })();
    const docsBaseUrl = "https://oxlib.sh";
    const docs = `${docsBaseUrl}${docsPath ?? ""}`;
    const message = [
      shortMessage || "An error occurred.",
      ...options.metaMessages ? ["", ...options.metaMessages] : [],
      ...details || docsPath ? [
        "",
        details ? `Details: ${details}` : void 0,
        docsPath ? `See: ${docs}` : void 0
      ] : []
    ].filter((x3) => typeof x3 === "string").join("\n");
    super(message, options.cause ? { cause: options.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `ox@${getVersion()}`
    });
    this.cause = options.cause;
    this.details = details;
    this.docs = docs;
    this.docsPath = docsPath;
    this.shortMessage = shortMessage;
  }
  walk(fn3) {
    return walk(this, fn3);
  }
};
function walk(err, fn3) {
  if (fn3?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause)
    return walk(err.cause, fn3);
  return fn3 ? null : err;
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/bytes.js
function assertSize(bytes, size_) {
  if (size2(bytes) > size_)
    throw new SizeOverflowError({
      givenSize: size2(bytes),
      maxSize: size_
    });
}
var charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function pad2(bytes, options = {}) {
  const { dir, size: size4 = 32 } = options;
  if (size4 === 0)
    return bytes;
  if (bytes.length > size4)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size4,
      type: "Bytes"
    });
  const paddedBytes = new Uint8Array(size4);
  for (let i3 = 0; i3 < size4; i3++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i3 : size4 - i3 - 1] = bytes[padEnd ? i3 : bytes.length - i3 - 1];
  }
  return paddedBytes;
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/hex.js
function assertSize2(hex, size_) {
  if (size3(hex) > size_)
    throw new SizeOverflowError2({
      givenSize: size3(hex),
      maxSize: size_
    });
}
function pad3(hex_, options = {}) {
  const { dir, size: size4 = 32 } = options;
  if (size4 === 0)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size4 * 2)
    throw new SizeExceedsPaddingSizeError2({
      size: Math.ceil(hex.length / 2),
      targetSize: size4,
      type: "Hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size4 * 2, "0")}`;
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Bytes.js
var decoder = new TextDecoder();
var encoder = new TextEncoder();
function from(value) {
  if (value instanceof Uint8Array)
    return value;
  if (typeof value === "string")
    return fromHex2(value);
  return fromArray(value);
}
function fromArray(value) {
  return value instanceof Uint8Array ? value : new Uint8Array(value);
}
function fromHex2(value, options = {}) {
  const { size: size4 } = options;
  let hex = value;
  if (size4) {
    assertSize2(value, size4);
    hex = padRight(value, size4);
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j3 = 0; index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j3++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j3++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError2(`Invalid byte sequence ("${hexString[j3 - 2]}${hexString[j3 - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function fromString2(value, options = {}) {
  const { size: size4 } = options;
  const bytes = encoder.encode(value);
  if (typeof size4 === "number") {
    assertSize(bytes, size4);
    return padRight2(bytes, size4);
  }
  return bytes;
}
function padRight2(value, size4) {
  return pad2(value, { dir: "right", size: size4 });
}
function size2(value) {
  return value.length;
}
var SizeOverflowError = class extends BaseError2 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeOverflowError"
    });
  }
};
var SizeExceedsPaddingSizeError = class extends BaseError2 {
  constructor({ size: size4, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size4}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Hex.js
var encoder2 = new TextEncoder();
var hexes2 = Array.from({ length: 256 }, (_v, i3) => i3.toString(16).padStart(2, "0"));
function concat3(...values) {
  return `0x${values.reduce((acc, x3) => acc + x3.replace("0x", ""), "")}`;
}
function fromBoolean(value, options = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof options.size === "number") {
    assertSize2(hex, options.size);
    return padLeft(hex, options.size);
  }
  return hex;
}
function fromBytes2(value, options = {}) {
  let string = "";
  for (let i3 = 0; i3 < value.length; i3++)
    string += hexes2[value[i3]];
  const hex = `0x${string}`;
  if (typeof options.size === "number") {
    assertSize2(hex, options.size);
    return padRight(hex, options.size);
  }
  return hex;
}
function fromNumber(value, options = {}) {
  const { signed, size: size4 } = options;
  const value_ = BigInt(value);
  let maxValue;
  if (size4) {
    if (signed)
      maxValue = (1n << BigInt(size4) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size4) * 8n) - 1n;
  } else if (typeof value === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value_ > maxValue || value_ < minValue) {
    const suffix = typeof value === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size4,
      value: `${value}${suffix}`
    });
  }
  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size4 * 8)) + BigInt(value_) : value_).toString(16);
  const hex = `0x${stringValue}`;
  if (size4)
    return padLeft(hex, size4);
  return hex;
}
function fromString3(value, options = {}) {
  return fromBytes2(encoder2.encode(value), options);
}
function padLeft(value, size4) {
  return pad3(value, { dir: "left", size: size4 });
}
function padRight(value, size4) {
  return pad3(value, { dir: "right", size: size4 });
}
function size3(value) {
  return Math.ceil((value.length - 2) / 2);
}
var IntegerOutOfRangeError = class extends BaseError2 {
  constructor({ max, min, signed, size: size4, value }) {
    super(`Number \`${value}\` is not in safe${size4 ? ` ${size4 * 8}-bit` : ""}${signed ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
};
var SizeOverflowError2 = class extends BaseError2 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeOverflowError"
    });
  }
};
var SizeExceedsPaddingSizeError2 = class extends BaseError2 {
  constructor({ size: size4, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size4}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/@noble/hashes/esm/_assert.js
function anumber(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function isBytes2(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function abytes(b5, ...lengths) {
  if (!isBytes2(b5))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b5.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b5.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}

// node_modules/@reown/appkit/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@reown/appkit/node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var rotl2 = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
function byteSwap32(arr) {
  for (let i3 = 0; i3 < arr.length; i3++) {
    arr[i3] = byteSwap(arr[i3]);
  }
}
var hexes3 = Array.from({ length: 256 }, (_, i3) => i3.toString(16).padStart(2, "0"));
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// node_modules/@reown/appkit/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h5 = isLE2 ? 4 : 0;
  const l4 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h5, wh, isLE2);
  view.setUint32(byteOffset + l4, wl, isLE2);
}
var Chi = (a2, b5, c3) => a2 & b5 ^ ~a2 & c3;
var Maj = (a2, b5, c3) => a2 & b5 ^ a2 & c3 ^ b5 & c3;
var HashMD2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i3 = pos; i3 < blockLen; i3++)
      buffer[i3] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i3 = 0; i3 < outLen; i3++)
      oview.setUint32(4 * i3, state[i3], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to4) {
    to4 || (to4 = new this.constructor());
    to4.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to4.length = length;
    to4.pos = pos;
    to4.finished = finished;
    to4.destroyed = destroyed;
    if (length % blockLen)
      to4.buffer.set(buffer);
    return to4;
  }
};

// node_modules/@reown/appkit/node_modules/@noble/hashes/esm/ripemd160.js
var Rho2 = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id2 = new Uint8Array(new Array(16).fill(0).map((_, i3) => i3));
var Pi2 = Id2.map((i3) => (9 * i3 + 5) % 16);
var idxL2 = [Id2];
var idxR2 = [Pi2];
for (let i3 = 0; i3 < 4; i3++)
  for (let j3 of [idxL2, idxR2])
    j3.push(j3[i3].map((k6) => Rho2[k6]));
var shifts2 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i3) => new Uint8Array(i3));
var shiftsL2 = idxL2.map((idx, i3) => idx.map((j3) => shifts2[i3][j3]));
var shiftsR2 = idxR2.map((idx, i3) => idx.map((j3) => shifts2[i3][j3]));
var Kl2 = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr3 = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f4(group, x3, y5, z2) {
  if (group === 0)
    return x3 ^ y5 ^ z2;
  else if (group === 1)
    return x3 & y5 | ~x3 & z2;
  else if (group === 2)
    return (x3 | ~y5) ^ z2;
  else if (group === 3)
    return x3 & z2 | y5 & ~z2;
  else
    return x3 ^ (y5 | ~z2);
}
var R_BUF2 = new Uint32Array(16);
var RIPEMD1602 = class extends HashMD2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
    return [h0, h1, h22, h32, h42];
  }
  set(h0, h1, h22, h32, h42) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h42 | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4)
      R_BUF2[i3] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar4 = al, bl = this.h1 | 0, br4 = bl, cl = this.h2 | 0, cr4 = cl, dl = this.h3 | 0, dr4 = dl, el = this.h4 | 0, er4 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl2[group], hbr = Kr3[group];
      const rl = idxL2[group], rr4 = idxR2[group];
      const sl = shiftsL2[group], sr4 = shiftsR2[group];
      for (let i3 = 0; i3 < 16; i3++) {
        const tl = rotl2(al + f4(group, bl, cl, dl) + R_BUF2[rl[i3]] + hbl, sl[i3]) + el | 0;
        al = el, el = dl, dl = rotl2(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i3 = 0; i3 < 16; i3++) {
        const tr4 = rotl2(ar4 + f4(rGroup, br4, cr4, dr4) + R_BUF2[rr4[i3]] + hbr, sr4[i3]) + er4 | 0;
        ar4 = er4, er4 = dr4, dr4 = rotl2(cr4, 10) | 0, cr4 = br4, br4 = tr4;
      }
    }
    this.set(this.h1 + cl + dr4 | 0, this.h2 + dl + er4 | 0, this.h3 + el + ar4 | 0, this.h4 + al + br4 | 0, this.h0 + bl + cr4 | 0);
  }
  roundClean() {
    R_BUF2.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd1603 = wrapConstructor2(() => new RIPEMD1602());

// node_modules/@reown/appkit/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n2, le5 = false) {
  if (le5)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le5 = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i3 = 0; i3 < lst.length; i3++) {
    const { h: h5, l: l4 } = fromBig(lst[i3], le5);
    [Ah[i3], Al[i3]] = [h5, l4];
  }
  return [Ah, Al];
}
var rotlSH = (h5, l4, s) => h5 << s | l4 >>> 32 - s;
var rotlSL = (h5, l4, s) => l4 << s | h5 >>> 32 - s;
var rotlBH = (h5, l4, s) => l4 << s - 32 | h5 >>> 64 - s;
var rotlBL = (h5, l4, s) => h5 << s - 32 | l4 >>> 64 - s;

// node_modules/@reown/appkit/node_modules/@noble/hashes/esm/sha3.js
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R4 = _1n2, x3 = 1, y5 = 0; round < 24; round++) {
  [x3, y5] = [y5, (2 * x3 + 3 * y5) % 5];
  SHA3_PI.push(2 * (5 * y5 + x3));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n2;
  for (let j3 = 0; j3 < 7; j3++) {
    R4 = (R4 << _1n2 ^ (R4 >> _7n) * _0x71n) % _256n;
    if (R4 & _2n2)
      t ^= _1n2 << (_1n2 << BigInt(j3)) - _1n2;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h5, l4, s) => s > 32 ? rotlBH(h5, l4, s) : rotlSH(h5, l4, s);
var rotlL = (h5, l4, s) => s > 32 ? rotlBL(h5, l4, s) : rotlSL(h5, l4, s);
function keccakP(s, rounds = 24) {
  const B3 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x3 = 0; x3 < 10; x3++)
      B3[x3] = s[x3] ^ s[x3 + 10] ^ s[x3 + 20] ^ s[x3 + 30] ^ s[x3 + 40];
    for (let x3 = 0; x3 < 10; x3 += 2) {
      const idx1 = (x3 + 8) % 10;
      const idx0 = (x3 + 2) % 10;
      const B0 = B3[idx0];
      const B1 = B3[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B3[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B3[idx1 + 1];
      for (let y5 = 0; y5 < 50; y5 += 10) {
        s[x3 + y5] ^= Th;
        s[x3 + y5 + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y5 = 0; y5 < 50; y5 += 10) {
      for (let x3 = 0; x3 < 10; x3++)
        B3[x3] = s[y5 + x3];
      for (let x3 = 0; x3 < 10; x3++)
        s[y5 + x3] ^= ~B3[(x3 + 2) % 10] & B3[(x3 + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B3.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    anumber(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    if (!isLE)
      byteSwap32(this.state32);
    keccakP(this.state32, this.rounds);
    if (!isLE)
      byteSwap32(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists(this);
    const { blockLen, state } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i3 = 0; i3 < take; i3++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to4) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to4 || (to4 = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to4.state32.set(this.state32);
    to4.pos = this.pos;
    to4.posOut = this.posOut;
    to4.finished = this.finished;
    to4.rounds = rounds;
    to4.suffix = suffix;
    to4.outputLen = outputLen;
    to4.enableXOF = enableXOF;
    to4.destroyed = this.destroyed;
    return to4;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor2(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/@reown/appkit/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A4, B: B3, C: C5, D: D2, E: E5, F: F4, G: G4, H: H4 } = this;
    return [A4, B3, C5, D2, E5, F4, G4, H4];
  }
  // prettier-ignore
  set(A4, B3, C5, D2, E5, F4, G4, H4) {
    this.A = A4 | 0;
    this.B = B3 | 0;
    this.C = C5 | 0;
    this.D = D2 | 0;
    this.E = E5 | 0;
    this.F = F4 | 0;
    this.G = G4 | 0;
    this.H = H4 | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4)
      SHA256_W[i3] = view.getUint32(offset, false);
    for (let i3 = 16; i3 < 64; i3++) {
      const W15 = SHA256_W[i3 - 15];
      const W22 = SHA256_W[i3 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
      SHA256_W[i3] = s1 + SHA256_W[i3 - 7] + s0 + SHA256_W[i3 - 16] | 0;
    }
    let { A: A4, B: B3, C: C5, D: D2, E: E5, F: F4, G: G4, H: H4 } = this;
    for (let i3 = 0; i3 < 64; i3++) {
      const sigma1 = rotr(E5, 6) ^ rotr(E5, 11) ^ rotr(E5, 25);
      const T1 = H4 + sigma1 + Chi(E5, F4, G4) + SHA256_K[i3] + SHA256_W[i3] | 0;
      const sigma0 = rotr(A4, 2) ^ rotr(A4, 13) ^ rotr(A4, 22);
      const T2 = sigma0 + Maj(A4, B3, C5) | 0;
      H4 = G4;
      G4 = F4;
      F4 = E5;
      E5 = D2 + T1 | 0;
      D2 = C5;
      C5 = B3;
      B3 = A4;
      A4 = T1 + T2 | 0;
    }
    A4 = A4 + this.A | 0;
    B3 = B3 + this.B | 0;
    C5 = C5 + this.C | 0;
    D2 = D2 + this.D | 0;
    E5 = E5 + this.E | 0;
    F4 = F4 + this.F | 0;
    G4 = G4 + this.G | 0;
    H4 = H4 + this.H | 0;
    this.set(A4, B3, C5, D2, E5, F4, G4, H4);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha2563 = wrapConstructor2(() => new SHA256());
var sha224 = wrapConstructor2(() => new SHA224());

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Hash.js
function keccak2562(value, options = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value));
  if (as === "Bytes")
    return bytes;
  return fromBytes2(bytes);
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/lru.js
var LruMap2 = class extends Map {
  constructor(size4) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size4;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap2(8192)
};
var checksum = caches.checksum;

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex.test(value))
    throw new InvalidAddressError2({
      address: value,
      cause: new InvalidInputError()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError2({
        address: value,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2562(fromString2(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i3 = 0; i3 < 40; i3 += 2) {
    if (hash[i3 >> 1] >> 4 >= 8 && characters[i3]) {
      characters[i3] = characters[i3].toUpperCase();
    }
    if ((hash[i3 >> 1] & 15) >= 8 && characters[i3 + 1]) {
      characters[i3 + 1] = characters[i3 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
var InvalidAddressError2 = class extends BaseError2 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError = class extends BaseError2 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError2 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Solidity.js
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2562 = 2n ** 256n - 1n;

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size4) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size4 ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError = class extends BaseError2 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError2 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError2 {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked2(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i3 = 0; i3 < types.length; i3++) {
    const type = types[i3];
    const value = values[i3];
    data.push(encodePacked2.encode(type, value));
  }
  return concat3(...data);
}
(function(encodePacked3) {
  function encode4(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      assert(address);
      return padLeft(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString3(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return padLeft(fromBoolean(value), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size4 = Number.parseInt(bits) / 8;
      return fromNumber(value, {
        size: isArray ? 32 : size4,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size4] = bytesMatch;
      if (Number.parseInt(size4) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size4),
          value
        });
      return padRight(value, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i3 = 0; i3 < value.length; i3++) {
        data.push(encode4(childType, value[i3], true));
      }
      if (data.length === 0)
        return "0x";
      return concat3(...data);
    }
    throw new InvalidTypeError(type);
  }
  encodePacked3.encode = encode4;
})(encodePacked2 || (encodePacked2 = {}));
var BytesSizeMismatchError2 = class extends BaseError2 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size3(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError2 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError = class extends BaseError2 {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/relay-api/dist/index.es.js
var C = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } };

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/dist/index.es.js
var ae = ":";
function Ne2(t) {
  const [e, n2] = t.split(ae);
  return { namespace: e, reference: n2 };
}
function ue(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var Zo2 = Object.defineProperty;
var Yo2 = Object.defineProperties;
var Go2 = Object.getOwnPropertyDescriptors;
var Tn2 = Object.getOwnPropertySymbols;
var Wo2 = Object.prototype.hasOwnProperty;
var Xo = Object.prototype.propertyIsEnumerable;
var Rn2 = (t, e, n2) => e in t ? Zo2(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var _n2 = (t, e) => {
  for (var n2 in e || (e = {})) Wo2.call(e, n2) && Rn2(t, n2, e[n2]);
  if (Tn2) for (var n2 of Tn2(e)) Xo.call(e, n2) && Rn2(t, n2, e[n2]);
  return t;
};
var Jo2 = (t, e) => Yo2(t, Go2(e));
var $n2 = "ReactNative";
var Y = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var jn2 = "js";
function _e2() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function pt() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === $n2;
}
function ei() {
  return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function ni() {
  return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function Tt2() {
  return !_e2() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function xt2() {
  return pt() ? Y.reactNative : _e2() ? Y.node : Tt2() ? Y.browser : Y.unknown;
}
function ri() {
  var t;
  try {
    return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function Cn2(t, e) {
  const n2 = new URLSearchParams(t);
  for (const r2 of Object.keys(e).sort()) if (e.hasOwnProperty(r2)) {
    const o2 = e[r2];
    o2 !== void 0 && n2.set(r2, o2);
  }
  return n2.toString();
}
function oi(t) {
  var e, n2;
  const r2 = Pn2();
  try {
    return t != null && t.url && r2.url && new URL(t.url).host !== new URL(r2.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r2.url}. This is probably unintended and can lead to issues.`), t.url = r2.url), (e = t?.icons) != null && e.length && t.icons.length > 0 && (t.icons = t.icons.filter((o2) => o2 !== "")), Jo2(_n2(_n2({}, r2), t), { url: t?.url || r2.url, name: t?.name || r2.name, description: t?.description || r2.description, icons: (n2 = t?.icons) != null && n2.length && t.icons.length > 0 ? t.icons : r2.icons });
  } catch (o2) {
    return console.warn("Error populating app metadata", o2), t || r2;
  }
}
function Pn2() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function kn2() {
  if (xt2() === Y.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n2, Version: r2 } = global.Platform;
    return [n2, r2].join("-");
  }
  const t = detect();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function Vn2() {
  var t;
  const e = xt2();
  return e === Y.browser ? [e, ((t = (0, import_window_getters.getLocation)()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function Mn2(t, e, n2) {
  const r2 = kn2(), o2 = Vn2();
  return [[t, e].join("-"), [jn2, n2].join("-"), r2, o2].join("/");
}
function si({ protocol: t, version: e, relayUrl: n2, sdkVersion: r2, auth: o2, projectId: i3, useOnCloseEvent: s, bundleId: c3, packageName: a2 }) {
  const u3 = n2.split("?"), l4 = Mn2(t, e, r2), f7 = { auth: o2, ua: l4, projectId: i3, useOnCloseEvent: s || void 0, packageName: a2 || void 0, bundleId: c3 || void 0 }, h5 = Cn2(u3[1] || "", f7);
  return u3[0] + "?" + h5;
}
function gt2(t, e) {
  return t.filter((n2) => e.includes(n2)).length === t.length;
}
function fi(t) {
  return Object.fromEntries(t.entries());
}
function li(t) {
  return new Map(Object.entries(t));
}
function gi(t = import_time2.FIVE_MINUTES, e) {
  const n2 = (0, import_time2.toMiliseconds)(t || import_time2.FIVE_MINUTES);
  let r2, o2, i3, s;
  return { resolve: (c3) => {
    i3 && r2 && (clearTimeout(i3), r2(c3), s = Promise.resolve(c3));
  }, reject: (c3) => {
    i3 && o2 && (clearTimeout(i3), o2(c3));
  }, done: () => new Promise((c3, a2) => {
    if (s) return c3(s);
    i3 = setTimeout(() => {
      const u3 = new Error(e);
      s = Promise.reject(u3), a2(u3);
    }, n2), r2 = c3, o2 = a2;
  }) };
}
function yi(t, e, n2) {
  return new Promise(async (r2, o2) => {
    const i3 = setTimeout(() => o2(new Error(n2)), e);
    try {
      const s = await t;
      r2(s);
    } catch (s) {
      o2(s);
    }
    clearTimeout(i3);
  });
}
function $e2(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function mi(t) {
  return $e2("topic", t);
}
function wi(t) {
  return $e2("id", t);
}
function bi(t) {
  const [e, n2] = t.split(":"), r2 = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof n2 == "string") r2.topic = n2;
  else if (e === "id" && Number.isInteger(Number(n2))) r2.id = Number(n2);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n2}`);
  return r2;
}
function Ei(t, e) {
  return (0, import_time2.fromMiliseconds)((e || Date.now()) + (0, import_time2.toMiliseconds)(t));
}
function vi(t) {
  return Date.now() >= (0, import_time2.toMiliseconds)(t);
}
function xi(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function ot(t = [], e = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e])];
}
async function Si({ id: t, topic: e, wcDeepLink: n2 }) {
  var r2;
  try {
    if (!n2) return;
    const o2 = typeof n2 == "string" ? JSON.parse(n2) : n2, i3 = o2?.href;
    if (typeof i3 != "string") return;
    const s = Kn2(i3, t, e), c3 = xt2();
    if (c3 === Y.browser) {
      if (!((r2 = (0, import_window_getters.getDocument)()) != null && r2.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      Fn2(s);
    } else c3 === Y.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (o2) {
    console.error(o2);
  }
}
function Kn2(t, e, n2) {
  const r2 = `requestId=${e}&sessionTopic=${n2}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let o2 = `${t}`;
  if (t.startsWith("https://t.me")) {
    const i3 = t.includes("?") ? "&startapp=" : "?startapp=";
    o2 = `${o2}${i3}${Yn2(r2, true)}`;
  } else o2 = `${o2}/wc?${r2}`;
  return o2;
}
function Fn2(t) {
  let e = "_self";
  Zn2() ? e = "_top" : (zn2() || t.startsWith("https://") || t.startsWith("http://")) && (e = "_blank"), window.open(t, e, "noreferrer noopener");
}
async function Oi(t, e) {
  let n2 = "";
  try {
    if (Tt2() && (n2 = localStorage.getItem(e), n2)) return n2;
    n2 = await t.getItem(e);
  } catch (r2) {
    console.error(r2);
  }
  return n2;
}
function Ai(t, e) {
  if (!t.includes(e)) return null;
  const n2 = t.split(/([&,?,=])/), r2 = n2.indexOf(e);
  return n2[r2 + 2];
}
function Bi() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e = Math.random() * 16 | 0;
    return (t === "x" ? e : e & 3 | 8).toString(16);
  });
}
function Ii() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function zn2() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function Zn2() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function Yn2(t, e = false) {
  const n2 = Buffer.from(t).toString("base64");
  return e ? n2.replace(/[=]/g, "") : n2;
}
function je2(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
function Ni(t) {
  return new Promise((e) => setTimeout(e, t));
}
function Wt2(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function Ui(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Xt2(t, ...e) {
  if (!Ui(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Ce2(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Wt2(t.outputLen), Wt2(t.blockLen);
}
function Rt2(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Gn2(t, e) {
  Xt2(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
var le2 = BigInt(2 ** 32 - 1);
var Wn2 = BigInt(32);
function Ti(t, e = false) {
  return e ? { h: Number(t & le2), l: Number(t >> Wn2 & le2) } : { h: Number(t >> Wn2 & le2) | 0, l: Number(t & le2) | 0 };
}
function Ri(t, e = false) {
  let n2 = new Uint32Array(t.length), r2 = new Uint32Array(t.length);
  for (let o2 = 0; o2 < t.length; o2++) {
    const { h: i3, l: s } = Ti(t[o2], e);
    [n2[o2], r2[o2]] = [i3, s];
  }
  return [n2, r2];
}
var _i = (t, e, n2) => t << n2 | e >>> 32 - n2;
var $i = (t, e, n2) => e << n2 | t >>> 32 - n2;
var Li = (t, e, n2) => e << n2 - 32 | t >>> 64 - n2;
var ji = (t, e, n2) => t << n2 - 32 | e >>> 64 - n2;
var _t2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Ci(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Pe2(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function ct2(t, e) {
  return t << 32 - e | t >>> e;
}
var Xn2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Pi3(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function Jn2(t) {
  for (let e = 0; e < t.length; e++) t[e] = Pi3(t[e]);
}
function ki(t) {
  if (typeof t != "string") throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function $t2(t) {
  return typeof t == "string" && (t = ki(t)), Xt2(t), t;
}
function Vi(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o2 = t[r2];
    Xt2(o2), e += o2.length;
  }
  const n2 = new Uint8Array(e);
  for (let r2 = 0, o2 = 0; r2 < t.length; r2++) {
    const i3 = t[r2];
    n2.set(i3, o2), o2 += i3.length;
  }
  return n2;
}
var ke2 = class {
  clone() {
    return this._cloneInto();
  }
};
function Qn2(t) {
  const e = (r2) => t().update($t2(r2)).digest(), n2 = t();
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = () => t(), e;
}
function Lt2(t = 32) {
  if (_t2 && typeof _t2.getRandomValues == "function") return _t2.getRandomValues(new Uint8Array(t));
  if (_t2 && typeof _t2.randomBytes == "function") return _t2.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
var tr2 = [];
var er2 = [];
var nr2 = [];
var Mi = BigInt(0);
var Jt2 = BigInt(1);
var Di = BigInt(2);
var Hi = BigInt(7);
var qi = BigInt(256);
var Ki = BigInt(113);
for (let t = 0, e = Jt2, n2 = 1, r2 = 0; t < 24; t++) {
  [n2, r2] = [r2, (2 * n2 + 3 * r2) % 5], tr2.push(2 * (5 * r2 + n2)), er2.push((t + 1) * (t + 2) / 2 % 64);
  let o2 = Mi;
  for (let i3 = 0; i3 < 7; i3++) e = (e << Jt2 ^ (e >> Hi) * Ki) % qi, e & Di && (o2 ^= Jt2 << (Jt2 << BigInt(i3)) - Jt2);
  nr2.push(o2);
}
var [Fi, zi] = Ri(nr2, true);
var rr2 = (t, e, n2) => n2 > 32 ? Li(t, e, n2) : _i(t, e, n2);
var or2 = (t, e, n2) => n2 > 32 ? ji(t, e, n2) : $i(t, e, n2);
function Zi(t, e = 24) {
  const n2 = new Uint32Array(10);
  for (let r2 = 24 - e; r2 < 24; r2++) {
    for (let s = 0; s < 10; s++) n2[s] = t[s] ^ t[s + 10] ^ t[s + 20] ^ t[s + 30] ^ t[s + 40];
    for (let s = 0; s < 10; s += 2) {
      const c3 = (s + 8) % 10, a2 = (s + 2) % 10, u3 = n2[a2], l4 = n2[a2 + 1], f7 = rr2(u3, l4, 1) ^ n2[c3], h5 = or2(u3, l4, 1) ^ n2[c3 + 1];
      for (let y5 = 0; y5 < 50; y5 += 10) t[s + y5] ^= f7, t[s + y5 + 1] ^= h5;
    }
    let o2 = t[2], i3 = t[3];
    for (let s = 0; s < 24; s++) {
      const c3 = er2[s], a2 = rr2(o2, i3, c3), u3 = or2(o2, i3, c3), l4 = tr2[s];
      o2 = t[l4], i3 = t[l4 + 1], t[l4] = a2, t[l4 + 1] = u3;
    }
    for (let s = 0; s < 50; s += 10) {
      for (let c3 = 0; c3 < 10; c3++) n2[c3] = t[s + c3];
      for (let c3 = 0; c3 < 10; c3++) t[s + c3] ^= ~n2[(c3 + 2) % 10] & n2[(c3 + 4) % 10];
    }
    t[0] ^= Fi[r2], t[1] ^= zi[r2];
  }
  n2.fill(0);
}
var En2 = class _En extends ke2 {
  constructor(e, n2, r2, o2 = false, i3 = 24) {
    if (super(), this.blockLen = e, this.suffix = n2, this.outputLen = r2, this.enableXOF = o2, this.rounds = i3, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Wt2(r2), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Ci(this.state);
  }
  keccak() {
    Xn2 || Jn2(this.state32), Zi(this.state32, this.rounds), Xn2 || Jn2(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Rt2(this);
    const { blockLen: n2, state: r2 } = this;
    e = $t2(e);
    const o2 = e.length;
    for (let i3 = 0; i3 < o2; ) {
      const s = Math.min(n2 - this.pos, o2 - i3);
      for (let c3 = 0; c3 < s; c3++) r2[this.pos++] ^= e[i3++];
      this.pos === n2 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n2, pos: r2, blockLen: o2 } = this;
    e[r2] ^= n2, (n2 & 128) !== 0 && r2 === o2 - 1 && this.keccak(), e[o2 - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Rt2(this, false), Xt2(e), this.finish();
    const n2 = this.state, { blockLen: r2 } = this;
    for (let o2 = 0, i3 = e.length; o2 < i3; ) {
      this.posOut >= r2 && this.keccak();
      const s = Math.min(r2 - this.posOut, i3 - o2);
      e.set(n2.subarray(this.posOut, this.posOut + s), o2), this.posOut += s, o2 += s;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Wt2(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Gn2(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: n2, suffix: r2, outputLen: o2, rounds: i3, enableXOF: s } = this;
    return e || (e = new _En(n2, r2, o2, s, i3)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i3, e.suffix = r2, e.outputLen = o2, e.enableXOF = s, e.destroyed = this.destroyed, e;
  }
};
var Yi = (t, e, n2) => Qn2(() => new En2(e, t, n2));
var Gi = Yi(1, 136, 256 / 8);
var Wi = "https://rpc.walletconnect.org/v1";
function Ve2(t) {
  const e = `Ethereum Signed Message:
${t.length}`, n2 = new TextEncoder().encode(e + t);
  return "0x" + Buffer.from(Gi(n2)).toString("hex");
}
async function ir2(t, e, n2, r2, o2, i3) {
  switch (n2.t) {
    case "eip191":
      return await sr2(t, e, n2.s);
    case "eip1271":
      return await cr2(t, e, n2.s, r2, o2, i3);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n2.t}`);
  }
}
async function sr2(t, e, n2) {
  return (await recoverAddress({ hash: Ve2(e), signature: n2 })).toLowerCase() === t.toLowerCase();
}
async function cr2(t, e, n2, r2, o2, i3) {
  const s = Ne2(r2);
  if (!s.namespace || !s.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r2}`);
  try {
    const c3 = "0x1626ba7e", a2 = "0000000000000000000000000000000000000000000000000000000000000040", u3 = "0000000000000000000000000000000000000000000000000000000000000041", l4 = n2.substring(2), f7 = Ve2(e).substring(2), h5 = c3 + f7 + a2 + u3 + l4, y5 = await fetch(`${i3 || Wi}/?chainId=${r2}&projectId=${o2}`, { method: "POST", body: JSON.stringify({ id: Xi(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: h5 }, "latest"] }) }), { result: E5 } = await y5.json();
    return E5 ? E5.slice(0, c3.length).toLowerCase() === c3.toLowerCase() : false;
  } catch (c3) {
    return console.error("isValidEip1271Signature: ", c3), false;
  }
}
function Xi() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function Ji(t) {
  const e = atob(t), n2 = new Uint8Array(e.length);
  for (let s = 0; s < e.length; s++) n2[s] = e.charCodeAt(s);
  const r2 = n2[0];
  if (r2 === 0) throw new Error("No signatures found");
  const o2 = 1 + r2 * 64;
  if (n2.length < o2) throw new Error("Transaction data too short for claimed signature count");
  if (n2.length < 100) throw new Error("Transaction too short");
  const i3 = Buffer.from(t, "base64").slice(1, 65);
  return esm_default.encode(i3);
}
var Qi = Object.defineProperty;
var ts = Object.defineProperties;
var es = Object.getOwnPropertyDescriptors;
var ar2 = Object.getOwnPropertySymbols;
var ns = Object.prototype.hasOwnProperty;
var rs = Object.prototype.propertyIsEnumerable;
var ur2 = (t, e, n2) => e in t ? Qi(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var Me2 = (t, e) => {
  for (var n2 in e || (e = {})) ns.call(e, n2) && ur2(t, n2, e[n2]);
  if (ar2) for (var n2 of ar2(e)) rs.call(e, n2) && ur2(t, n2, e[n2]);
  return t;
};
var fr2 = (t, e) => ts(t, es(e));
var os = "did:pkh:";
var de2 = (t) => t?.split(":");
var lr2 = (t) => {
  const e = t && de2(t);
  if (e) return t.includes(os) ? e[3] : e[1];
};
var dr2 = (t) => {
  const e = t && de2(t);
  if (e) return e[2] + ":" + e[3];
};
var De2 = (t) => {
  const e = t && de2(t);
  if (e) return e.pop();
};
async function is(t) {
  const { cacao: e, projectId: n2 } = t, { s: r2, p: o2 } = e, i3 = hr2(o2, o2.iss), s = De2(o2.iss);
  return await ir2(s, i3, r2, dr2(o2.iss), n2);
}
var hr2 = (t, e) => {
  const n2 = `${t.domain} wants you to sign in with your Ethereum account:`, r2 = De2(e);
  if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o2 = t.statement || void 0;
  const i3 = `URI: ${t.aud || t.uri}`, s = `Version: ${t.version}`, c3 = `Chain ID: ${lr2(e)}`, a2 = `Nonce: ${t.nonce}`, u3 = `Issued At: ${t.iat}`, l4 = t.exp ? `Expiration Time: ${t.exp}` : void 0, f7 = t.nbf ? `Not Before: ${t.nbf}` : void 0, h5 = t.requestId ? `Request ID: ${t.requestId}` : void 0, y5 = t.resources ? `Resources:${t.resources.map((p3) => `
- ${p3}`).join("")}` : void 0, E5 = pe2(t.resources);
  if (E5) {
    const p3 = yt2(E5);
    o2 = Ke2(o2, p3);
  }
  return [n2, r2, "", o2, "", i3, s, c3, a2, u3, l4, f7, h5, y5].filter((p3) => p3 != null).join(`
`);
};
function mr2(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function wr2(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function at(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((n2) => {
    const r2 = t.att[n2];
    if (Array.isArray(r2)) throw new Error(`Resource must be an object: ${n2}`);
    if (typeof r2 != "object") throw new Error(`Resource must be an object: ${n2}`);
    if (!Object.keys(r2).length) throw new Error(`Resource object is empty: ${n2}`);
    Object.keys(r2).forEach((o2) => {
      const i3 = r2[o2];
      if (!Array.isArray(i3)) throw new Error(`Ability limits ${o2} must be an array of objects, found: ${i3}`);
      if (!i3.length) throw new Error(`Value of ${o2} is empty array, must be an array with objects`);
      i3.forEach((s) => {
        if (typeof s != "object") throw new Error(`Ability limits (${o2}) must be an array of objects, found: ${s}`);
      });
    });
  });
}
function br2(t, e, n2, r2 = {}) {
  return n2?.sort((o2, i3) => o2.localeCompare(i3)), { att: { [t]: He2(e, n2, r2) } };
}
function He2(t, e, n2 = {}) {
  e = e?.sort((o2, i3) => o2.localeCompare(i3));
  const r2 = e.map((o2) => ({ [`${t}/${o2}`]: [n2] }));
  return Object.assign({}, ...r2);
}
function he2(t) {
  return at(t), `urn:recap:${mr2(t).replace(/=/g, "")}`;
}
function yt2(t) {
  const e = wr2(t.replace("urn:recap:", ""));
  return at(e), e;
}
function fs(t, e, n2) {
  const r2 = br2(t, e, n2);
  return he2(r2);
}
function qe2(t) {
  return t && t.includes("urn:recap:");
}
function ls(t, e) {
  const n2 = yt2(t), r2 = yt2(e), o2 = vr2(n2, r2);
  return he2(o2);
}
function vr2(t, e) {
  at(t), at(e);
  const n2 = Object.keys(t.att).concat(Object.keys(e.att)).sort((o2, i3) => o2.localeCompare(i3)), r2 = { att: {} };
  return n2.forEach((o2) => {
    var i3, s;
    Object.keys(((i3 = t.att) == null ? void 0 : i3[o2]) || {}).concat(Object.keys(((s = e.att) == null ? void 0 : s[o2]) || {})).sort((c3, a2) => c3.localeCompare(a2)).forEach((c3) => {
      var a2, u3;
      r2.att[o2] = fr2(Me2({}, r2.att[o2]), { [c3]: ((a2 = t.att[o2]) == null ? void 0 : a2[c3]) || ((u3 = e.att[o2]) == null ? void 0 : u3[c3]) });
    });
  }), r2;
}
function Ke2(t = "", e) {
  at(e);
  const n2 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(n2)) return t;
  const r2 = [];
  let o2 = 0;
  Object.keys(e.att).forEach((c3) => {
    const a2 = Object.keys(e.att[c3]).map((f7) => ({ ability: f7.split("/")[0], action: f7.split("/")[1] }));
    a2.sort((f7, h5) => f7.action.localeCompare(h5.action));
    const u3 = {};
    a2.forEach((f7) => {
      u3[f7.ability] || (u3[f7.ability] = []), u3[f7.ability].push(f7.action);
    });
    const l4 = Object.keys(u3).map((f7) => (o2++, `(${o2}) '${f7}': '${u3[f7].join("', '")}' for '${c3}'.`));
    r2.push(l4.join(", ").replace(".,", "."));
  });
  const i3 = r2.join(" "), s = `${n2}${i3}`;
  return `${t ? t + " " : ""}${s}`;
}
function ds(t) {
  var e;
  const n2 = yt2(t);
  at(n2);
  const r2 = (e = n2.att) == null ? void 0 : e.eip155;
  return r2 ? Object.keys(r2).map((o2) => o2.split("/")[1]) : [];
}
function hs(t) {
  const e = yt2(t);
  at(e);
  const n2 = [];
  return Object.values(e.att).forEach((r2) => {
    Object.values(r2).forEach((o2) => {
      var i3;
      (i3 = o2?.[0]) != null && i3.chains && n2.push(o2[0].chains);
    });
  }), [...new Set(n2.flat())];
}
function pe2(t) {
  if (!t) return;
  const e = t?.[t.length - 1];
  return qe2(e) ? e : void 0;
}
function Fe(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function Sr2(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function tt(t, ...e) {
  if (!Sr2(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Or2(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function ps(t, e) {
  tt(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function Ar2(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
var mt = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
var gs = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
var ys = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!ys) throw new Error("Non little-endian hardware is not supported");
function ms(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function ze2(t) {
  if (typeof t == "string") t = ms(t);
  else if (Sr2(t)) t = Ze2(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function ws(t, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(t, e);
}
function bs(t, e) {
  if (t.length !== e.length) return false;
  let n2 = 0;
  for (let r2 = 0; r2 < t.length; r2++) n2 |= t[r2] ^ e[r2];
  return n2 === 0;
}
var Es = (t, e) => {
  function n2(r2, ...o2) {
    if (tt(r2), t.nonceLength !== void 0) {
      const l4 = o2[0];
      if (!l4) throw new Error("nonce / iv required");
      t.varSizeNonce ? tt(l4) : tt(l4, t.nonceLength);
    }
    const i3 = t.tagLength;
    i3 && o2[1] !== void 0 && tt(o2[1]);
    const s = e(r2, ...o2), c3 = (l4, f7) => {
      if (f7 !== void 0) {
        if (l4 !== 2) throw new Error("cipher output not supported");
        tt(f7);
      }
    };
    let a2 = false;
    return { encrypt(l4, f7) {
      if (a2) throw new Error("cannot encrypt() twice with same key + nonce");
      return a2 = true, tt(l4), c3(s.encrypt.length, f7), s.encrypt(l4, f7);
    }, decrypt(l4, f7) {
      if (tt(l4), i3 && l4.length < i3) throw new Error("invalid ciphertext length: smaller than tagLength=" + i3);
      return c3(s.decrypt.length, f7), s.decrypt(l4, f7);
    } };
  }
  return Object.assign(n2, t), n2;
};
function Br2(t, e, n2 = true) {
  if (e === void 0) return new Uint8Array(t);
  if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
  if (n2 && !vs(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function Ir2(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o2 = BigInt(32), i3 = BigInt(4294967295), s = Number(n2 >> o2 & i3), c3 = Number(n2 & i3), a2 = r2 ? 4 : 0, u3 = r2 ? 0 : 4;
  t.setUint32(e + a2, s, r2), t.setUint32(e + u3, c3, r2);
}
function vs(t) {
  return t.byteOffset % 4 === 0;
}
function Ze2(t) {
  return Uint8Array.from(t);
}
function jt2(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
var Nr2 = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0)));
var xs = Nr2("expand 16-byte k");
var Ss = Nr2("expand 32-byte k");
var Os = mt(xs);
var As = mt(Ss);
function V2(t, e) {
  return t << e | t >>> 32 - e;
}
function Ye2(t) {
  return t.byteOffset % 4 === 0;
}
var ge2 = 64;
var Bs = 16;
var Ur2 = 2 ** 32 - 1;
var Tr2 = new Uint32Array();
function Is(t, e, n2, r2, o2, i3, s, c3) {
  const a2 = o2.length, u3 = new Uint8Array(ge2), l4 = mt(u3), f7 = Ye2(o2) && Ye2(i3), h5 = f7 ? mt(o2) : Tr2, y5 = f7 ? mt(i3) : Tr2;
  for (let E5 = 0; E5 < a2; s++) {
    if (t(e, n2, r2, l4, s, c3), s >= Ur2) throw new Error("arx: counter overflow");
    const p3 = Math.min(ge2, a2 - E5);
    if (f7 && p3 === ge2) {
      const d4 = E5 / 4;
      if (E5 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let v5 = 0, m2; v5 < Bs; v5++) m2 = d4 + v5, y5[m2] = h5[m2] ^ l4[v5];
      E5 += ge2;
      continue;
    }
    for (let d4 = 0, v5; d4 < p3; d4++) v5 = E5 + d4, i3[v5] = o2[v5] ^ u3[d4];
    E5 += p3;
  }
}
function Ns(t, e) {
  const { allowShortKeys: n2, extendNonceFn: r2, counterLength: o2, counterRight: i3, rounds: s } = ws({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e);
  if (typeof t != "function") throw new Error("core must be a function");
  return Fe(o2), Fe(s), Ar2(i3), Ar2(n2), (c3, a2, u3, l4, f7 = 0) => {
    tt(c3), tt(a2), tt(u3);
    const h5 = u3.length;
    if (l4 === void 0 && (l4 = new Uint8Array(h5)), tt(l4), Fe(f7), f7 < 0 || f7 >= Ur2) throw new Error("arx: counter overflow");
    if (l4.length < h5) throw new Error(`arx: output (${l4.length}) is shorter than data (${h5})`);
    const y5 = [];
    let E5 = c3.length, p3, d4;
    if (E5 === 32) y5.push(p3 = Ze2(c3)), d4 = As;
    else if (E5 === 16 && n2) p3 = new Uint8Array(32), p3.set(c3), p3.set(c3, 16), d4 = Os, y5.push(p3);
    else throw new Error(`arx: invalid 32-byte key, got length=${E5}`);
    Ye2(a2) || y5.push(a2 = Ze2(a2));
    const v5 = mt(p3);
    if (r2) {
      if (a2.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r2(d4, v5, mt(a2.subarray(0, 16)), v5), a2 = a2.subarray(16);
    }
    const m2 = 16 - o2;
    if (m2 !== a2.length) throw new Error(`arx: nonce must be ${m2} or 16 bytes`);
    if (m2 !== 12) {
      const N4 = new Uint8Array(12);
      N4.set(a2, i3 ? 0 : 12 - a2.length), a2 = N4, y5.push(a2);
    }
    const O4 = mt(a2);
    return Is(t, d4, v5, O4, u3, l4, f7, s), jt2(...y5), l4;
  };
}
var F = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
var Us = class {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e = ze2(e), tt(e, 32);
    const n2 = F(e, 0), r2 = F(e, 2), o2 = F(e, 4), i3 = F(e, 6), s = F(e, 8), c3 = F(e, 10), a2 = F(e, 12), u3 = F(e, 14);
    this.r[0] = n2 & 8191, this.r[1] = (n2 >>> 13 | r2 << 3) & 8191, this.r[2] = (r2 >>> 10 | o2 << 6) & 7939, this.r[3] = (o2 >>> 7 | i3 << 9) & 8191, this.r[4] = (i3 >>> 4 | s << 12) & 255, this.r[5] = s >>> 1 & 8190, this.r[6] = (s >>> 14 | c3 << 2) & 8191, this.r[7] = (c3 >>> 11 | a2 << 5) & 8065, this.r[8] = (a2 >>> 8 | u3 << 8) & 8191, this.r[9] = u3 >>> 5 & 127;
    for (let l4 = 0; l4 < 8; l4++) this.pad[l4] = F(e, 16 + 2 * l4);
  }
  process(e, n2, r2 = false) {
    const o2 = r2 ? 0 : 2048, { h: i3, r: s } = this, c3 = s[0], a2 = s[1], u3 = s[2], l4 = s[3], f7 = s[4], h5 = s[5], y5 = s[6], E5 = s[7], p3 = s[8], d4 = s[9], v5 = F(e, n2 + 0), m2 = F(e, n2 + 2), O4 = F(e, n2 + 4), N4 = F(e, n2 + 6), $4 = F(e, n2 + 8), B3 = F(e, n2 + 10), A4 = F(e, n2 + 12), T2 = F(e, n2 + 14);
    let S4 = i3[0] + (v5 & 8191), L3 = i3[1] + ((v5 >>> 13 | m2 << 3) & 8191), U4 = i3[2] + ((m2 >>> 10 | O4 << 6) & 8191), _ = i3[3] + ((O4 >>> 7 | N4 << 9) & 8191), j3 = i3[4] + ((N4 >>> 4 | $4 << 12) & 8191), g2 = i3[5] + ($4 >>> 1 & 8191), w3 = i3[6] + (($4 >>> 14 | B3 << 2) & 8191), b5 = i3[7] + ((B3 >>> 11 | A4 << 5) & 8191), I3 = i3[8] + ((A4 >>> 8 | T2 << 8) & 8191), R4 = i3[9] + (T2 >>> 5 | o2), x3 = 0, C5 = x3 + S4 * c3 + L3 * (5 * d4) + U4 * (5 * p3) + _ * (5 * E5) + j3 * (5 * y5);
    x3 = C5 >>> 13, C5 &= 8191, C5 += g2 * (5 * h5) + w3 * (5 * f7) + b5 * (5 * l4) + I3 * (5 * u3) + R4 * (5 * a2), x3 += C5 >>> 13, C5 &= 8191;
    let P4 = x3 + S4 * a2 + L3 * c3 + U4 * (5 * d4) + _ * (5 * p3) + j3 * (5 * E5);
    x3 = P4 >>> 13, P4 &= 8191, P4 += g2 * (5 * y5) + w3 * (5 * h5) + b5 * (5 * f7) + I3 * (5 * l4) + R4 * (5 * u3), x3 += P4 >>> 13, P4 &= 8191;
    let k6 = x3 + S4 * u3 + L3 * a2 + U4 * c3 + _ * (5 * d4) + j3 * (5 * p3);
    x3 = k6 >>> 13, k6 &= 8191, k6 += g2 * (5 * E5) + w3 * (5 * y5) + b5 * (5 * h5) + I3 * (5 * f7) + R4 * (5 * l4), x3 += k6 >>> 13, k6 &= 8191;
    let M5 = x3 + S4 * l4 + L3 * u3 + U4 * a2 + _ * c3 + j3 * (5 * d4);
    x3 = M5 >>> 13, M5 &= 8191, M5 += g2 * (5 * p3) + w3 * (5 * E5) + b5 * (5 * y5) + I3 * (5 * h5) + R4 * (5 * f7), x3 += M5 >>> 13, M5 &= 8191;
    let D2 = x3 + S4 * f7 + L3 * l4 + U4 * u3 + _ * a2 + j3 * c3;
    x3 = D2 >>> 13, D2 &= 8191, D2 += g2 * (5 * d4) + w3 * (5 * p3) + b5 * (5 * E5) + I3 * (5 * y5) + R4 * (5 * h5), x3 += D2 >>> 13, D2 &= 8191;
    let z2 = x3 + S4 * h5 + L3 * f7 + U4 * l4 + _ * u3 + j3 * a2;
    x3 = z2 >>> 13, z2 &= 8191, z2 += g2 * c3 + w3 * (5 * d4) + b5 * (5 * p3) + I3 * (5 * E5) + R4 * (5 * y5), x3 += z2 >>> 13, z2 &= 8191;
    let Z2 = x3 + S4 * y5 + L3 * h5 + U4 * f7 + _ * l4 + j3 * u3;
    x3 = Z2 >>> 13, Z2 &= 8191, Z2 += g2 * a2 + w3 * c3 + b5 * (5 * d4) + I3 * (5 * p3) + R4 * (5 * E5), x3 += Z2 >>> 13, Z2 &= 8191;
    let st2 = x3 + S4 * E5 + L3 * y5 + U4 * h5 + _ * f7 + j3 * l4;
    x3 = st2 >>> 13, st2 &= 8191, st2 += g2 * u3 + w3 * a2 + b5 * c3 + I3 * (5 * d4) + R4 * (5 * p3), x3 += st2 >>> 13, st2 &= 8191;
    let W4 = x3 + S4 * p3 + L3 * E5 + U4 * y5 + _ * h5 + j3 * f7;
    x3 = W4 >>> 13, W4 &= 8191, W4 += g2 * l4 + w3 * u3 + b5 * a2 + I3 * c3 + R4 * (5 * d4), x3 += W4 >>> 13, W4 &= 8191;
    let J4 = x3 + S4 * d4 + L3 * p3 + U4 * E5 + _ * y5 + j3 * h5;
    x3 = J4 >>> 13, J4 &= 8191, J4 += g2 * f7 + w3 * l4 + b5 * u3 + I3 * a2 + R4 * c3, x3 += J4 >>> 13, J4 &= 8191, x3 = (x3 << 2) + x3 | 0, x3 = x3 + C5 | 0, C5 = x3 & 8191, x3 = x3 >>> 13, P4 += x3, i3[0] = C5, i3[1] = P4, i3[2] = k6, i3[3] = M5, i3[4] = D2, i3[5] = z2, i3[6] = Z2, i3[7] = st2, i3[8] = W4, i3[9] = J4;
  }
  finalize() {
    const { h: e, pad: n2 } = this, r2 = new Uint16Array(10);
    let o2 = e[1] >>> 13;
    e[1] &= 8191;
    for (let c3 = 2; c3 < 10; c3++) e[c3] += o2, o2 = e[c3] >>> 13, e[c3] &= 8191;
    e[0] += o2 * 5, o2 = e[0] >>> 13, e[0] &= 8191, e[1] += o2, o2 = e[1] >>> 13, e[1] &= 8191, e[2] += o2, r2[0] = e[0] + 5, o2 = r2[0] >>> 13, r2[0] &= 8191;
    for (let c3 = 1; c3 < 10; c3++) r2[c3] = e[c3] + o2, o2 = r2[c3] >>> 13, r2[c3] &= 8191;
    r2[9] -= 8192;
    let i3 = (o2 ^ 1) - 1;
    for (let c3 = 0; c3 < 10; c3++) r2[c3] &= i3;
    i3 = ~i3;
    for (let c3 = 0; c3 < 10; c3++) e[c3] = e[c3] & i3 | r2[c3];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let s = e[0] + n2[0];
    e[0] = s & 65535;
    for (let c3 = 1; c3 < 8; c3++) s = (e[c3] + n2[c3] | 0) + (s >>> 16) | 0, e[c3] = s & 65535;
    jt2(r2);
  }
  update(e) {
    Or2(this);
    const { buffer: n2, blockLen: r2 } = this;
    e = ze2(e);
    const o2 = e.length;
    for (let i3 = 0; i3 < o2; ) {
      const s = Math.min(r2 - this.pos, o2 - i3);
      if (s === r2) {
        for (; r2 <= o2 - i3; i3 += r2) this.process(e, i3);
        continue;
      }
      n2.set(e.subarray(i3, i3 + s), this.pos), this.pos += s, i3 += s, this.pos === r2 && (this.process(n2, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    jt2(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    Or2(this), ps(e, this), this.finished = true;
    const { buffer: n2, h: r2 } = this;
    let { pos: o2 } = this;
    if (o2) {
      for (n2[o2++] = 1; o2 < 16; o2++) n2[o2] = 0;
      this.process(n2, 0, true);
    }
    this.finalize();
    let i3 = 0;
    for (let s = 0; s < 8; s++) e[i3++] = r2[s] >>> 0, e[i3++] = r2[s] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
};
function Ts(t) {
  const e = (r2, o2) => t(o2).update(ze2(r2)).digest(), n2 = t(new Uint8Array(32));
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = (r2) => t(r2), e;
}
var Rs = Ts((t) => new Us(t));
function _s(t, e, n2, r2, o2, i3 = 20) {
  let s = t[0], c3 = t[1], a2 = t[2], u3 = t[3], l4 = e[0], f7 = e[1], h5 = e[2], y5 = e[3], E5 = e[4], p3 = e[5], d4 = e[6], v5 = e[7], m2 = o2, O4 = n2[0], N4 = n2[1], $4 = n2[2], B3 = s, A4 = c3, T2 = a2, S4 = u3, L3 = l4, U4 = f7, _ = h5, j3 = y5, g2 = E5, w3 = p3, b5 = d4, I3 = v5, R4 = m2, x3 = O4, C5 = N4, P4 = $4;
  for (let M5 = 0; M5 < i3; M5 += 2) B3 = B3 + L3 | 0, R4 = V2(R4 ^ B3, 16), g2 = g2 + R4 | 0, L3 = V2(L3 ^ g2, 12), B3 = B3 + L3 | 0, R4 = V2(R4 ^ B3, 8), g2 = g2 + R4 | 0, L3 = V2(L3 ^ g2, 7), A4 = A4 + U4 | 0, x3 = V2(x3 ^ A4, 16), w3 = w3 + x3 | 0, U4 = V2(U4 ^ w3, 12), A4 = A4 + U4 | 0, x3 = V2(x3 ^ A4, 8), w3 = w3 + x3 | 0, U4 = V2(U4 ^ w3, 7), T2 = T2 + _ | 0, C5 = V2(C5 ^ T2, 16), b5 = b5 + C5 | 0, _ = V2(_ ^ b5, 12), T2 = T2 + _ | 0, C5 = V2(C5 ^ T2, 8), b5 = b5 + C5 | 0, _ = V2(_ ^ b5, 7), S4 = S4 + j3 | 0, P4 = V2(P4 ^ S4, 16), I3 = I3 + P4 | 0, j3 = V2(j3 ^ I3, 12), S4 = S4 + j3 | 0, P4 = V2(P4 ^ S4, 8), I3 = I3 + P4 | 0, j3 = V2(j3 ^ I3, 7), B3 = B3 + U4 | 0, P4 = V2(P4 ^ B3, 16), b5 = b5 + P4 | 0, U4 = V2(U4 ^ b5, 12), B3 = B3 + U4 | 0, P4 = V2(P4 ^ B3, 8), b5 = b5 + P4 | 0, U4 = V2(U4 ^ b5, 7), A4 = A4 + _ | 0, R4 = V2(R4 ^ A4, 16), I3 = I3 + R4 | 0, _ = V2(_ ^ I3, 12), A4 = A4 + _ | 0, R4 = V2(R4 ^ A4, 8), I3 = I3 + R4 | 0, _ = V2(_ ^ I3, 7), T2 = T2 + j3 | 0, x3 = V2(x3 ^ T2, 16), g2 = g2 + x3 | 0, j3 = V2(j3 ^ g2, 12), T2 = T2 + j3 | 0, x3 = V2(x3 ^ T2, 8), g2 = g2 + x3 | 0, j3 = V2(j3 ^ g2, 7), S4 = S4 + L3 | 0, C5 = V2(C5 ^ S4, 16), w3 = w3 + C5 | 0, L3 = V2(L3 ^ w3, 12), S4 = S4 + L3 | 0, C5 = V2(C5 ^ S4, 8), w3 = w3 + C5 | 0, L3 = V2(L3 ^ w3, 7);
  let k6 = 0;
  r2[k6++] = s + B3 | 0, r2[k6++] = c3 + A4 | 0, r2[k6++] = a2 + T2 | 0, r2[k6++] = u3 + S4 | 0, r2[k6++] = l4 + L3 | 0, r2[k6++] = f7 + U4 | 0, r2[k6++] = h5 + _ | 0, r2[k6++] = y5 + j3 | 0, r2[k6++] = E5 + g2 | 0, r2[k6++] = p3 + w3 | 0, r2[k6++] = d4 + b5 | 0, r2[k6++] = v5 + I3 | 0, r2[k6++] = m2 + R4 | 0, r2[k6++] = O4 + x3 | 0, r2[k6++] = N4 + C5 | 0, r2[k6++] = $4 + P4 | 0;
}
var $s = Ns(_s, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Ls = new Uint8Array(16);
var Rr2 = (t, e) => {
  t.update(e);
  const n2 = e.length % 16;
  n2 && t.update(Ls.subarray(n2));
};
var js = new Uint8Array(32);
function _r2(t, e, n2, r2, o2) {
  const i3 = t(e, n2, js), s = Rs.create(i3);
  o2 && Rr2(s, o2), Rr2(s, r2);
  const c3 = new Uint8Array(16), a2 = gs(c3);
  Ir2(a2, 0, BigInt(o2 ? o2.length : 0), true), Ir2(a2, 8, BigInt(r2.length), true), s.update(c3);
  const u3 = s.digest();
  return jt2(i3, c3), u3;
}
var Cs = (t) => (e, n2, r2) => ({ encrypt(i3, s) {
  const c3 = i3.length;
  s = Br2(c3 + 16, s, false), s.set(i3);
  const a2 = s.subarray(0, -16);
  t(e, n2, a2, a2, 1);
  const u3 = _r2(t, e, n2, a2, r2);
  return s.set(u3, c3), jt2(u3), s;
}, decrypt(i3, s) {
  s = Br2(i3.length - 16, s, false);
  const c3 = i3.subarray(0, -16), a2 = i3.subarray(-16), u3 = _r2(t, e, n2, c3, r2);
  if (!bs(a2, u3)) throw new Error("invalid tag");
  return s.set(i3.subarray(0, -16)), t(e, n2, s, s, 1), jt2(u3), s;
} });
var $r2 = Es({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Cs($s));
var Lr2 = class extends ke2 {
  constructor(e, n2) {
    super(), this.finished = false, this.destroyed = false, Ce2(e);
    const r2 = $t2(n2);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o2 = this.blockLen, i3 = new Uint8Array(o2);
    i3.set(r2.length > o2 ? e.create().update(r2).digest() : r2);
    for (let s = 0; s < i3.length; s++) i3[s] ^= 54;
    this.iHash.update(i3), this.oHash = e.create();
    for (let s = 0; s < i3.length; s++) i3[s] ^= 106;
    this.oHash.update(i3), i3.fill(0);
  }
  update(e) {
    return Rt2(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Rt2(this), Xt2(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n2, iHash: r2, finished: o2, destroyed: i3, blockLen: s, outputLen: c3 } = this;
    return e = e, e.finished = o2, e.destroyed = i3, e.blockLen = s, e.outputLen = c3, e.oHash = n2._cloneInto(e.oHash), e.iHash = r2._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var ye2 = (t, e, n2) => new Lr2(t, e).update(n2).digest();
ye2.create = (t, e) => new Lr2(t, e);
function Ps(t, e, n2) {
  return Ce2(t), n2 === void 0 && (n2 = new Uint8Array(t.outputLen)), ye2(t, $t2(n2), $t2(e));
}
var Ge2 = new Uint8Array([0]);
var jr2 = new Uint8Array();
function ks(t, e, n2, r2 = 32) {
  if (Ce2(t), Wt2(r2), r2 > 255 * t.outputLen) throw new Error("Length should be <= 255*HashLen");
  const o2 = Math.ceil(r2 / t.outputLen);
  n2 === void 0 && (n2 = jr2);
  const i3 = new Uint8Array(o2 * t.outputLen), s = ye2.create(t, e), c3 = s._cloneInto(), a2 = new Uint8Array(s.outputLen);
  for (let u3 = 0; u3 < o2; u3++) Ge2[0] = u3 + 1, c3.update(u3 === 0 ? jr2 : a2).update(n2).update(Ge2).digestInto(a2), i3.set(a2, t.outputLen * u3), s._cloneInto(c3);
  return s.destroy(), c3.destroy(), a2.fill(0), Ge2.fill(0), i3.slice(0, r2);
}
var Vs = (t, e, n2, r2, o2) => ks(t, Ps(t, e, n2), r2, o2);
function Ms(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o2 = BigInt(32), i3 = BigInt(4294967295), s = Number(n2 >> o2 & i3), c3 = Number(n2 & i3), a2 = r2 ? 4 : 0, u3 = r2 ? 0 : 4;
  t.setUint32(e + a2, s, r2), t.setUint32(e + u3, c3, r2);
}
function Ds(t, e, n2) {
  return t & e ^ ~t & n2;
}
function Hs(t, e, n2) {
  return t & e ^ t & n2 ^ e & n2;
}
var qs = class extends ke2 {
  constructor(e, n2, r2, o2) {
    super(), this.blockLen = e, this.outputLen = n2, this.padOffset = r2, this.isLE = o2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = Pe2(this.buffer);
  }
  update(e) {
    Rt2(this);
    const { view: n2, buffer: r2, blockLen: o2 } = this;
    e = $t2(e);
    const i3 = e.length;
    for (let s = 0; s < i3; ) {
      const c3 = Math.min(o2 - this.pos, i3 - s);
      if (c3 === o2) {
        const a2 = Pe2(e);
        for (; o2 <= i3 - s; s += o2) this.process(a2, s);
        continue;
      }
      r2.set(e.subarray(s, s + c3), this.pos), this.pos += c3, s += c3, this.pos === o2 && (this.process(n2, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Rt2(this), Gn2(e, this), this.finished = true;
    const { buffer: n2, view: r2, blockLen: o2, isLE: i3 } = this;
    let { pos: s } = this;
    n2[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o2 - s && (this.process(r2, 0), s = 0);
    for (let f7 = s; f7 < o2; f7++) n2[f7] = 0;
    Ms(r2, o2 - 8, BigInt(this.length * 8), i3), this.process(r2, 0);
    const c3 = Pe2(e), a2 = this.outputLen;
    if (a2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u3 = a2 / 4, l4 = this.get();
    if (u3 > l4.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f7 = 0; f7 < u3; f7++) c3.setUint32(4 * f7, l4[f7], i3);
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n2, buffer: r2, length: o2, finished: i3, destroyed: s, pos: c3 } = this;
    return e.length = o2, e.pos = c3, e.finished = i3, e.destroyed = s, o2 % n2 && e.buffer.set(r2), e;
  }
};
var Ks = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var wt2 = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var bt2 = new Uint32Array(64);
var Fs = class extends qs {
  constructor() {
    super(64, 32, 8, false), this.A = wt2[0] | 0, this.B = wt2[1] | 0, this.C = wt2[2] | 0, this.D = wt2[3] | 0, this.E = wt2[4] | 0, this.F = wt2[5] | 0, this.G = wt2[6] | 0, this.H = wt2[7] | 0;
  }
  get() {
    const { A: e, B: n2, C: r2, D: o2, E: i3, F: s, G: c3, H: a2 } = this;
    return [e, n2, r2, o2, i3, s, c3, a2];
  }
  set(e, n2, r2, o2, i3, s, c3, a2) {
    this.A = e | 0, this.B = n2 | 0, this.C = r2 | 0, this.D = o2 | 0, this.E = i3 | 0, this.F = s | 0, this.G = c3 | 0, this.H = a2 | 0;
  }
  process(e, n2) {
    for (let f7 = 0; f7 < 16; f7++, n2 += 4) bt2[f7] = e.getUint32(n2, false);
    for (let f7 = 16; f7 < 64; f7++) {
      const h5 = bt2[f7 - 15], y5 = bt2[f7 - 2], E5 = ct2(h5, 7) ^ ct2(h5, 18) ^ h5 >>> 3, p3 = ct2(y5, 17) ^ ct2(y5, 19) ^ y5 >>> 10;
      bt2[f7] = p3 + bt2[f7 - 7] + E5 + bt2[f7 - 16] | 0;
    }
    let { A: r2, B: o2, C: i3, D: s, E: c3, F: a2, G: u3, H: l4 } = this;
    for (let f7 = 0; f7 < 64; f7++) {
      const h5 = ct2(c3, 6) ^ ct2(c3, 11) ^ ct2(c3, 25), y5 = l4 + h5 + Ds(c3, a2, u3) + Ks[f7] + bt2[f7] | 0, p3 = (ct2(r2, 2) ^ ct2(r2, 13) ^ ct2(r2, 22)) + Hs(r2, o2, i3) | 0;
      l4 = u3, u3 = a2, a2 = c3, c3 = s + y5 | 0, s = i3, i3 = o2, o2 = r2, r2 = y5 + p3 | 0;
    }
    r2 = r2 + this.A | 0, o2 = o2 + this.B | 0, i3 = i3 + this.C | 0, s = s + this.D | 0, c3 = c3 + this.E | 0, a2 = a2 + this.F | 0, u3 = u3 + this.G | 0, l4 = l4 + this.H | 0, this.set(r2, o2, i3, s, c3, a2, u3, l4);
  }
  roundClean() {
    bt2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var Qt2 = Qn2(() => new Fs());
var me2 = BigInt(0);
var we2 = BigInt(1);
var zs = BigInt(2);
function St2(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function te2(t) {
  if (!St2(t)) throw new Error("Uint8Array expected");
}
function Ct(t, e) {
  if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e);
}
var Zs = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Pt2(t) {
  te2(t);
  let e = "";
  for (let n2 = 0; n2 < t.length; n2++) e += Zs[t[n2]];
  return e;
}
function kt2(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function We2(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? me2 : BigInt("0x" + t);
}
var ut2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Cr2(t) {
  if (t >= ut2._0 && t <= ut2._9) return t - ut2._0;
  if (t >= ut2.A && t <= ut2.F) return t - (ut2.A - 10);
  if (t >= ut2.a && t <= ut2.f) return t - (ut2.a - 10);
}
function Vt2(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  const e = t.length, n2 = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r2 = new Uint8Array(n2);
  for (let o2 = 0, i3 = 0; o2 < n2; o2++, i3 += 2) {
    const s = Cr2(t.charCodeAt(i3)), c3 = Cr2(t.charCodeAt(i3 + 1));
    if (s === void 0 || c3 === void 0) {
      const a2 = t[i3] + t[i3 + 1];
      throw new Error('hex string expected, got non-hex character "' + a2 + '" at index ' + i3);
    }
    r2[o2] = s * 16 + c3;
  }
  return r2;
}
function Ot2(t) {
  return We2(Pt2(t));
}
function ee(t) {
  return te2(t), We2(Pt2(Uint8Array.from(t).reverse()));
}
function Mt2(t, e) {
  return Vt2(t.toString(16).padStart(e * 2, "0"));
}
function be2(t, e) {
  return Mt2(t, e).reverse();
}
function Ys(t) {
  return Vt2(kt2(t));
}
function et(t, e, n2) {
  let r2;
  if (typeof e == "string") try {
    r2 = Vt2(e);
  } catch (i3) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + i3);
  }
  else if (St2(e)) r2 = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o2 = r2.length;
  if (typeof n2 == "number" && o2 !== n2) throw new Error(t + " of length " + n2 + " expected, got " + o2);
  return r2;
}
function ne(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o2 = t[r2];
    te2(o2), e += o2.length;
  }
  const n2 = new Uint8Array(e);
  for (let r2 = 0, o2 = 0; r2 < t.length; r2++) {
    const i3 = t[r2];
    n2.set(i3, o2), o2 += i3.length;
  }
  return n2;
}
function Gs(t, e) {
  if (t.length !== e.length) return false;
  let n2 = 0;
  for (let r2 = 0; r2 < t.length; r2++) n2 |= t[r2] ^ e[r2];
  return n2 === 0;
}
function Ws(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
var Xe2 = (t) => typeof t == "bigint" && me2 <= t;
function Ee2(t, e, n2) {
  return Xe2(t) && Xe2(e) && Xe2(n2) && e <= t && t < n2;
}
function ft2(t, e, n2, r2) {
  if (!Ee2(e, n2, r2)) throw new Error("expected valid " + t + ": " + n2 + " <= n < " + r2 + ", got " + e);
}
function Pr2(t) {
  let e;
  for (e = 0; t > me2; t >>= we2, e += 1) ;
  return e;
}
function Xs(t, e) {
  return t >> BigInt(e) & we2;
}
function Js(t, e, n2) {
  return t | (n2 ? we2 : me2) << BigInt(e);
}
var Je2 = (t) => (zs << BigInt(t - 1)) - we2;
var Qe2 = (t) => new Uint8Array(t);
var kr2 = (t) => Uint8Array.from(t);
function Vr2(t, e, n2) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof n2 != "function") throw new Error("hmacFn must be a function");
  let r2 = Qe2(t), o2 = Qe2(t), i3 = 0;
  const s = () => {
    r2.fill(1), o2.fill(0), i3 = 0;
  }, c3 = (...f7) => n2(o2, r2, ...f7), a2 = (f7 = Qe2()) => {
    o2 = c3(kr2([0]), f7), r2 = c3(), f7.length !== 0 && (o2 = c3(kr2([1]), f7), r2 = c3());
  }, u3 = () => {
    if (i3++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let f7 = 0;
    const h5 = [];
    for (; f7 < e; ) {
      r2 = c3();
      const y5 = r2.slice();
      h5.push(y5), f7 += r2.length;
    }
    return ne(...h5);
  };
  return (f7, h5) => {
    s(), a2(f7);
    let y5;
    for (; !(y5 = h5(u3())); ) a2();
    return s(), y5;
  };
}
var Qs = { bigint: (t) => typeof t == "bigint", function: (t) => typeof t == "function", boolean: (t) => typeof t == "boolean", string: (t) => typeof t == "string", stringOrUint8Array: (t) => typeof t == "string" || St2(t), isSafeInteger: (t) => Number.isSafeInteger(t), array: (t) => Array.isArray(t), field: (t, e) => e.Fp.isValid(t), hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen) };
function Dt2(t, e, n2 = {}) {
  const r2 = (o2, i3, s) => {
    const c3 = Qs[i3];
    if (typeof c3 != "function") throw new Error("invalid validator function");
    const a2 = t[o2];
    if (!(s && a2 === void 0) && !c3(a2, t)) throw new Error("param " + String(o2) + " is invalid. Expected " + i3 + ", got " + a2);
  };
  for (const [o2, i3] of Object.entries(e)) r2(o2, i3, false);
  for (const [o2, i3] of Object.entries(n2)) r2(o2, i3, true);
  return t;
}
var tc = () => {
  throw new Error("not implemented");
};
function tn(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n2, ...r2) => {
    const o2 = e.get(n2);
    if (o2 !== void 0) return o2;
    const i3 = t(n2, ...r2);
    return e.set(n2, i3), i3;
  };
}
var ec = Object.freeze({ __proto__: null, isBytes: St2, abytes: te2, abool: Ct, bytesToHex: Pt2, numberToHexUnpadded: kt2, hexToNumber: We2, hexToBytes: Vt2, bytesToNumberBE: Ot2, bytesToNumberLE: ee, numberToBytesBE: Mt2, numberToBytesLE: be2, numberToVarBytesBE: Ys, ensureBytes: et, concatBytes: ne, equalBytes: Gs, utf8ToBytes: Ws, inRange: Ee2, aInRange: ft2, bitLen: Pr2, bitGet: Xs, bitSet: Js, bitMask: Je2, createHmacDrbg: Vr2, validateObject: Dt2, notImplemented: tc, memoized: tn });
var q = BigInt(0);
var H2 = BigInt(1);
var At = BigInt(2);
var nc = BigInt(3);
var en2 = BigInt(4);
var Mr2 = BigInt(5);
var Dr2 = BigInt(8);
function X(t, e) {
  const n2 = t % e;
  return n2 >= q ? n2 : e + n2;
}
function Hr2(t, e, n2) {
  if (e < q) throw new Error("invalid exponent, negatives unsupported");
  if (n2 <= q) throw new Error("invalid modulus");
  if (n2 === H2) return q;
  let r2 = H2;
  for (; e > q; ) e & H2 && (r2 = r2 * t % n2), t = t * t % n2, e >>= H2;
  return r2;
}
function it2(t, e, n2) {
  let r2 = t;
  for (; e-- > q; ) r2 *= r2, r2 %= n2;
  return r2;
}
function nn2(t, e) {
  if (t === q) throw new Error("invert: expected non-zero number");
  if (e <= q) throw new Error("invert: expected positive modulus, got " + e);
  let n2 = X(t, e), r2 = e, o2 = q, i3 = H2;
  for (; n2 !== q; ) {
    const c3 = r2 / n2, a2 = r2 % n2, u3 = o2 - i3 * c3;
    r2 = n2, n2 = a2, o2 = i3, i3 = u3;
  }
  if (r2 !== H2) throw new Error("invert: does not exist");
  return X(o2, e);
}
function rc(t) {
  const e = (t - H2) / At;
  let n2, r2, o2;
  for (n2 = t - H2, r2 = 0; n2 % At === q; n2 /= At, r2++) ;
  for (o2 = At; o2 < t && Hr2(o2, e, t) !== t - H2; o2++) if (o2 > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r2 === 1) {
    const s = (t + H2) / en2;
    return function(a2, u3) {
      const l4 = a2.pow(u3, s);
      if (!a2.eql(a2.sqr(l4), u3)) throw new Error("Cannot find square root");
      return l4;
    };
  }
  const i3 = (n2 + H2) / At;
  return function(c3, a2) {
    if (c3.pow(a2, e) === c3.neg(c3.ONE)) throw new Error("Cannot find square root");
    let u3 = r2, l4 = c3.pow(c3.mul(c3.ONE, o2), n2), f7 = c3.pow(a2, i3), h5 = c3.pow(a2, n2);
    for (; !c3.eql(h5, c3.ONE); ) {
      if (c3.eql(h5, c3.ZERO)) return c3.ZERO;
      let y5 = 1;
      for (let p3 = c3.sqr(h5); y5 < u3 && !c3.eql(p3, c3.ONE); y5++) p3 = c3.sqr(p3);
      const E5 = c3.pow(l4, H2 << BigInt(u3 - y5 - 1));
      l4 = c3.sqr(E5), f7 = c3.mul(f7, E5), h5 = c3.mul(h5, l4), u3 = y5;
    }
    return f7;
  };
}
function oc(t) {
  if (t % en2 === nc) {
    const e = (t + H2) / en2;
    return function(r2, o2) {
      const i3 = r2.pow(o2, e);
      if (!r2.eql(r2.sqr(i3), o2)) throw new Error("Cannot find square root");
      return i3;
    };
  }
  if (t % Dr2 === Mr2) {
    const e = (t - Mr2) / Dr2;
    return function(r2, o2) {
      const i3 = r2.mul(o2, At), s = r2.pow(i3, e), c3 = r2.mul(o2, s), a2 = r2.mul(r2.mul(c3, At), s), u3 = r2.mul(c3, r2.sub(a2, r2.ONE));
      if (!r2.eql(r2.sqr(u3), o2)) throw new Error("Cannot find square root");
      return u3;
    };
  }
  return rc(t);
}
var ic = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function sc(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, n2 = ic.reduce((r2, o2) => (r2[o2] = "function", r2), e);
  return Dt2(t, n2);
}
function cc(t, e, n2) {
  if (n2 < q) throw new Error("invalid exponent, negatives unsupported");
  if (n2 === q) return t.ONE;
  if (n2 === H2) return e;
  let r2 = t.ONE, o2 = e;
  for (; n2 > q; ) n2 & H2 && (r2 = t.mul(r2, o2)), o2 = t.sqr(o2), n2 >>= H2;
  return r2;
}
function ac(t, e) {
  const n2 = new Array(e.length), r2 = e.reduce((i3, s, c3) => t.is0(s) ? i3 : (n2[c3] = i3, t.mul(i3, s)), t.ONE), o2 = t.inv(r2);
  return e.reduceRight((i3, s, c3) => t.is0(s) ? i3 : (n2[c3] = t.mul(i3, n2[c3]), t.mul(i3, s)), o2), n2;
}
function qr2(t, e) {
  const n2 = e !== void 0 ? e : t.toString(2).length, r2 = Math.ceil(n2 / 8);
  return { nBitLength: n2, nByteLength: r2 };
}
function Kr4(t, e, n2 = false, r2 = {}) {
  if (t <= q) throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: o2, nByteLength: i3 } = qr2(t, e);
  if (i3 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let s;
  const c3 = Object.freeze({ ORDER: t, isLE: n2, BITS: o2, BYTES: i3, MASK: Je2(o2), ZERO: q, ONE: H2, create: (a2) => X(a2, t), isValid: (a2) => {
    if (typeof a2 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof a2);
    return q <= a2 && a2 < t;
  }, is0: (a2) => a2 === q, isOdd: (a2) => (a2 & H2) === H2, neg: (a2) => X(-a2, t), eql: (a2, u3) => a2 === u3, sqr: (a2) => X(a2 * a2, t), add: (a2, u3) => X(a2 + u3, t), sub: (a2, u3) => X(a2 - u3, t), mul: (a2, u3) => X(a2 * u3, t), pow: (a2, u3) => cc(c3, a2, u3), div: (a2, u3) => X(a2 * nn2(u3, t), t), sqrN: (a2) => a2 * a2, addN: (a2, u3) => a2 + u3, subN: (a2, u3) => a2 - u3, mulN: (a2, u3) => a2 * u3, inv: (a2) => nn2(a2, t), sqrt: r2.sqrt || ((a2) => (s || (s = oc(t)), s(c3, a2))), invertBatch: (a2) => ac(c3, a2), cmov: (a2, u3, l4) => l4 ? u3 : a2, toBytes: (a2) => n2 ? be2(a2, i3) : Mt2(a2, i3), fromBytes: (a2) => {
    if (a2.length !== i3) throw new Error("Field.fromBytes: expected " + i3 + " bytes, got " + a2.length);
    return n2 ? ee(a2) : Ot2(a2);
  } });
  return Object.freeze(c3);
}
function Fr2(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function zr2(t) {
  const e = Fr2(t);
  return e + Math.ceil(e / 2);
}
function uc(t, e, n2 = false) {
  const r2 = t.length, o2 = Fr2(e), i3 = zr2(e);
  if (r2 < 16 || r2 < i3 || r2 > 1024) throw new Error("expected " + i3 + "-1024 bytes of input, got " + r2);
  const s = n2 ? ee(t) : Ot2(t), c3 = X(s, e - H2) + H2;
  return n2 ? be2(c3, o2) : Mt2(c3, o2);
}
var Zr2 = BigInt(0);
var ve2 = BigInt(1);
function rn2(t, e) {
  const n2 = e.negate();
  return t ? n2 : e;
}
function Yr2(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function on2(t, e) {
  Yr2(t, e);
  const n2 = Math.ceil(e / t) + 1, r2 = 2 ** (t - 1);
  return { windows: n2, windowSize: r2 };
}
function fc(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n2, r2) => {
    if (!(n2 instanceof e)) throw new Error("invalid point at index " + r2);
  });
}
function lc(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n2, r2) => {
    if (!e.isValid(n2)) throw new Error("invalid scalar at index " + r2);
  });
}
var sn2 = /* @__PURE__ */ new WeakMap();
var Gr2 = /* @__PURE__ */ new WeakMap();
function cn(t) {
  return Gr2.get(t) || 1;
}
function dc(t, e) {
  return { constTimeNegate: rn2, hasPrecomputes(n2) {
    return cn(n2) !== 1;
  }, unsafeLadder(n2, r2, o2 = t.ZERO) {
    let i3 = n2;
    for (; r2 > Zr2; ) r2 & ve2 && (o2 = o2.add(i3)), i3 = i3.double(), r2 >>= ve2;
    return o2;
  }, precomputeWindow(n2, r2) {
    const { windows: o2, windowSize: i3 } = on2(r2, e), s = [];
    let c3 = n2, a2 = c3;
    for (let u3 = 0; u3 < o2; u3++) {
      a2 = c3, s.push(a2);
      for (let l4 = 1; l4 < i3; l4++) a2 = a2.add(c3), s.push(a2);
      c3 = a2.double();
    }
    return s;
  }, wNAF(n2, r2, o2) {
    const { windows: i3, windowSize: s } = on2(n2, e);
    let c3 = t.ZERO, a2 = t.BASE;
    const u3 = BigInt(2 ** n2 - 1), l4 = 2 ** n2, f7 = BigInt(n2);
    for (let h5 = 0; h5 < i3; h5++) {
      const y5 = h5 * s;
      let E5 = Number(o2 & u3);
      o2 >>= f7, E5 > s && (E5 -= l4, o2 += ve2);
      const p3 = y5, d4 = y5 + Math.abs(E5) - 1, v5 = h5 % 2 !== 0, m2 = E5 < 0;
      E5 === 0 ? a2 = a2.add(rn2(v5, r2[p3])) : c3 = c3.add(rn2(m2, r2[d4]));
    }
    return { p: c3, f: a2 };
  }, wNAFUnsafe(n2, r2, o2, i3 = t.ZERO) {
    const { windows: s, windowSize: c3 } = on2(n2, e), a2 = BigInt(2 ** n2 - 1), u3 = 2 ** n2, l4 = BigInt(n2);
    for (let f7 = 0; f7 < s; f7++) {
      const h5 = f7 * c3;
      if (o2 === Zr2) break;
      let y5 = Number(o2 & a2);
      if (o2 >>= l4, y5 > c3 && (y5 -= u3, o2 += ve2), y5 === 0) continue;
      let E5 = r2[h5 + Math.abs(y5) - 1];
      y5 < 0 && (E5 = E5.negate()), i3 = i3.add(E5);
    }
    return i3;
  }, getPrecomputes(n2, r2, o2) {
    let i3 = sn2.get(r2);
    return i3 || (i3 = this.precomputeWindow(r2, n2), n2 !== 1 && sn2.set(r2, o2(i3))), i3;
  }, wNAFCached(n2, r2, o2) {
    const i3 = cn(n2);
    return this.wNAF(i3, this.getPrecomputes(i3, n2, o2), r2);
  }, wNAFCachedUnsafe(n2, r2, o2, i3) {
    const s = cn(n2);
    return s === 1 ? this.unsafeLadder(n2, r2, i3) : this.wNAFUnsafe(s, this.getPrecomputes(s, n2, o2), r2, i3);
  }, setWindowSize(n2, r2) {
    Yr2(r2, e), Gr2.set(n2, r2), sn2.delete(n2);
  } };
}
function hc(t, e, n2, r2) {
  if (fc(n2, t), lc(r2, e), n2.length !== r2.length) throw new Error("arrays of points and scalars must have equal length");
  const o2 = t.ZERO, i3 = Pr2(BigInt(n2.length)), s = i3 > 12 ? i3 - 3 : i3 > 4 ? i3 - 2 : i3 ? 2 : 1, c3 = (1 << s) - 1, a2 = new Array(c3 + 1).fill(o2), u3 = Math.floor((e.BITS - 1) / s) * s;
  let l4 = o2;
  for (let f7 = u3; f7 >= 0; f7 -= s) {
    a2.fill(o2);
    for (let y5 = 0; y5 < r2.length; y5++) {
      const E5 = r2[y5], p3 = Number(E5 >> BigInt(f7) & BigInt(c3));
      a2[p3] = a2[p3].add(n2[y5]);
    }
    let h5 = o2;
    for (let y5 = a2.length - 1, E5 = o2; y5 > 0; y5--) E5 = E5.add(a2[y5]), h5 = h5.add(E5);
    if (l4 = l4.add(h5), f7 !== 0) for (let y5 = 0; y5 < s; y5++) l4 = l4.double();
  }
  return l4;
}
function Wr2(t) {
  return sc(t.Fp), Dt2(t, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...qr2(t.n, t.nBitLength), ...t, p: t.Fp.ORDER });
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var Ht2 = BigInt(0);
var an = BigInt(1);
function pc(t) {
  return Dt2(t, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...t });
}
function gc(t) {
  const e = pc(t), { P: n2 } = e, r2 = (m2) => X(m2, n2), o2 = e.montgomeryBits, i3 = Math.ceil(o2 / 8), s = e.nByteLength, c3 = e.adjustScalarBytes || ((m2) => m2), a2 = e.powPminus2 || ((m2) => Hr2(m2, n2 - BigInt(2), n2));
  function u3(m2, O4, N4) {
    const $4 = r2(m2 * (O4 - N4));
    return O4 = r2(O4 - $4), N4 = r2(N4 + $4), [O4, N4];
  }
  const l4 = (e.a - BigInt(2)) / BigInt(4);
  function f7(m2, O4) {
    ft2("u", m2, Ht2, n2), ft2("scalar", O4, Ht2, n2);
    const N4 = O4, $4 = m2;
    let B3 = an, A4 = Ht2, T2 = m2, S4 = an, L3 = Ht2, U4;
    for (let j3 = BigInt(o2 - 1); j3 >= Ht2; j3--) {
      const g2 = N4 >> j3 & an;
      L3 ^= g2, U4 = u3(L3, B3, T2), B3 = U4[0], T2 = U4[1], U4 = u3(L3, A4, S4), A4 = U4[0], S4 = U4[1], L3 = g2;
      const w3 = B3 + A4, b5 = r2(w3 * w3), I3 = B3 - A4, R4 = r2(I3 * I3), x3 = b5 - R4, C5 = T2 + S4, P4 = T2 - S4, k6 = r2(P4 * w3), M5 = r2(C5 * I3), D2 = k6 + M5, z2 = k6 - M5;
      T2 = r2(D2 * D2), S4 = r2($4 * r2(z2 * z2)), B3 = r2(b5 * R4), A4 = r2(x3 * (b5 + r2(l4 * x3)));
    }
    U4 = u3(L3, B3, T2), B3 = U4[0], T2 = U4[1], U4 = u3(L3, A4, S4), A4 = U4[0], S4 = U4[1];
    const _ = a2(A4);
    return r2(B3 * _);
  }
  function h5(m2) {
    return be2(r2(m2), i3);
  }
  function y5(m2) {
    const O4 = et("u coordinate", m2, i3);
    return s === 32 && (O4[31] &= 127), ee(O4);
  }
  function E5(m2) {
    const O4 = et("scalar", m2), N4 = O4.length;
    if (N4 !== i3 && N4 !== s) {
      let $4 = "" + i3 + " or " + s;
      throw new Error("invalid scalar, expected " + $4 + " bytes, got " + N4);
    }
    return ee(c3(O4));
  }
  function p3(m2, O4) {
    const N4 = y5(O4), $4 = E5(m2), B3 = f7(N4, $4);
    if (B3 === Ht2) throw new Error("invalid private or public key received");
    return h5(B3);
  }
  const d4 = h5(e.Gu);
  function v5(m2) {
    return p3(m2, d4);
  }
  return { scalarMult: p3, scalarMultBase: v5, getSharedSecret: (m2, O4) => p3(m2, O4), getPublicKey: (m2) => v5(m2), utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) }, GuBytes: d4 };
}
var un = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
var yc = BigInt(1);
var Xr2 = BigInt(2);
var mc = BigInt(3);
var wc = BigInt(5);
BigInt(8);
function bc(t) {
  const e = BigInt(10), n2 = BigInt(20), r2 = BigInt(40), o2 = BigInt(80), i3 = un, c3 = t * t % i3 * t % i3, a2 = it2(c3, Xr2, i3) * c3 % i3, u3 = it2(a2, yc, i3) * t % i3, l4 = it2(u3, wc, i3) * u3 % i3, f7 = it2(l4, e, i3) * l4 % i3, h5 = it2(f7, n2, i3) * f7 % i3, y5 = it2(h5, r2, i3) * h5 % i3, E5 = it2(y5, o2, i3) * y5 % i3, p3 = it2(E5, o2, i3) * y5 % i3, d4 = it2(p3, e, i3) * l4 % i3;
  return { pow_p_5_8: it2(d4, Xr2, i3) * t % i3, b2: c3 };
}
function Ec(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var fn = gc({ P: un, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (t) => {
  const e = un, { pow_p_5_8: n2, b2: r2 } = bc(t);
  return X(it2(n2, mc, e) * r2, e);
}, adjustScalarBytes: Ec, randomBytes: Lt2 });
function Jr2(t) {
  t.lowS !== void 0 && Ct("lowS", t.lowS), t.prehash !== void 0 && Ct("prehash", t.prehash);
}
function vc(t) {
  const e = Wr2(t);
  Dt2(e, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
  const { endo: n2, Fp: r2, a: o2 } = e;
  if (n2) {
    if (!r2.eql(o2, r2.ZERO)) throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    if (typeof n2 != "object" || typeof n2.beta != "bigint" || typeof n2.splitScalar != "function") throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
var { bytesToNumberBE: xc, hexToBytes: Sc } = ec;
var Oc = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var lt2 = { Err: Oc, _tlv: { encode: (t, e) => {
  const { Err: n2 } = lt2;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length & 1) throw new n2("tlv.encode: unpadded data");
  const r2 = e.length / 2, o2 = kt2(r2);
  if (o2.length / 2 & 128) throw new n2("tlv.encode: long form length too big");
  const i3 = r2 > 127 ? kt2(o2.length / 2 | 128) : "";
  return kt2(t) + i3 + o2 + e;
}, decode(t, e) {
  const { Err: n2 } = lt2;
  let r2 = 0;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length < 2 || e[r2++] !== t) throw new n2("tlv.decode: wrong tlv");
  const o2 = e[r2++], i3 = !!(o2 & 128);
  let s = 0;
  if (!i3) s = o2;
  else {
    const a2 = o2 & 127;
    if (!a2) throw new n2("tlv.decode(long): indefinite length not supported");
    if (a2 > 4) throw new n2("tlv.decode(long): byte length is too big");
    const u3 = e.subarray(r2, r2 + a2);
    if (u3.length !== a2) throw new n2("tlv.decode: length bytes not complete");
    if (u3[0] === 0) throw new n2("tlv.decode(long): zero leftmost byte");
    for (const l4 of u3) s = s << 8 | l4;
    if (r2 += a2, s < 128) throw new n2("tlv.decode(long): not minimal encoding");
  }
  const c3 = e.subarray(r2, r2 + s);
  if (c3.length !== s) throw new n2("tlv.decode: wrong value length");
  return { v: c3, l: e.subarray(r2 + s) };
} }, _int: { encode(t) {
  const { Err: e } = lt2;
  if (t < dt2) throw new e("integer: negative integers are not allowed");
  let n2 = kt2(t);
  if (Number.parseInt(n2[0], 16) & 8 && (n2 = "00" + n2), n2.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return n2;
}, decode(t) {
  const { Err: e } = lt2;
  if (t[0] & 128) throw new e("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return xc(t);
} }, toSig(t) {
  const { Err: e, _int: n2, _tlv: r2 } = lt2, o2 = typeof t == "string" ? Sc(t) : t;
  te2(o2);
  const { v: i3, l: s } = r2.decode(48, o2);
  if (s.length) throw new e("invalid signature: left bytes after parsing");
  const { v: c3, l: a2 } = r2.decode(2, i3), { v: u3, l: l4 } = r2.decode(2, a2);
  if (l4.length) throw new e("invalid signature: left bytes after parsing");
  return { r: n2.decode(c3), s: n2.decode(u3) };
}, hexFromSig(t) {
  const { _tlv: e, _int: n2 } = lt2, r2 = e.encode(2, n2.encode(t.r)), o2 = e.encode(2, n2.encode(t.s)), i3 = r2 + o2;
  return e.encode(48, i3);
} };
var dt2 = BigInt(0);
var K2 = BigInt(1);
BigInt(2);
var Qr2 = BigInt(3);
BigInt(4);
function Ac(t) {
  const e = vc(t), { Fp: n2 } = e, r2 = Kr4(e.n, e.nBitLength), o2 = e.toBytes || ((p3, d4, v5) => {
    const m2 = d4.toAffine();
    return ne(Uint8Array.from([4]), n2.toBytes(m2.x), n2.toBytes(m2.y));
  }), i3 = e.fromBytes || ((p3) => {
    const d4 = p3.subarray(1), v5 = n2.fromBytes(d4.subarray(0, n2.BYTES)), m2 = n2.fromBytes(d4.subarray(n2.BYTES, 2 * n2.BYTES));
    return { x: v5, y: m2 };
  });
  function s(p3) {
    const { a: d4, b: v5 } = e, m2 = n2.sqr(p3), O4 = n2.mul(m2, p3);
    return n2.add(n2.add(O4, n2.mul(p3, d4)), v5);
  }
  if (!n2.eql(n2.sqr(e.Gy), s(e.Gx))) throw new Error("bad generator point: equation left != right");
  function c3(p3) {
    return Ee2(p3, K2, e.n);
  }
  function a2(p3) {
    const { allowedPrivateKeyLengths: d4, nByteLength: v5, wrapPrivateKey: m2, n: O4 } = e;
    if (d4 && typeof p3 != "bigint") {
      if (St2(p3) && (p3 = Pt2(p3)), typeof p3 != "string" || !d4.includes(p3.length)) throw new Error("invalid private key");
      p3 = p3.padStart(v5 * 2, "0");
    }
    let N4;
    try {
      N4 = typeof p3 == "bigint" ? p3 : Ot2(et("private key", p3, v5));
    } catch {
      throw new Error("invalid private key, expected hex or " + v5 + " bytes, got " + typeof p3);
    }
    return m2 && (N4 = X(N4, O4)), ft2("private key", N4, K2, O4), N4;
  }
  function u3(p3) {
    if (!(p3 instanceof h5)) throw new Error("ProjectivePoint expected");
  }
  const l4 = tn((p3, d4) => {
    const { px: v5, py: m2, pz: O4 } = p3;
    if (n2.eql(O4, n2.ONE)) return { x: v5, y: m2 };
    const N4 = p3.is0();
    d4 == null && (d4 = N4 ? n2.ONE : n2.inv(O4));
    const $4 = n2.mul(v5, d4), B3 = n2.mul(m2, d4), A4 = n2.mul(O4, d4);
    if (N4) return { x: n2.ZERO, y: n2.ZERO };
    if (!n2.eql(A4, n2.ONE)) throw new Error("invZ was invalid");
    return { x: $4, y: B3 };
  }), f7 = tn((p3) => {
    if (p3.is0()) {
      if (e.allowInfinityPoint && !n2.is0(p3.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d4, y: v5 } = p3.toAffine();
    if (!n2.isValid(d4) || !n2.isValid(v5)) throw new Error("bad point: x or y not FE");
    const m2 = n2.sqr(v5), O4 = s(d4);
    if (!n2.eql(m2, O4)) throw new Error("bad point: equation left != right");
    if (!p3.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class h5 {
    constructor(d4, v5, m2) {
      if (this.px = d4, this.py = v5, this.pz = m2, d4 == null || !n2.isValid(d4)) throw new Error("x required");
      if (v5 == null || !n2.isValid(v5)) throw new Error("y required");
      if (m2 == null || !n2.isValid(m2)) throw new Error("z required");
      Object.freeze(this);
    }
    static fromAffine(d4) {
      const { x: v5, y: m2 } = d4 || {};
      if (!d4 || !n2.isValid(v5) || !n2.isValid(m2)) throw new Error("invalid affine point");
      if (d4 instanceof h5) throw new Error("projective point not allowed");
      const O4 = (N4) => n2.eql(N4, n2.ZERO);
      return O4(v5) && O4(m2) ? h5.ZERO : new h5(v5, m2, n2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d4) {
      const v5 = n2.invertBatch(d4.map((m2) => m2.pz));
      return d4.map((m2, O4) => m2.toAffine(v5[O4])).map(h5.fromAffine);
    }
    static fromHex(d4) {
      const v5 = h5.fromAffine(i3(et("pointHex", d4)));
      return v5.assertValidity(), v5;
    }
    static fromPrivateKey(d4) {
      return h5.BASE.multiply(a2(d4));
    }
    static msm(d4, v5) {
      return hc(h5, r2, d4, v5);
    }
    _setWindowSize(d4) {
      E5.setWindowSize(this, d4);
    }
    assertValidity() {
      f7(this);
    }
    hasEvenY() {
      const { y: d4 } = this.toAffine();
      if (n2.isOdd) return !n2.isOdd(d4);
      throw new Error("Field doesn't support isOdd");
    }
    equals(d4) {
      u3(d4);
      const { px: v5, py: m2, pz: O4 } = this, { px: N4, py: $4, pz: B3 } = d4, A4 = n2.eql(n2.mul(v5, B3), n2.mul(N4, O4)), T2 = n2.eql(n2.mul(m2, B3), n2.mul($4, O4));
      return A4 && T2;
    }
    negate() {
      return new h5(this.px, n2.neg(this.py), this.pz);
    }
    double() {
      const { a: d4, b: v5 } = e, m2 = n2.mul(v5, Qr2), { px: O4, py: N4, pz: $4 } = this;
      let B3 = n2.ZERO, A4 = n2.ZERO, T2 = n2.ZERO, S4 = n2.mul(O4, O4), L3 = n2.mul(N4, N4), U4 = n2.mul($4, $4), _ = n2.mul(O4, N4);
      return _ = n2.add(_, _), T2 = n2.mul(O4, $4), T2 = n2.add(T2, T2), B3 = n2.mul(d4, T2), A4 = n2.mul(m2, U4), A4 = n2.add(B3, A4), B3 = n2.sub(L3, A4), A4 = n2.add(L3, A4), A4 = n2.mul(B3, A4), B3 = n2.mul(_, B3), T2 = n2.mul(m2, T2), U4 = n2.mul(d4, U4), _ = n2.sub(S4, U4), _ = n2.mul(d4, _), _ = n2.add(_, T2), T2 = n2.add(S4, S4), S4 = n2.add(T2, S4), S4 = n2.add(S4, U4), S4 = n2.mul(S4, _), A4 = n2.add(A4, S4), U4 = n2.mul(N4, $4), U4 = n2.add(U4, U4), S4 = n2.mul(U4, _), B3 = n2.sub(B3, S4), T2 = n2.mul(U4, L3), T2 = n2.add(T2, T2), T2 = n2.add(T2, T2), new h5(B3, A4, T2);
    }
    add(d4) {
      u3(d4);
      const { px: v5, py: m2, pz: O4 } = this, { px: N4, py: $4, pz: B3 } = d4;
      let A4 = n2.ZERO, T2 = n2.ZERO, S4 = n2.ZERO;
      const L3 = e.a, U4 = n2.mul(e.b, Qr2);
      let _ = n2.mul(v5, N4), j3 = n2.mul(m2, $4), g2 = n2.mul(O4, B3), w3 = n2.add(v5, m2), b5 = n2.add(N4, $4);
      w3 = n2.mul(w3, b5), b5 = n2.add(_, j3), w3 = n2.sub(w3, b5), b5 = n2.add(v5, O4);
      let I3 = n2.add(N4, B3);
      return b5 = n2.mul(b5, I3), I3 = n2.add(_, g2), b5 = n2.sub(b5, I3), I3 = n2.add(m2, O4), A4 = n2.add($4, B3), I3 = n2.mul(I3, A4), A4 = n2.add(j3, g2), I3 = n2.sub(I3, A4), S4 = n2.mul(L3, b5), A4 = n2.mul(U4, g2), S4 = n2.add(A4, S4), A4 = n2.sub(j3, S4), S4 = n2.add(j3, S4), T2 = n2.mul(A4, S4), j3 = n2.add(_, _), j3 = n2.add(j3, _), g2 = n2.mul(L3, g2), b5 = n2.mul(U4, b5), j3 = n2.add(j3, g2), g2 = n2.sub(_, g2), g2 = n2.mul(L3, g2), b5 = n2.add(b5, g2), _ = n2.mul(j3, b5), T2 = n2.add(T2, _), _ = n2.mul(I3, b5), A4 = n2.mul(w3, A4), A4 = n2.sub(A4, _), _ = n2.mul(w3, j3), S4 = n2.mul(I3, S4), S4 = n2.add(S4, _), new h5(A4, T2, S4);
    }
    subtract(d4) {
      return this.add(d4.negate());
    }
    is0() {
      return this.equals(h5.ZERO);
    }
    wNAF(d4) {
      return E5.wNAFCached(this, d4, h5.normalizeZ);
    }
    multiplyUnsafe(d4) {
      const { endo: v5, n: m2 } = e;
      ft2("scalar", d4, dt2, m2);
      const O4 = h5.ZERO;
      if (d4 === dt2) return O4;
      if (this.is0() || d4 === K2) return this;
      if (!v5 || E5.hasPrecomputes(this)) return E5.wNAFCachedUnsafe(this, d4, h5.normalizeZ);
      let { k1neg: N4, k1: $4, k2neg: B3, k2: A4 } = v5.splitScalar(d4), T2 = O4, S4 = O4, L3 = this;
      for (; $4 > dt2 || A4 > dt2; ) $4 & K2 && (T2 = T2.add(L3)), A4 & K2 && (S4 = S4.add(L3)), L3 = L3.double(), $4 >>= K2, A4 >>= K2;
      return N4 && (T2 = T2.negate()), B3 && (S4 = S4.negate()), S4 = new h5(n2.mul(S4.px, v5.beta), S4.py, S4.pz), T2.add(S4);
    }
    multiply(d4) {
      const { endo: v5, n: m2 } = e;
      ft2("scalar", d4, K2, m2);
      let O4, N4;
      if (v5) {
        const { k1neg: $4, k1: B3, k2neg: A4, k2: T2 } = v5.splitScalar(d4);
        let { p: S4, f: L3 } = this.wNAF(B3), { p: U4, f: _ } = this.wNAF(T2);
        S4 = E5.constTimeNegate($4, S4), U4 = E5.constTimeNegate(A4, U4), U4 = new h5(n2.mul(U4.px, v5.beta), U4.py, U4.pz), O4 = S4.add(U4), N4 = L3.add(_);
      } else {
        const { p: $4, f: B3 } = this.wNAF(d4);
        O4 = $4, N4 = B3;
      }
      return h5.normalizeZ([O4, N4])[0];
    }
    multiplyAndAddUnsafe(d4, v5, m2) {
      const O4 = h5.BASE, N4 = (B3, A4) => A4 === dt2 || A4 === K2 || !B3.equals(O4) ? B3.multiplyUnsafe(A4) : B3.multiply(A4), $4 = N4(this, v5).add(N4(d4, m2));
      return $4.is0() ? void 0 : $4;
    }
    toAffine(d4) {
      return l4(this, d4);
    }
    isTorsionFree() {
      const { h: d4, isTorsionFree: v5 } = e;
      if (d4 === K2) return true;
      if (v5) return v5(h5, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: d4, clearCofactor: v5 } = e;
      return d4 === K2 ? this : v5 ? v5(h5, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(d4 = true) {
      return Ct("isCompressed", d4), this.assertValidity(), o2(h5, this, d4);
    }
    toHex(d4 = true) {
      return Ct("isCompressed", d4), Pt2(this.toRawBytes(d4));
    }
  }
  h5.BASE = new h5(e.Gx, e.Gy, n2.ONE), h5.ZERO = new h5(n2.ZERO, n2.ONE, n2.ZERO);
  const y5 = e.nBitLength, E5 = dc(h5, e.endo ? Math.ceil(y5 / 2) : y5);
  return { CURVE: e, ProjectivePoint: h5, normPrivateKeyToScalar: a2, weierstrassEquation: s, isWithinCurveOrder: c3 };
}
function Bc(t) {
  const e = Wr2(t);
  return Dt2(e, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: true, ...e });
}
function Ic(t) {
  const e = Bc(t), { Fp: n2, n: r2 } = e, o2 = n2.BYTES + 1, i3 = 2 * n2.BYTES + 1;
  function s(g2) {
    return X(g2, r2);
  }
  function c3(g2) {
    return nn2(g2, r2);
  }
  const { ProjectivePoint: a2, normPrivateKeyToScalar: u3, weierstrassEquation: l4, isWithinCurveOrder: f7 } = Ac({ ...e, toBytes(g2, w3, b5) {
    const I3 = w3.toAffine(), R4 = n2.toBytes(I3.x), x3 = ne;
    return Ct("isCompressed", b5), b5 ? x3(Uint8Array.from([w3.hasEvenY() ? 2 : 3]), R4) : x3(Uint8Array.from([4]), R4, n2.toBytes(I3.y));
  }, fromBytes(g2) {
    const w3 = g2.length, b5 = g2[0], I3 = g2.subarray(1);
    if (w3 === o2 && (b5 === 2 || b5 === 3)) {
      const R4 = Ot2(I3);
      if (!Ee2(R4, K2, n2.ORDER)) throw new Error("Point is not on curve");
      const x3 = l4(R4);
      let C5;
      try {
        C5 = n2.sqrt(x3);
      } catch (M5) {
        const D2 = M5 instanceof Error ? ": " + M5.message : "";
        throw new Error("Point is not on curve" + D2);
      }
      const P4 = (C5 & K2) === K2;
      return (b5 & 1) === 1 !== P4 && (C5 = n2.neg(C5)), { x: R4, y: C5 };
    } else if (w3 === i3 && b5 === 4) {
      const R4 = n2.fromBytes(I3.subarray(0, n2.BYTES)), x3 = n2.fromBytes(I3.subarray(n2.BYTES, 2 * n2.BYTES));
      return { x: R4, y: x3 };
    } else {
      const R4 = o2, x3 = i3;
      throw new Error("invalid Point, expected length of " + R4 + ", or uncompressed " + x3 + ", got " + w3);
    }
  } }), h5 = (g2) => Pt2(Mt2(g2, e.nByteLength));
  function y5(g2) {
    const w3 = r2 >> K2;
    return g2 > w3;
  }
  function E5(g2) {
    return y5(g2) ? s(-g2) : g2;
  }
  const p3 = (g2, w3, b5) => Ot2(g2.slice(w3, b5));
  class d4 {
    constructor(w3, b5, I3) {
      this.r = w3, this.s = b5, this.recovery = I3, this.assertValidity();
    }
    static fromCompact(w3) {
      const b5 = e.nByteLength;
      return w3 = et("compactSignature", w3, b5 * 2), new d4(p3(w3, 0, b5), p3(w3, b5, 2 * b5));
    }
    static fromDER(w3) {
      const { r: b5, s: I3 } = lt2.toSig(et("DER", w3));
      return new d4(b5, I3);
    }
    assertValidity() {
      ft2("r", this.r, K2, r2), ft2("s", this.s, K2, r2);
    }
    addRecoveryBit(w3) {
      return new d4(this.r, this.s, w3);
    }
    recoverPublicKey(w3) {
      const { r: b5, s: I3, recovery: R4 } = this, x3 = B3(et("msgHash", w3));
      if (R4 == null || ![0, 1, 2, 3].includes(R4)) throw new Error("recovery id invalid");
      const C5 = R4 === 2 || R4 === 3 ? b5 + e.n : b5;
      if (C5 >= n2.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const P4 = (R4 & 1) === 0 ? "02" : "03", k6 = a2.fromHex(P4 + h5(C5)), M5 = c3(C5), D2 = s(-x3 * M5), z2 = s(I3 * M5), Z2 = a2.BASE.multiplyAndAddUnsafe(k6, D2, z2);
      if (!Z2) throw new Error("point at infinify");
      return Z2.assertValidity(), Z2;
    }
    hasHighS() {
      return y5(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new d4(this.r, s(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return Vt2(this.toDERHex());
    }
    toDERHex() {
      return lt2.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return Vt2(this.toCompactHex());
    }
    toCompactHex() {
      return h5(this.r) + h5(this.s);
    }
  }
  const v5 = { isValidPrivateKey(g2) {
    try {
      return u3(g2), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: u3, randomPrivateKey: () => {
    const g2 = zr2(e.n);
    return uc(e.randomBytes(g2), e.n);
  }, precompute(g2 = 8, w3 = a2.BASE) {
    return w3._setWindowSize(g2), w3.multiply(BigInt(3)), w3;
  } };
  function m2(g2, w3 = true) {
    return a2.fromPrivateKey(g2).toRawBytes(w3);
  }
  function O4(g2) {
    const w3 = St2(g2), b5 = typeof g2 == "string", I3 = (w3 || b5) && g2.length;
    return w3 ? I3 === o2 || I3 === i3 : b5 ? I3 === 2 * o2 || I3 === 2 * i3 : g2 instanceof a2;
  }
  function N4(g2, w3, b5 = true) {
    if (O4(g2)) throw new Error("first arg must be private key");
    if (!O4(w3)) throw new Error("second arg must be public key");
    return a2.fromHex(w3).multiply(u3(g2)).toRawBytes(b5);
  }
  const $4 = e.bits2int || function(g2) {
    if (g2.length > 8192) throw new Error("input is too large");
    const w3 = Ot2(g2), b5 = g2.length * 8 - e.nBitLength;
    return b5 > 0 ? w3 >> BigInt(b5) : w3;
  }, B3 = e.bits2int_modN || function(g2) {
    return s($4(g2));
  }, A4 = Je2(e.nBitLength);
  function T2(g2) {
    return ft2("num < 2^" + e.nBitLength, g2, dt2, A4), Mt2(g2, e.nByteLength);
  }
  function S4(g2, w3, b5 = L3) {
    if (["recovered", "canonical"].some((W4) => W4 in b5)) throw new Error("sign() legacy options not supported");
    const { hash: I3, randomBytes: R4 } = e;
    let { lowS: x3, prehash: C5, extraEntropy: P4 } = b5;
    x3 == null && (x3 = true), g2 = et("msgHash", g2), Jr2(b5), C5 && (g2 = et("prehashed msgHash", I3(g2)));
    const k6 = B3(g2), M5 = u3(w3), D2 = [T2(M5), T2(k6)];
    if (P4 != null && P4 !== false) {
      const W4 = P4 === true ? R4(n2.BYTES) : P4;
      D2.push(et("extraEntropy", W4));
    }
    const z2 = ne(...D2), Z2 = k6;
    function st2(W4) {
      const J4 = $4(W4);
      if (!f7(J4)) return;
      const Be5 = c3(J4), zt4 = a2.BASE.multiply(J4).toAffine(), vt3 = s(zt4.x);
      if (vt3 === dt2) return;
      const Zt4 = s(Be5 * s(Z2 + vt3 * M5));
      if (Zt4 === dt2) return;
      let Ut4 = (zt4.x === vt3 ? 0 : 2) | Number(zt4.y & K2), vn3 = Zt4;
      return x3 && y5(Zt4) && (vn3 = E5(Zt4), Ut4 ^= 1), new d4(vt3, vn3, Ut4);
    }
    return { seed: z2, k2sig: st2 };
  }
  const L3 = { lowS: e.lowS, prehash: false }, U4 = { lowS: e.lowS, prehash: false };
  function _(g2, w3, b5 = L3) {
    const { seed: I3, k2sig: R4 } = S4(g2, w3, b5), x3 = e;
    return Vr2(x3.hash.outputLen, x3.nByteLength, x3.hmac)(I3, R4);
  }
  a2.BASE._setWindowSize(8);
  function j3(g2, w3, b5, I3 = U4) {
    const R4 = g2;
    w3 = et("msgHash", w3), b5 = et("publicKey", b5);
    const { lowS: x3, prehash: C5, format: P4 } = I3;
    if (Jr2(I3), "strict" in I3) throw new Error("options.strict was renamed to lowS");
    if (P4 !== void 0 && P4 !== "compact" && P4 !== "der") throw new Error("format must be compact or der");
    const k6 = typeof R4 == "string" || St2(R4), M5 = !k6 && !P4 && typeof R4 == "object" && R4 !== null && typeof R4.r == "bigint" && typeof R4.s == "bigint";
    if (!k6 && !M5) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let D2, z2;
    try {
      if (M5 && (D2 = new d4(R4.r, R4.s)), k6) {
        try {
          P4 !== "compact" && (D2 = d4.fromDER(R4));
        } catch (Ut4) {
          if (!(Ut4 instanceof lt2.Err)) throw Ut4;
        }
        !D2 && P4 !== "der" && (D2 = d4.fromCompact(R4));
      }
      z2 = a2.fromHex(b5);
    } catch {
      return false;
    }
    if (!D2 || x3 && D2.hasHighS()) return false;
    C5 && (w3 = e.hash(w3));
    const { r: Z2, s: st2 } = D2, W4 = B3(w3), J4 = c3(st2), Be5 = s(W4 * J4), zt4 = s(Z2 * J4), vt3 = a2.BASE.multiplyAndAddUnsafe(z2, Be5, zt4)?.toAffine();
    return vt3 ? s(vt3.x) === Z2 : false;
  }
  return { CURVE: e, getPublicKey: m2, getSharedSecret: N4, sign: _, verify: j3, ProjectivePoint: a2, Signature: d4, utils: v5 };
}
function Nc(t) {
  return { hash: t, hmac: (e, ...n2) => ye2(t, e, Vi(...n2)), randomBytes: Lt2 };
}
function Uc(t, e) {
  const n2 = (r2) => Ic({ ...t, ...Nc(r2) });
  return { ...n2(e), create: n2 };
}
var to2 = Kr4(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var Tc = to2.create(BigInt("-3"));
var Rc = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var _c = Uc({ a: Tc, b: Rc, Fp: to2, n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"), h: BigInt(1), lowS: false }, Qt2);
var ln = "base10";
var G2 = "base16";
var qt2 = "base64pad";
var xe2 = "base64url";
var Kt2 = "utf8";
var dn = 0;
var Ft2 = 1;
var re = 2;
var $c = 0;
var eo2 = 1;
var oe = 12;
var hn = 32;
function Lc() {
  const t = fn.utils.randomPrivateKey(), e = fn.getPublicKey(t);
  return { privateKey: toString(t, G2), publicKey: toString(e, G2) };
}
function jc() {
  const t = Lt2(hn);
  return toString(t, G2);
}
function Cc(t, e) {
  const n2 = fn.getSharedSecret(fromString(t, G2), fromString(e, G2)), r2 = Vs(Qt2, n2, void 0, void 0, hn);
  return toString(r2, G2);
}
function Pc(t) {
  const e = Qt2(fromString(t, G2));
  return toString(e, G2);
}
function kc(t) {
  const e = Qt2(fromString(t, Kt2));
  return toString(e, G2);
}
function pn(t) {
  return fromString(`${t}`, ln);
}
function Bt2(t) {
  return Number(toString(t, ln));
}
function no2(t) {
  return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function ro2(t) {
  const e = t.replace(/-/g, "+").replace(/_/g, "/"), n2 = (4 - e.length % 4) % 4;
  return e + "=".repeat(n2);
}
function Vc(t) {
  const e = pn(typeof t.type < "u" ? t.type : dn);
  if (Bt2(e) === Ft2 && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n2 = typeof t.senderPublicKey < "u" ? fromString(t.senderPublicKey, G2) : void 0, r2 = typeof t.iv < "u" ? fromString(t.iv, G2) : Lt2(oe), o2 = fromString(t.symKey, G2), i3 = $r2(o2, r2).encrypt(fromString(t.message, Kt2)), s = gn2({ type: e, sealed: i3, iv: r2, senderPublicKey: n2 });
  return t.encoding === xe2 ? no2(s) : s;
}
function Mc(t) {
  const e = fromString(t.symKey, G2), { sealed: n2, iv: r2 } = Se2({ encoded: t.encoded, encoding: t.encoding }), o2 = $r2(e, r2).decrypt(n2);
  if (o2 === null) throw new Error("Failed to decrypt");
  return toString(o2, Kt2);
}
function Dc(t, e) {
  const n2 = pn(re), r2 = Lt2(oe), o2 = fromString(t, Kt2), i3 = gn2({ type: n2, sealed: o2, iv: r2 });
  return e === xe2 ? no2(i3) : i3;
}
function Hc(t, e) {
  const { sealed: n2 } = Se2({ encoded: t, encoding: e });
  return toString(n2, Kt2);
}
function gn2(t) {
  if (Bt2(t.type) === re) return toString(concat([t.type, t.sealed]), qt2);
  if (Bt2(t.type) === Ft2) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([t.type, t.senderPublicKey, t.iv, t.sealed]), qt2);
  }
  return toString(concat([t.type, t.iv, t.sealed]), qt2);
}
function Se2(t) {
  const e = (t.encoding || qt2) === xe2 ? ro2(t.encoded) : t.encoded, n2 = fromString(e, qt2), r2 = n2.slice($c, eo2), o2 = eo2;
  if (Bt2(r2) === Ft2) {
    const a2 = o2 + hn, u3 = a2 + oe, l4 = n2.slice(o2, a2), f7 = n2.slice(a2, u3), h5 = n2.slice(u3);
    return { type: r2, sealed: h5, iv: f7, senderPublicKey: l4 };
  }
  if (Bt2(r2) === re) {
    const a2 = n2.slice(o2), u3 = Lt2(oe);
    return { type: r2, sealed: a2, iv: u3 };
  }
  const i3 = o2 + oe, s = n2.slice(o2, i3), c3 = n2.slice(i3);
  return { type: r2, sealed: c3, iv: s };
}
function qc(t, e) {
  const n2 = Se2({ encoded: t, encoding: e?.encoding });
  return oo2({ type: Bt2(n2.type), senderPublicKey: typeof n2.senderPublicKey < "u" ? toString(n2.senderPublicKey, G2) : void 0, receiverPublicKey: e?.receiverPublicKey });
}
function oo2(t) {
  const e = t?.type || dn;
  if (e === Ft2) {
    if (typeof t?.senderPublicKey > "u") throw new Error("missing sender public key");
    if (typeof t?.receiverPublicKey > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t?.senderPublicKey, receiverPublicKey: t?.receiverPublicKey };
}
function Kc(t) {
  return t.type === Ft2 && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function Fc(t) {
  return t.type === re;
}
function io2(t) {
  const e = Buffer.from(t.x, "base64"), n2 = Buffer.from(t.y, "base64");
  return concat([new Uint8Array([4]), e, n2]);
}
function zc(t, e) {
  const [n2, r2, o2] = t.split("."), i3 = Buffer.from(ro2(o2), "base64");
  if (i3.length !== 64) throw new Error("Invalid signature length");
  const s = i3.slice(0, 32), c3 = i3.slice(32, 64), a2 = `${n2}.${r2}`, u3 = Qt2(a2), l4 = io2(e);
  if (!_c.verify(concat([s, c3]), u3, l4)) throw new Error("Invalid signature");
  return sn(t).payload;
}
var so2 = "irn";
function Zc(t) {
  return t?.relay || { protocol: so2 };
}
function Yc(t) {
  const e = C[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
function co2(t, e = "-") {
  const n2 = {}, r2 = "relay" + e;
  return Object.keys(t).forEach((o2) => {
    if (o2.startsWith(r2)) {
      const i3 = o2.replace(r2, ""), s = t[o2];
      n2[i3] = s;
    }
  }), n2;
}
function Gc(t) {
  if (!t.includes("wc:")) {
    const u3 = je2(t);
    u3 != null && u3.includes("wc:") && (t = u3);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), n2 = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, r2 = t.substring(0, e), o2 = t.substring(e + 1, n2).split("@"), i3 = typeof n2 < "u" ? t.substring(n2) : "", s = new URLSearchParams(i3), c3 = {};
  s.forEach((u3, l4) => {
    c3[l4] = u3;
  });
  const a2 = typeof c3.methods == "string" ? c3.methods.split(",") : void 0;
  return { protocol: r2, topic: ao2(o2[0]), version: parseInt(o2[1], 10), symKey: c3.symKey, relay: co2(c3), methods: a2, expiryTimestamp: c3.expiryTimestamp ? parseInt(c3.expiryTimestamp, 10) : void 0 };
}
function ao2(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function uo2(t, e = "-") {
  const n2 = "relay", r2 = {};
  return Object.keys(t).forEach((o2) => {
    const i3 = o2, s = n2 + e + i3;
    t[i3] && (r2[s] = t[i3]);
  }), r2;
}
function Wc(t) {
  const e = new URLSearchParams(), n2 = uo2(t.relay);
  Object.keys(n2).sort().forEach((o2) => {
    e.set(o2, n2[o2]);
  }), e.set("symKey", t.symKey), t.expiryTimestamp && e.set("expiryTimestamp", t.expiryTimestamp.toString()), t.methods && e.set("methods", t.methods.join(","));
  const r2 = e.toString();
  return `${t.protocol}:${t.topic}@${t.version}?${r2}`;
}
function Xc(t, e, n2) {
  return `${t}?wc_ev=${n2}&topic=${e}`;
}
var Jc = Object.defineProperty;
var Qc = Object.defineProperties;
var ta = Object.getOwnPropertyDescriptors;
var fo2 = Object.getOwnPropertySymbols;
var ea = Object.prototype.hasOwnProperty;
var na = Object.prototype.propertyIsEnumerable;
var lo2 = (t, e, n2) => e in t ? Jc(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var ra = (t, e) => {
  for (var n2 in e || (e = {})) ea.call(e, n2) && lo2(t, n2, e[n2]);
  if (fo2) for (var n2 of fo2(e)) na.call(e, n2) && lo2(t, n2, e[n2]);
  return t;
};
var oa = (t, e) => Qc(t, ta(e));
function It2(t) {
  const e = [];
  return t.forEach((n2) => {
    const [r2, o2] = n2.split(":");
    e.push(`${r2}:${o2}`);
  }), e;
}
function ho2(t) {
  const e = [];
  return Object.values(t).forEach((n2) => {
    e.push(...It2(n2.accounts));
  }), e;
}
function po2(t, e) {
  const n2 = [];
  return Object.values(t).forEach((r2) => {
    It2(r2.accounts).includes(e) && n2.push(...r2.methods);
  }), n2;
}
function go2(t, e) {
  const n2 = [];
  return Object.values(t).forEach((r2) => {
    It2(r2.accounts).includes(e) && n2.push(...r2.events);
  }), n2;
}
function yn2(t) {
  return t.includes(":");
}
function yo2(t) {
  return yn2(t) ? t.split(":")[0] : t;
}
function ie(t) {
  var e, n2, r2;
  const o2 = {};
  if (!Oe2(t)) return o2;
  for (const [i3, s] of Object.entries(t)) {
    const c3 = yn2(i3) ? [i3] : s.chains, a2 = s.methods || [], u3 = s.events || [], l4 = yo2(i3);
    o2[l4] = oa(ra({}, o2[l4]), { chains: ot(c3, (e = o2[l4]) == null ? void 0 : e.chains), methods: ot(a2, (n2 = o2[l4]) == null ? void 0 : n2.methods), events: ot(u3, (r2 = o2[l4]) == null ? void 0 : r2.events) });
  }
  return o2;
}
function mo2(t) {
  const e = {};
  return t?.forEach((n2) => {
    var r2;
    const [o2, i3] = n2.split(":");
    e[o2] || (e[o2] = { accounts: [], chains: [], events: [], methods: [] }), e[o2].accounts.push(n2), (r2 = e[o2].chains) == null || r2.push(`${o2}:${i3}`);
  }), e;
}
function ca(t, e) {
  e = e.map((r2) => r2.replace("did:pkh:", ""));
  const n2 = mo2(e);
  for (const [r2, o2] of Object.entries(n2)) o2.methods ? o2.methods = ot(o2.methods, t) : o2.methods = t, o2.events = ["chainChanged", "accountsChanged"];
  return n2;
}
function aa(t, e) {
  var n2, r2, o2, i3, s, c3;
  const a2 = ie(t), u3 = ie(e), l4 = {}, f7 = Object.keys(a2).concat(Object.keys(u3));
  for (const h5 of f7) l4[h5] = { chains: ot((n2 = a2[h5]) == null ? void 0 : n2.chains, (r2 = u3[h5]) == null ? void 0 : r2.chains), methods: ot((o2 = a2[h5]) == null ? void 0 : o2.methods, (i3 = u3[h5]) == null ? void 0 : i3.methods), events: ot((s = a2[h5]) == null ? void 0 : s.events, (c3 = u3[h5]) == null ? void 0 : c3.events) };
  return l4;
}
var wo2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var bo2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function ht2(t, e) {
  const { message: n2, code: r2 } = bo2[t];
  return { message: e ? `${n2} ${e}` : n2, code: r2 };
}
function Nt2(t, e) {
  const { message: n2, code: r2 } = wo2[t];
  return { message: e ? `${n2} ${e}` : n2, code: r2 };
}
function se(t, e) {
  return Array.isArray(t) ? typeof e < "u" && t.length ? t.every(e) : true : false;
}
function Oe2(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function Et2(t) {
  return typeof t > "u";
}
function nt2(t, e) {
  return e && Et2(t) ? true : typeof t == "string" && !!t.trim().length;
}
function Ae2(t, e) {
  return e && Et2(t) ? true : typeof t == "number" && !isNaN(t);
}
function ua(t, e) {
  const { requiredNamespaces: n2 } = e, r2 = Object.keys(t.namespaces), o2 = Object.keys(n2);
  let i3 = true;
  return gt2(o2, r2) ? (r2.forEach((s) => {
    const { accounts: c3, methods: a2, events: u3 } = t.namespaces[s], l4 = It2(c3), f7 = n2[s];
    (!gt2(ue(s, f7), l4) || !gt2(f7.methods, a2) || !gt2(f7.events, u3)) && (i3 = false);
  }), i3) : false;
}
function ce(t) {
  return nt2(t, false) && t.includes(":") ? t.split(":").length === 2 : false;
}
function Eo2(t) {
  if (nt2(t, false) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const n2 = e[0] + ":" + e[1];
      return !!e[2] && ce(n2);
    }
  }
  return false;
}
function fa(t) {
  function e(n2) {
    try {
      return typeof new URL(n2) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (nt2(t, false)) {
      if (e(t)) return true;
      const n2 = je2(t);
      return e(n2);
    }
  } catch {
  }
  return false;
}
function la(t) {
  var e;
  return (e = t?.proposer) == null ? void 0 : e.publicKey;
}
function da(t) {
  return t?.topic;
}
function ha(t, e) {
  let n2 = null;
  return nt2(t?.publicKey, false) || (n2 = ht2("MISSING_OR_INVALID", `${e} controller public key should be a string`)), n2;
}
function mn2(t) {
  let e = true;
  return se(t) ? t.length && (e = t.every((n2) => nt2(n2, false))) : e = false, e;
}
function vo2(t, e, n2) {
  let r2 = null;
  return se(e) && e.length ? e.forEach((o2) => {
    r2 || ce(o2) || (r2 = Nt2("UNSUPPORTED_CHAINS", `${n2}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : ce(t) || (r2 = Nt2("UNSUPPORTED_CHAINS", `${n2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function xo2(t, e, n2) {
  let r2 = null;
  return Object.entries(t).forEach(([o2, i3]) => {
    if (r2) return;
    const s = vo2(o2, ue(o2, i3), `${e} ${n2}`);
    s && (r2 = s);
  }), r2;
}
function So2(t, e) {
  let n2 = null;
  return se(t) ? t.forEach((r2) => {
    n2 || Eo2(r2) || (n2 = Nt2("UNSUPPORTED_ACCOUNTS", `${e}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : n2 = Nt2("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n2;
}
function Oo2(t, e) {
  let n2 = null;
  return Object.values(t).forEach((r2) => {
    if (n2) return;
    const o2 = So2(r2?.accounts, `${e} namespace`);
    o2 && (n2 = o2);
  }), n2;
}
function Ao2(t, e) {
  let n2 = null;
  return mn2(t?.methods) ? mn2(t?.events) || (n2 = Nt2("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : n2 = Nt2("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), n2;
}
function wn(t, e) {
  let n2 = null;
  return Object.values(t).forEach((r2) => {
    if (n2) return;
    const o2 = Ao2(r2, `${e}, namespace`);
    o2 && (n2 = o2);
  }), n2;
}
function pa(t, e, n2) {
  let r2 = null;
  if (t && Oe2(t)) {
    const o2 = wn(t, e);
    o2 && (r2 = o2);
    const i3 = xo2(t, e, n2);
    i3 && (r2 = i3);
  } else r2 = ht2("MISSING_OR_INVALID", `${e}, ${n2} should be an object with data`);
  return r2;
}
function Bo2(t, e) {
  let n2 = null;
  if (t && Oe2(t)) {
    const r2 = wn(t, e);
    r2 && (n2 = r2);
    const o2 = Oo2(t, e);
    o2 && (n2 = o2);
  } else n2 = ht2("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return n2;
}
function Io2(t) {
  return nt2(t.protocol, true);
}
function ga(t, e) {
  let n2 = false;
  return e && !t ? n2 = true : t && se(t) && t.length && t.forEach((r2) => {
    n2 = Io2(r2);
  }), n2;
}
function ya(t) {
  return typeof t == "number";
}
function ma(t) {
  return typeof t < "u" && typeof t !== null;
}
function wa(t) {
  return !(!t || typeof t != "object" || !t.code || !Ae2(t.code, false) || !t.message || !nt2(t.message, false));
}
function ba(t) {
  return !(Et2(t) || !nt2(t.method, false));
}
function Ea(t) {
  return !(Et2(t) || Et2(t.result) && Et2(t.error) || !Ae2(t.id, false) || !nt2(t.jsonrpc, false));
}
function va(t) {
  return !(Et2(t) || !nt2(t.name, false));
}
function xa(t, e) {
  return !(!ce(e) || !ho2(t).includes(e));
}
function Sa(t, e, n2) {
  return nt2(n2, false) ? po2(t, e).includes(n2) : false;
}
function Oa(t, e, n2) {
  return nt2(n2, false) ? go2(t, e).includes(n2) : false;
}
function No2(t, e, n2) {
  let r2 = null;
  const o2 = Aa(t), i3 = Ba(e), s = Object.keys(o2), c3 = Object.keys(i3), a2 = Uo2(Object.keys(t)), u3 = Uo2(Object.keys(e)), l4 = a2.filter((f7) => !u3.includes(f7));
  return l4.length && (r2 = ht2("NON_CONFORMING_NAMESPACES", `${n2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l4.toString()}
      Received: ${Object.keys(e).toString()}`)), gt2(s, c3) || (r2 = ht2("NON_CONFORMING_NAMESPACES", `${n2} namespaces chains don't satisfy required namespaces.
      Required: ${s.toString()}
      Approved: ${c3.toString()}`)), Object.keys(e).forEach((f7) => {
    if (!f7.includes(":") || r2) return;
    const h5 = It2(e[f7].accounts);
    h5.includes(f7) || (r2 = ht2("NON_CONFORMING_NAMESPACES", `${n2} namespaces accounts don't satisfy namespace accounts for ${f7}
        Required: ${f7}
        Approved: ${h5.toString()}`));
  }), s.forEach((f7) => {
    r2 || (gt2(o2[f7].methods, i3[f7].methods) ? gt2(o2[f7].events, i3[f7].events) || (r2 = ht2("NON_CONFORMING_NAMESPACES", `${n2} namespaces events don't satisfy namespace events for ${f7}`)) : r2 = ht2("NON_CONFORMING_NAMESPACES", `${n2} namespaces methods don't satisfy namespace methods for ${f7}`));
  }), r2;
}
function Aa(t) {
  const e = {};
  return Object.keys(t).forEach((n2) => {
    var r2;
    n2.includes(":") ? e[n2] = t[n2] : (r2 = t[n2].chains) == null || r2.forEach((o2) => {
      e[o2] = { methods: t[n2].methods, events: t[n2].events };
    });
  }), e;
}
function Uo2(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function Ba(t) {
  const e = {};
  return Object.keys(t).forEach((n2) => {
    if (n2.includes(":")) e[n2] = t[n2];
    else {
      const r2 = It2(t[n2].accounts);
      r2?.forEach((o2) => {
        e[o2] = { accounts: t[n2].accounts.filter((i3) => i3.includes(`${o2}:`)), methods: t[n2].methods, events: t[n2].events };
      });
    }
  }), e;
}
function Ia(t, e) {
  return Ae2(t, false) && t <= e.max && t >= e.min;
}
function Na() {
  const t = xt2();
  return new Promise((e) => {
    switch (t) {
      case Y.browser:
        e(To2());
        break;
      case Y.reactNative:
        e(Ro2());
        break;
      case Y.node:
        e(_o2());
        break;
      default:
        e(true);
    }
  });
}
function To2() {
  return Tt2() && navigator?.onLine;
}
async function Ro2() {
  if (pt() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t?.isConnected;
  }
  return true;
}
function _o2() {
  return true;
}
function Ua(t) {
  switch (xt2()) {
    case Y.browser:
      $o2(t);
      break;
    case Y.reactNative:
      Lo2(t);
      break;
    case Y.node:
      break;
  }
}
function $o2(t) {
  !pt() && Tt2() && (window.addEventListener("online", () => t(true)), window.addEventListener("offline", () => t(false)));
}
function Lo2(t) {
  pt() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener((e) => t(e?.isConnected));
}
function Ta() {
  var t;
  return Tt2() && (0, import_window_getters.getDocument)() ? ((t = (0, import_window_getters.getDocument)()) == null ? void 0 : t.visibilityState) === "visible" : true;
}
var bn2 = {};
var Ra = class {
  static get(e) {
    return bn2[e];
  }
  static set(e, n2) {
    bn2[e] = n2;
  }
  static delete(e) {
    delete bn2[e];
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events3 = __toESM(require_events());
var v2 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser();
var w = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var d2 = (r2) => r2.split("?")[0];
var h3 = 10;
var b2 = v2();
var f5 = class {
  constructor(e) {
    if (this.url = e, this.events = new import_events3.EventEmitter(), this.registering = false, !isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n2) => {
        this.onClose(n2), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n2, s) => {
        this.events.once("register_error", (o2) => {
          this.resetMaxListeners(), s(o2);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return s(new Error("WebSocket connection is missing or invalid"));
          n2(this.socket);
        });
      });
    }
    return this.url = e, this.registering = true, new Promise((t, n2) => {
      const s = (0, esm_exports.isReactNative)() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e) }, o2 = new b2(e, [], s);
      w() ? o2.onerror = (i3) => {
        const a2 = i3;
        n2(this.emitError(a2.error));
      } : o2.on("error", (i3) => {
        n2(this.emitError(i3));
      }), o2.onopen = () => {
        this.onOpen(o2), t(o2);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = false, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const t = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n2 = this.parseError(t), s = n2.message || n2.toString(), o2 = formatJsonRpcError(e, s);
    this.events.emit("payload", o2);
  }
  parseError(e, t = this.url) {
    return parseConnectionError(e, d2(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h3 && this.events.setMaxListeners(h3);
  }
  emitError(e) {
    const t = this.parseError(new Error(e?.message || `WebSocket connection failed for host: ${d2(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_window_getters2 = __toESM(require_cjs2());
var ze3 = "wc";
var Le2 = 2;
var he3 = "core";
var B = `${ze3}@2:${he3}:`;
var Et3 = { name: he3, logger: "error" };
var It3 = { database: ":memory:" };
var Tt3 = "crypto";
var ke3 = "client_ed25519_seed";
var Ct2 = import_time3.ONE_DAY;
var Pt3 = "keychain";
var St3 = "0.3";
var Ot3 = "messages";
var Rt3 = "0.3";
var je3 = import_time3.SIX_HOURS;
var At2 = "publisher";
var xt3 = "irn";
var Nt3 = "error";
var Ue2 = "wss://relay.walletconnect.org";
var $t3 = "relayer";
var C2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var zt2 = "_subscription";
var L = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Lt3 = 0.1;
var _e3 = "2.21.0";
var Q2 = { link_mode: "link_mode", relay: "relay" };
var le3 = { inbound: "inbound", outbound: "outbound" };
var kt3 = "0.3";
var jt3 = "WALLETCONNECT_CLIENT_ID";
var Fe2 = "WALLETCONNECT_LINK_MODE_APPS";
var $ = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Ut2 = "subscription";
var Ft3 = "0.3";
var Ys2 = import_time3.FIVE_SECONDS * 1e3;
var Mt3 = "pairing";
var Kt3 = "0.3";
var se2 = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
var re2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var F2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Bt3 = "history";
var Vt3 = "0.3";
var qt3 = "expirer";
var M3 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Gt2 = "0.3";
var Wt3 = "verify-api";
var Zs2 = "https://verify.walletconnect.com";
var Ht3 = "https://verify.walletconnect.org";
var ue2 = Ht3;
var Yt3 = `${ue2}/v3`;
var Jt3 = [Zs2, Ht3];
var Xt3 = "echo";
var Zt2 = "https://echo.walletconnect.com";
var G3 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var Y2 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var er3 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var tr3 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var ir3 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var sr3 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Qt3 = 0.1;
var ei2 = "event-client";
var ti = 86400;
var ii = "https://pulse.walletconnect.org/batch";
function rr3(r2, e) {
  if (r2.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i3 = 0; i3 < t.length; i3++) t[i3] = 255;
  for (var s = 0; s < r2.length; s++) {
    var n2 = r2.charAt(s), o2 = n2.charCodeAt(0);
    if (t[o2] !== 255) throw new TypeError(n2 + " is ambiguous");
    t[o2] = s;
  }
  var a2 = r2.length, c3 = r2.charAt(0), h5 = Math.log(a2) / Math.log(256), l4 = Math.log(256) / Math.log(a2);
  function d4(u3) {
    if (u3 instanceof Uint8Array || (ArrayBuffer.isView(u3) ? u3 = new Uint8Array(u3.buffer, u3.byteOffset, u3.byteLength) : Array.isArray(u3) && (u3 = Uint8Array.from(u3))), !(u3 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u3.length === 0) return "";
    for (var b5 = 0, x3 = 0, I3 = 0, D2 = u3.length; I3 !== D2 && u3[I3] === 0; ) I3++, b5++;
    for (var j3 = (D2 - I3) * l4 + 1 >>> 0, T2 = new Uint8Array(j3); I3 !== D2; ) {
      for (var q3 = u3[I3], J4 = 0, K4 = j3 - 1; (q3 !== 0 || J4 < x3) && K4 !== -1; K4--, J4++) q3 += 256 * T2[K4] >>> 0, T2[K4] = q3 % a2 >>> 0, q3 = q3 / a2 >>> 0;
      if (q3 !== 0) throw new Error("Non-zero carry");
      x3 = J4, I3++;
    }
    for (var H4 = j3 - x3; H4 !== j3 && T2[H4] === 0; ) H4++;
    for (var me5 = c3.repeat(b5); H4 < j3; ++H4) me5 += r2.charAt(T2[H4]);
    return me5;
  }
  function g2(u3) {
    if (typeof u3 != "string") throw new TypeError("Expected String");
    if (u3.length === 0) return new Uint8Array();
    var b5 = 0;
    if (u3[b5] !== " ") {
      for (var x3 = 0, I3 = 0; u3[b5] === c3; ) x3++, b5++;
      for (var D2 = (u3.length - b5) * h5 + 1 >>> 0, j3 = new Uint8Array(D2); u3[b5]; ) {
        var T2 = t[u3.charCodeAt(b5)];
        if (T2 === 255) return;
        for (var q3 = 0, J4 = D2 - 1; (T2 !== 0 || q3 < I3) && J4 !== -1; J4--, q3++) T2 += a2 * j3[J4] >>> 0, j3[J4] = T2 % 256 >>> 0, T2 = T2 / 256 >>> 0;
        if (T2 !== 0) throw new Error("Non-zero carry");
        I3 = q3, b5++;
      }
      if (u3[b5] !== " ") {
        for (var K4 = D2 - I3; K4 !== D2 && j3[K4] === 0; ) K4++;
        for (var H4 = new Uint8Array(x3 + (D2 - K4)), me5 = x3; K4 !== D2; ) H4[me5++] = j3[K4++];
        return H4;
      }
    }
  }
  function _(u3) {
    var b5 = g2(u3);
    if (b5) return b5;
    throw new Error(`Non-${e} character`);
  }
  return { encode: d4, decodeUnsafe: g2, decode: _ };
}
var nr3 = rr3;
var or3 = nr3;
var si2 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array") return r2;
  if (r2 instanceof ArrayBuffer) return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2)) return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ar3 = (r2) => new TextEncoder().encode(r2);
var cr3 = (r2) => new TextDecoder().decode(r2);
var hr3 = class {
  constructor(e, t, i3) {
    this.name = e, this.prefix = t, this.baseEncode = i3;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var lr3 = class {
  constructor(e, t, i3) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i3;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ri2(this, e);
  }
};
var ur3 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ri2(this, e);
  }
  decode(e) {
    const t = e[0], i3 = this.decoders[t];
    if (i3) return i3.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ri2 = (r2, e) => new ur3({ ...r2.decoders || { [r2.prefix]: r2 }, ...e.decoders || { [e.prefix]: e } });
var dr3 = class {
  constructor(e, t, i3, s) {
    this.name = e, this.prefix = t, this.baseEncode = i3, this.baseDecode = s, this.encoder = new hr3(e, t, i3), this.decoder = new lr3(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Ee3 = ({ name: r2, prefix: e, encode: t, decode: i3 }) => new dr3(r2, e, t, i3);
var de3 = ({ prefix: r2, name: e, alphabet: t }) => {
  const { encode: i3, decode: s } = or3(t, e);
  return Ee3({ prefix: r2, name: e, encode: i3, decode: (n2) => si2(s(n2)) });
};
var gr2 = (r2, e, t, i3) => {
  const s = {};
  for (let l4 = 0; l4 < e.length; ++l4) s[e[l4]] = l4;
  let n2 = r2.length;
  for (; r2[n2 - 1] === "="; ) --n2;
  const o2 = new Uint8Array(n2 * t / 8 | 0);
  let a2 = 0, c3 = 0, h5 = 0;
  for (let l4 = 0; l4 < n2; ++l4) {
    const d4 = s[r2[l4]];
    if (d4 === void 0) throw new SyntaxError(`Non-${i3} character`);
    c3 = c3 << t | d4, a2 += t, a2 >= 8 && (a2 -= 8, o2[h5++] = 255 & c3 >> a2);
  }
  if (a2 >= t || 255 & c3 << 8 - a2) throw new SyntaxError("Unexpected end of data");
  return o2;
};
var pr2 = (r2, e, t) => {
  const i3 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let n2 = "", o2 = 0, a2 = 0;
  for (let c3 = 0; c3 < r2.length; ++c3) for (a2 = a2 << 8 | r2[c3], o2 += 8; o2 > t; ) o2 -= t, n2 += e[s & a2 >> o2];
  if (o2 && (n2 += e[s & a2 << t - o2]), i3) for (; n2.length * t & 7; ) n2 += "=";
  return n2;
};
var P3 = ({ name: r2, prefix: e, bitsPerChar: t, alphabet: i3 }) => Ee3({ prefix: e, name: r2, encode(s) {
  return pr2(s, i3, t);
}, decode(s) {
  return gr2(s, i3, t, r2);
} });
var yr2 = Ee3({ prefix: "\0", name: "identity", encode: (r2) => cr3(r2), decode: (r2) => ar3(r2) });
var br3 = Object.freeze({ __proto__: null, identity: yr2 });
var mr3 = P3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var fr3 = Object.freeze({ __proto__: null, base2: mr3 });
var Dr3 = P3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vr3 = Object.freeze({ __proto__: null, base8: Dr3 });
var wr3 = de3({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _r3 = Object.freeze({ __proto__: null, base10: wr3 });
var Er2 = P3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Ir3 = P3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Tr3 = Object.freeze({ __proto__: null, base16: Er2, base16upper: Ir3 });
var Cr3 = P3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Pr3 = P3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Sr3 = P3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Or3 = P3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Rr3 = P3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Ar3 = P3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var xr2 = P3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Nr3 = P3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var $r3 = P3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var zr3 = Object.freeze({ __proto__: null, base32: Cr3, base32upper: Pr3, base32pad: Sr3, base32padupper: Or3, base32hex: Rr3, base32hexupper: Ar3, base32hexpad: xr2, base32hexpadupper: Nr3, base32z: $r3 });
var Lr3 = de3({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var kr3 = de3({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var jr3 = Object.freeze({ __proto__: null, base36: Lr3, base36upper: kr3 });
var Ur3 = de3({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Fr3 = de3({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Mr3 = Object.freeze({ __proto__: null, base58btc: Ur3, base58flickr: Fr3 });
var Kr5 = P3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Br3 = P3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Vr3 = P3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var qr3 = P3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Gr3 = Object.freeze({ __proto__: null, base64: Kr5, base64pad: Br3, base64url: Vr3, base64urlpad: qr3 });
var ni2 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var Wr3 = ni2.reduce((r2, e, t) => (r2[t] = e, r2), []);
var Hr3 = ni2.reduce((r2, e, t) => (r2[e.codePointAt(0)] = t, r2), []);
function Yr3(r2) {
  return r2.reduce((e, t) => (e += Wr3[t], e), "");
}
function Jr3(r2) {
  const e = [];
  for (const t of r2) {
    const i3 = Hr3[t.codePointAt(0)];
    if (i3 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i3);
  }
  return new Uint8Array(e);
}
var Xr3 = Ee3({ prefix: "🚀", name: "base256emoji", encode: Yr3, decode: Jr3 });
var Zr3 = Object.freeze({ __proto__: null, base256emoji: Xr3 });
var Qr3 = ai;
var oi2 = 128;
var en3 = 127;
var tn2 = ~en3;
var sn3 = Math.pow(2, 31);
function ai(r2, e, t) {
  e = e || [], t = t || 0;
  for (var i3 = t; r2 >= sn3; ) e[t++] = r2 & 255 | oi2, r2 /= 128;
  for (; r2 & tn2; ) e[t++] = r2 & 255 | oi2, r2 >>>= 7;
  return e[t] = r2 | 0, ai.bytes = t - i3 + 1, e;
}
var rn3 = Me3;
var nn3 = 128;
var ci = 127;
function Me3(r2, i3) {
  var t = 0, i3 = i3 || 0, s = 0, n2 = i3, o2, a2 = r2.length;
  do {
    if (n2 >= a2) throw Me3.bytes = 0, new RangeError("Could not decode varint");
    o2 = r2[n2++], t += s < 28 ? (o2 & ci) << s : (o2 & ci) * Math.pow(2, s), s += 7;
  } while (o2 >= nn3);
  return Me3.bytes = n2 - i3, t;
}
var on3 = Math.pow(2, 7);
var an2 = Math.pow(2, 14);
var cn2 = Math.pow(2, 21);
var hn2 = Math.pow(2, 28);
var ln2 = Math.pow(2, 35);
var un2 = Math.pow(2, 42);
var dn2 = Math.pow(2, 49);
var gn3 = Math.pow(2, 56);
var pn2 = Math.pow(2, 63);
var yn3 = function(r2) {
  return r2 < on3 ? 1 : r2 < an2 ? 2 : r2 < cn2 ? 3 : r2 < hn2 ? 4 : r2 < ln2 ? 5 : r2 < un2 ? 6 : r2 < dn2 ? 7 : r2 < gn3 ? 8 : r2 < pn2 ? 9 : 10;
};
var bn3 = { encode: Qr3, decode: rn3, encodingLength: yn3 };
var hi = bn3;
var li2 = (r2, e, t = 0) => (hi.encode(r2, e, t), e);
var ui = (r2) => hi.encodingLength(r2);
var Ke3 = (r2, e) => {
  const t = e.byteLength, i3 = ui(r2), s = i3 + ui(t), n2 = new Uint8Array(s + t);
  return li2(r2, n2, 0), li2(t, n2, i3), n2.set(e, s), new mn3(r2, t, e, n2);
};
var mn3 = class {
  constructor(e, t, i3, s) {
    this.code = e, this.size = t, this.digest = i3, this.bytes = s;
  }
};
var di = ({ name: r2, code: e, encode: t }) => new fn2(r2, e, t);
var fn2 = class {
  constructor(e, t, i3) {
    this.name = e, this.code = t, this.encode = i3;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ke3(this.code, t) : t.then((i3) => Ke3(this.code, i3));
    } else throw Error("Unknown type, must be binary type");
  }
};
var gi2 = (r2) => async (e) => new Uint8Array(await crypto.subtle.digest(r2, e));
var Dn = di({ name: "sha2-256", code: 18, encode: gi2("SHA-256") });
var vn2 = di({ name: "sha2-512", code: 19, encode: gi2("SHA-512") });
var wn2 = Object.freeze({ __proto__: null, sha256: Dn, sha512: vn2 });
var pi = 0;
var _n3 = "identity";
var yi2 = si2;
var En3 = (r2) => Ke3(pi, yi2(r2));
var In2 = { code: pi, name: _n3, encode: yi2, digest: En3 };
var Tn3 = Object.freeze({ __proto__: null, identity: In2 });
new TextEncoder(), new TextDecoder();
var bi2 = { ...br3, ...fr3, ...vr3, ..._r3, ...Tr3, ...zr3, ...jr3, ...Mr3, ...Gr3, ...Zr3 };
({ ...wn2, ...Tn3 });
function Cn3(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r2) : new Uint8Array(r2);
}
function mi2(r2, e, t, i3) {
  return { name: r2, prefix: e, encoder: { name: r2, prefix: e, encode: t }, decoder: { decode: i3 } };
}
var fi2 = mi2("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var Be2 = mi2("ascii", "a", (r2) => {
  let e = "a";
  for (let t = 0; t < r2.length; t++) e += String.fromCharCode(r2[t]);
  return e;
}, (r2) => {
  r2 = r2.substring(1);
  const e = Cn3(r2.length);
  for (let t = 0; t < r2.length; t++) e[t] = r2.charCodeAt(t);
  return e;
});
var Pn3 = { utf8: fi2, "utf-8": fi2, hex: bi2.base16, latin1: Be2, ascii: Be2, binary: Be2, ...bi2 };
function Sn3(r2, e = "utf8") {
  const t = Pn3[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r2, "utf8") : t.decoder.decode(`${t.prefix}${r2}`);
}
var On3 = Object.defineProperty;
var Rn3 = (r2, e, t) => e in r2 ? On3(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var W2 = (r2, e, t) => Rn3(r2, typeof e != "symbol" ? e + "" : e, t);
var Di2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, W2(this, "keychain", /* @__PURE__ */ new Map()), W2(this, "name", Pt3), W2(this, "version", St3), W2(this, "initialized", false), W2(this, "storagePrefix", B), W2(this, "init", async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }), W2(this, "has", (i3) => (this.isInitialized(), this.keychain.has(i3))), W2(this, "set", async (i3, s) => {
      this.isInitialized(), this.keychain.set(i3, s), await this.persist();
    }), W2(this, "get", (i3) => {
      this.isInitialized();
      const s = this.keychain.get(i3);
      if (typeof s > "u") {
        const { message: n2 } = ht2("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(n2);
      }
      return s;
    }), W2(this, "del", async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }), this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, fi(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? li(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var An2 = Object.defineProperty;
var xn3 = (r2, e, t) => e in r2 ? An2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var S2 = (r2, e, t) => xn3(r2, typeof e != "symbol" ? e + "" : e, t);
var vi2 = class {
  constructor(e, t, i3) {
    this.core = e, this.logger = t, S2(this, "name", Tt3), S2(this, "keychain"), S2(this, "randomSessionIdentifier", jc()), S2(this, "initialized", false), S2(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), S2(this, "hasKeys", (s) => (this.isInitialized(), this.keychain.has(s))), S2(this, "getClientId", async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), n2 = Po(s);
      return Qe(n2.publicKey);
    }), S2(this, "generateKeyPair", () => {
      this.isInitialized();
      const s = Lc();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }), S2(this, "signJWT", async (s) => {
      this.isInitialized();
      const n2 = await this.getClientSeed(), o2 = Po(n2), a2 = this.randomSessionIdentifier, c3 = Ct2;
      return await Qo(a2, s, c3, o2);
    }), S2(this, "generateSharedKey", (s, n2, o2) => {
      this.isInitialized();
      const a2 = this.getPrivateKey(s), c3 = Cc(a2, n2);
      return this.setSymKey(c3, o2);
    }), S2(this, "setSymKey", async (s, n2) => {
      this.isInitialized();
      const o2 = n2 || Pc(s);
      return await this.keychain.set(o2, s), o2;
    }), S2(this, "deleteKeyPair", async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }), S2(this, "deleteSymKey", async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }), S2(this, "encode", async (s, n2, o2) => {
      this.isInitialized();
      const a2 = oo2(o2), c3 = safeJsonStringify(n2);
      if (Fc(a2)) return Dc(c3, o2?.encoding);
      if (Kc(a2)) {
        const g2 = a2.senderPublicKey, _ = a2.receiverPublicKey;
        s = await this.generateSharedKey(g2, _);
      }
      const h5 = this.getSymKey(s), { type: l4, senderPublicKey: d4 } = a2;
      return Vc({ type: l4, symKey: h5, message: c3, senderPublicKey: d4, encoding: o2?.encoding });
    }), S2(this, "decode", async (s, n2, o2) => {
      this.isInitialized();
      const a2 = qc(n2, o2);
      if (Fc(a2)) {
        const c3 = Hc(n2, o2?.encoding);
        return safeJsonParse(c3);
      }
      if (Kc(a2)) {
        const c3 = a2.receiverPublicKey, h5 = a2.senderPublicKey;
        s = await this.generateSharedKey(c3, h5);
      }
      try {
        const c3 = this.getSymKey(s), h5 = Mc({ symKey: c3, encoded: n2, encoding: o2?.encoding });
        return safeJsonParse(h5);
      } catch (c3) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(c3);
      }
    }), S2(this, "getPayloadType", (s, n2 = qt2) => {
      const o2 = Se2({ encoded: s, encoding: n2 });
      return Bt2(o2.type);
    }), S2(this, "getPayloadSenderPublicKey", (s, n2 = qt2) => {
      const o2 = Se2({ encoded: s, encoding: n2 });
      return o2.senderPublicKey ? toString(o2.senderPublicKey, G2) : void 0;
    }), this.core = e, this.logger = E(t, this.name), this.keychain = i3 || new Di2(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(ke3);
    } catch {
      e = jc(), await this.keychain.set(ke3, e);
    }
    return Sn3(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Nn2 = Object.defineProperty;
var $n3 = Object.defineProperties;
var zn3 = Object.getOwnPropertyDescriptors;
var wi2 = Object.getOwnPropertySymbols;
var Ln2 = Object.prototype.hasOwnProperty;
var kn3 = Object.prototype.propertyIsEnumerable;
var Ve3 = (r2, e, t) => e in r2 ? Nn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var jn3 = (r2, e) => {
  for (var t in e || (e = {})) Ln2.call(e, t) && Ve3(r2, t, e[t]);
  if (wi2) for (var t of wi2(e)) kn3.call(e, t) && Ve3(r2, t, e[t]);
  return r2;
};
var Un2 = (r2, e) => $n3(r2, zn3(e));
var k4 = (r2, e, t) => Ve3(r2, typeof e != "symbol" ? e + "" : e, t);
var _i2 = class extends y2 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, k4(this, "messages", /* @__PURE__ */ new Map()), k4(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), k4(this, "name", Ot3), k4(this, "version", Rt3), k4(this, "initialized", false), k4(this, "storagePrefix", B), k4(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3);
          const s = await this.getRelayerMessagesWithoutClientAck();
          typeof s < "u" && (this.messagesWithoutClientAck = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }), k4(this, "set", async (i3, s, n2) => {
      this.isInitialized();
      const o2 = kc(s);
      let a2 = this.messages.get(i3);
      if (typeof a2 > "u" && (a2 = {}), typeof a2[o2] < "u") return o2;
      if (a2[o2] = s, this.messages.set(i3, a2), n2 === le3.inbound) {
        const c3 = this.messagesWithoutClientAck.get(i3) || {};
        this.messagesWithoutClientAck.set(i3, Un2(jn3({}, c3), { [o2]: s }));
      }
      return await this.persist(), o2;
    }), k4(this, "get", (i3) => {
      this.isInitialized();
      let s = this.messages.get(i3);
      return typeof s > "u" && (s = {}), s;
    }), k4(this, "getWithoutAck", (i3) => {
      this.isInitialized();
      const s = {};
      for (const n2 of i3) {
        const o2 = this.messagesWithoutClientAck.get(n2) || {};
        s[n2] = Object.values(o2);
      }
      return s;
    }), k4(this, "has", (i3, s) => {
      this.isInitialized();
      const n2 = this.get(i3), o2 = kc(s);
      return typeof n2[o2] < "u";
    }), k4(this, "ack", async (i3, s) => {
      this.isInitialized();
      const n2 = this.messagesWithoutClientAck.get(i3);
      if (typeof n2 > "u") return;
      const o2 = kc(s);
      delete n2[o2], Object.keys(n2).length === 0 ? this.messagesWithoutClientAck.delete(i3) : this.messagesWithoutClientAck.set(i3, n2), await this.persist();
    }), k4(this, "del", async (i3) => {
      this.isInitialized(), this.messages.delete(i3), this.messagesWithoutClientAck.delete(i3), await this.persist();
    }), this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, fi(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, fi(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? li(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? li(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Fn3 = Object.defineProperty;
var Mn3 = Object.defineProperties;
var Kn3 = Object.getOwnPropertyDescriptors;
var Ei2 = Object.getOwnPropertySymbols;
var Bn2 = Object.prototype.hasOwnProperty;
var Vn3 = Object.prototype.propertyIsEnumerable;
var qe3 = (r2, e, t) => e in r2 ? Fn3(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Ie3 = (r2, e) => {
  for (var t in e || (e = {})) Bn2.call(e, t) && qe3(r2, t, e[t]);
  if (Ei2) for (var t of Ei2(e)) Vn3.call(e, t) && qe3(r2, t, e[t]);
  return r2;
};
var Ge3 = (r2, e) => Mn3(r2, Kn3(e));
var V3 = (r2, e, t) => qe3(r2, typeof e != "symbol" ? e + "" : e, t);
var qn2 = class extends m {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, V3(this, "events", new import_events4.EventEmitter()), V3(this, "name", At2), V3(this, "queue", /* @__PURE__ */ new Map()), V3(this, "publishTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE)), V3(this, "initialPublishTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), V3(this, "needsTransportRestart", false), V3(this, "publish", async (i3, s, n2) => {
      var o2;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: n2 } });
      const a2 = n2?.ttl || je3, c3 = Zc(n2), h5 = n2?.prompt || false, l4 = n2?.tag || 0, d4 = n2?.id || getBigIntRpcId().toString(), g2 = { topic: i3, message: s, opts: { ttl: a2, relay: c3, prompt: h5, tag: l4, id: d4, attestation: n2?.attestation, tvf: n2?.tvf } }, _ = `Failed to publish payload, please try again. id:${d4} tag:${l4}`;
      try {
        const u3 = new Promise(async (b5) => {
          const x3 = ({ id: D2 }) => {
            g2.opts.id === D2 && (this.removeRequestFromQueue(D2), this.relayer.events.removeListener(C2.publish, x3), b5(g2));
          };
          this.relayer.events.on(C2.publish, x3);
          const I3 = yi(new Promise((D2, j3) => {
            this.rpcPublish({ topic: i3, message: s, ttl: a2, prompt: h5, tag: l4, id: d4, attestation: n2?.attestation, tvf: n2?.tvf }).then(D2).catch((T2) => {
              this.logger.warn(T2, T2?.message), j3(T2);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d4} tag:${l4}`);
          try {
            await I3, this.events.removeListener(C2.publish, x3);
          } catch (D2) {
            this.queue.set(d4, Ge3(Ie3({}, g2), { attempt: 1 })), this.logger.warn(D2, D2?.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: d4, topic: i3, message: s, opts: n2 } }), await yi(u3, this.publishTimeout, _);
      } catch (u3) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(u3), (o2 = n2?.internal) != null && o2.throwOnFailedPublish) throw u3;
      } finally {
        this.queue.delete(d4);
      }
    }), V3(this, "on", (i3, s) => {
      this.events.on(i3, s);
    }), V3(this, "once", (i3, s) => {
      this.events.once(i3, s);
    }), V3(this, "off", (i3, s) => {
      this.events.off(i3, s);
    }), V3(this, "removeListener", (i3, s) => {
      this.events.removeListener(i3, s);
    }), this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  async rpcPublish(e) {
    var t, i3, s, n2;
    const { topic: o2, message: a2, ttl: c3 = je3, prompt: h5, tag: l4, id: d4, attestation: g2, tvf: _ } = e, u3 = { method: Yc(Zc().protocol).publish, params: Ie3({ topic: o2, message: a2, ttl: c3, prompt: h5, tag: l4, attestation: g2 }, _), id: d4 };
    Et2((t = u3.params) == null ? void 0 : t.prompt) && ((i3 = u3.params) == null || delete i3.prompt), Et2((s = u3.params) == null ? void 0 : s.tag) && ((n2 = u3.params) == null || delete n2.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: u3 });
    const b5 = await this.relayer.request(u3);
    return this.relayer.events.emit(C2.publish, e), this.logger.debug("Successfully Published Payload"), b5;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      const i3 = e.attempt + 1;
      this.queue.set(t, Ge3(Ie3({}, e), { attempt: i3 }));
      const { topic: s, message: n2, opts: o2, attestation: a2 } = e;
      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${i3}`), await this.rpcPublish(Ge3(Ie3({}, e), { topic: s, message: n2, ttl: o2.ttl, prompt: o2.prompt, tag: o2.tag, id: o2.id, attestation: a2, tvf: o2.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(C2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(C2.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Gn3 = Object.defineProperty;
var Wn3 = (r2, e, t) => e in r2 ? Gn3(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var ne2 = (r2, e, t) => Wn3(r2, typeof e != "symbol" ? e + "" : e, t);
var Hn2 = class {
  constructor() {
    ne2(this, "map", /* @__PURE__ */ new Map()), ne2(this, "set", (e, t) => {
      const i3 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i3, t]);
    }), ne2(this, "get", (e) => this.map.get(e) || []), ne2(this, "exists", (e, t) => this.get(e).includes(t)), ne2(this, "delete", (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const i3 = this.get(e);
      if (!this.exists(e, t)) return;
      const s = i3.filter((n2) => n2 !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }), ne2(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Yn3 = Object.defineProperty;
var Jn3 = Object.defineProperties;
var Xn3 = Object.getOwnPropertyDescriptors;
var Ii2 = Object.getOwnPropertySymbols;
var Zn3 = Object.prototype.hasOwnProperty;
var Qn3 = Object.prototype.propertyIsEnumerable;
var We3 = (r2, e, t) => e in r2 ? Yn3(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var ge3 = (r2, e) => {
  for (var t in e || (e = {})) Zn3.call(e, t) && We3(r2, t, e[t]);
  if (Ii2) for (var t of Ii2(e)) Qn3.call(e, t) && We3(r2, t, e[t]);
  return r2;
};
var He3 = (r2, e) => Jn3(r2, Xn3(e));
var f6 = (r2, e, t) => We3(r2, typeof e != "symbol" ? e + "" : e, t);
var Ti2 = class extends P {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, f6(this, "subscriptions", /* @__PURE__ */ new Map()), f6(this, "topicMap", new Hn2()), f6(this, "events", new import_events4.EventEmitter()), f6(this, "name", Ut2), f6(this, "version", Ft3), f6(this, "pending", /* @__PURE__ */ new Map()), f6(this, "cached", []), f6(this, "initialized", false), f6(this, "storagePrefix", B), f6(this, "subscribeTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE)), f6(this, "initialSubscribeTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), f6(this, "clientId"), f6(this, "batchSubscribeTopicsLimit", 500), f6(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), f6(this, "subscribe", async (i3, s) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } });
      try {
        const n2 = Zc(s), o2 = { topic: i3, relay: n2, transportType: s?.transportType };
        this.pending.set(i3, o2);
        const a2 = await this.rpcSubscribe(i3, n2, s);
        return typeof a2 == "string" && (this.onSubscribe(a2, o2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } })), a2;
      } catch (n2) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n2), n2;
      }
    }), f6(this, "unsubscribe", async (i3, s) => {
      this.isInitialized(), typeof s?.id < "u" ? await this.unsubscribeById(i3, s.id, s) : await this.unsubscribeByTopic(i3, s);
    }), f6(this, "isSubscribed", (i3) => new Promise((s) => {
      s(this.topicMap.topics.includes(i3));
    })), f6(this, "isKnownTopic", (i3) => new Promise((s) => {
      s(this.topicMap.topics.includes(i3) || this.pending.has(i3) || this.cached.some((n2) => n2.topic === i3));
    })), f6(this, "on", (i3, s) => {
      this.events.on(i3, s);
    }), f6(this, "once", (i3, s) => {
      this.events.once(i3, s);
    }), f6(this, "off", (i3, s) => {
      this.events.off(i3, s);
    }), f6(this, "removeListener", (i3, s) => {
      this.events.removeListener(i3, s);
    }), f6(this, "start", async () => {
      await this.onConnect();
    }), f6(this, "stop", async () => {
      await this.onDisconnect();
    }), f6(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), f6(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const i3 = [];
      this.pending.forEach((s) => {
        i3.push(s);
      }), await this.batchSubscribe(i3);
    }), f6(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on($.created, async (i3) => {
        const s = $.created;
        this.logger.info(`Emitting ${s}`), this.logger.debug({ type: "event", event: s, data: i3 }), await this.persist();
      }), this.events.on($.deleted, async (i3) => {
        const s = $.deleted;
        this.logger.info(`Emitting ${s}`), this.logger.debug({ type: "event", event: s, data: i3 }), await this.persist();
      });
    }), this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e, t) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i3;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i3 = this.topicMap.get(e);
    await Promise.all(i3.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    try {
      const s = Zc(i3);
      await this.restartToComplete({ topic: e, id: t, relay: s }), await this.rpcUnsubscribe(e, t, s);
      const n2 = Nt2("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n2), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t, i3) {
    var s;
    (!i3 || i3?.transportType === Q2.relay) && await this.restartToComplete({ topic: e, id: e, relay: t });
    const n2 = { method: Yc(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n2 });
    const o2 = (s = i3?.internal) == null ? void 0 : s.throwOnFailedPublish;
    try {
      const a2 = await this.getSubscriptionId(e);
      if (i3?.transportType === Q2.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n2).catch((l4) => this.logger.warn(l4));
      }, (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND)), a2;
      const c3 = new Promise(async (l4) => {
        const d4 = (g2) => {
          g2.topic === e && (this.events.removeListener($.created, d4), l4(g2.id));
        };
        this.events.on($.created, d4);
        try {
          const g2 = await yi(new Promise((_, u3) => {
            this.relayer.request(n2).catch((b5) => {
              this.logger.warn(b5, b5?.message), u3(b5);
            }).then(_);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener($.created, d4), l4(g2);
        } catch {
        }
      }), h5 = await yi(c3, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h5 && o2) throw new Error(`Subscribing to ${e} failed, please try again`);
      return h5 ? a2 : null;
    } catch (a2) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C2.connection_stalled), o2) throw a2;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, i3 = { method: Yc(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await yi(new Promise((s) => {
        this.relayer.request(i3).catch((n2) => this.logger.warn(n2)).then(s);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, i3 = { method: Yc(t.protocol).batchFetchMessages, params: { topics: e.map((n2) => n2.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    let s;
    try {
      s = await await yi(new Promise((n2, o2) => {
        this.relayer.request(i3).catch((a2) => {
          this.logger.warn(a2), o2(a2);
        }).then(n2);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
    return s;
  }
  rpcUnsubscribe(e, t, i3) {
    const s = { method: Yc(i3.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, He3(ge3({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, ge3({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i3) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i3), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, ge3({}, t)), this.topicMap.set(t.topic, e), this.events.emit($.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i3 } = ht2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i3 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i3.topic, e), this.events.emit($.deleted, He3(ge3({}, i3), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i3 = 0; i3 < t; i3++) {
        const s = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s);
      }
    }
    this.events.emit($.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = ht2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => He3(ge3({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await Ni((0, import_time3.toMiliseconds)(import_time3.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return kc(e + await this.getClientId());
  }
};
var eo3 = Object.defineProperty;
var Ci2 = Object.getOwnPropertySymbols;
var to3 = Object.prototype.hasOwnProperty;
var io3 = Object.prototype.propertyIsEnumerable;
var Ye3 = (r2, e, t) => e in r2 ? eo3(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Pi4 = (r2, e) => {
  for (var t in e || (e = {})) to3.call(e, t) && Ye3(r2, t, e[t]);
  if (Ci2) for (var t of Ci2(e)) io3.call(e, t) && Ye3(r2, t, e[t]);
  return r2;
};
var y3 = (r2, e, t) => Ye3(r2, typeof e != "symbol" ? e + "" : e, t);
var Si2 = class extends d {
  constructor(e) {
    super(e), y3(this, "protocol", "wc"), y3(this, "version", 2), y3(this, "core"), y3(this, "logger"), y3(this, "events", new import_events4.EventEmitter()), y3(this, "provider"), y3(this, "messages"), y3(this, "subscriber"), y3(this, "publisher"), y3(this, "name", $t3), y3(this, "transportExplicitlyClosed", false), y3(this, "initialized", false), y3(this, "connectionAttemptInProgress", false), y3(this, "relayUrl"), y3(this, "projectId"), y3(this, "packageName"), y3(this, "bundleId"), y3(this, "hasExperiencedNetworkDisruption", false), y3(this, "pingTimeout"), y3(this, "heartBeatTimeout", (0, import_time3.toMiliseconds)(import_time3.THIRTY_SECONDS + import_time3.FIVE_SECONDS)), y3(this, "reconnectTimeout"), y3(this, "connectPromise"), y3(this, "reconnectInProgress", false), y3(this, "requestsInFlight", []), y3(this, "connectTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), y3(this, "request", async (t) => {
      var i3, s;
      this.logger.debug("Publishing Request Payload");
      const n2 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n2, method: t.method, topic: (i3 = t.params) == null ? void 0 : i3.topic }, "relayer.request - publishing...");
        const o2 = `${n2}:${((s = t.params) == null ? void 0 : s.tag) || ""}`;
        this.requestsInFlight.push(o2);
        const a2 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c3) => c3 !== o2), a2;
      } catch (o2) {
        throw this.logger.debug(`Failed to Publish Request: ${n2}`), o2;
      }
    }), y3(this, "resetPingTimeout", () => {
      _e2() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t, i3, s, n2;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n2 = (s = (i3 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : i3.socket) == null ? void 0 : s.terminate) == null || n2.call(s);
        } catch (o2) {
          this.logger.warn(o2, o2?.message);
        }
      }, this.heartBeatTimeout));
    }), y3(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), y3(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected 🛜"), this.startPingTimeout(), this.events.emit(C2.connect);
    }), y3(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected 🛑"), this.requestsInFlight = [], this.onProviderDisconnect();
    }), y3(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(C2.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), y3(this, "registerProviderListeners", () => {
      this.provider.on(L.payload, this.onPayloadHandler), this.provider.on(L.connect, this.onConnectHandler), this.provider.on(L.disconnect, this.onDisconnectHandler), this.provider.on(L.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || Nt3 })), this.messages = new _i2(this.logger, e.core), this.subscriber = new Ti2(this, this.logger), this.publisher = new qn2(this, this.logger), this.relayUrl = e?.relayUrl || Ue2, this.projectId = e.projectId, ei() ? this.packageName = ri() : ni() && (this.bundleId = ri()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.hasAnyTopics) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e, e?.message);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, i3;
    return ((i3 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i3.readyState) === 1 || false;
  }
  get connecting() {
    var e, t, i3;
    return ((i3 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i3.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e, t, i3) {
    this.isInitialized(), await this.publisher.publish(e, t, i3), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: Q2.relay }, le3.outbound);
  }
  async subscribe(e, t) {
    var i3, s, n2;
    this.isInitialized(), (!(t != null && t.transportType) || t?.transportType === "relay") && await this.toEstablishConnection();
    const o2 = typeof ((i3 = t?.internal) == null ? void 0 : i3.throwOnFailedPublish) > "u" ? true : (s = t?.internal) == null ? void 0 : s.throwOnFailedPublish;
    let a2 = ((n2 = this.subscriber.topicMap.get(e)) == null ? void 0 : n2[0]) || "", c3;
    const h5 = (l4) => {
      l4.topic === e && (this.subscriber.off($.created, h5), c3());
    };
    return await Promise.all([new Promise((l4) => {
      c3 = l4, this.subscriber.on($.created, h5);
    }), new Promise(async (l4, d4) => {
      a2 = await this.subscriber.subscribe(e, Pi4({ internal: { throwOnFailedPublish: o2 } }, t)).catch((g2) => {
        o2 && d4(g2);
      }) || a2, l4();
    })]), a2;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await yi(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, i3) => {
      await this.connect(e).then(t).catch(i3).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Na()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if (e?.length === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((i3, s) => i3.publishedAt - s.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const i3 of t) try {
      await this.onMessageEvent(i3);
    } catch (s) {
      this.logger.warn(s, "Error while processing batch message event: " + s?.message);
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: i3 } = e;
    if (!t.sessionExists) {
      const s = Ei(import_time3.FIVE_MINUTES), n2 = { topic: i3, expiry: s, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(i3, n2);
    }
    this.events.emit(C2.message, e), await this.recordMessageEvent(e, le3.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (i3, s) => {
          const n2 = () => {
            s(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(L.disconnect, n2), await yi(new Promise((o2, a2) => {
            this.provider.connect().then(o2).catch(a2);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o2) => {
            s(o2);
          }).finally(() => {
            this.provider.off(L.disconnect, n2), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o2, a2) => {
            const c3 = () => {
              a2(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L.disconnect, c3), await this.subscriber.start().then(o2).catch(a2).finally(() => {
              this.provider.off(L.disconnect, c3);
            });
          }), this.hasExperiencedNetworkDisruption = false, i3();
        });
      } catch (i3) {
        await this.subscriber.stop();
        const s = i3;
        this.logger.warn({}, s.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((i3) => setTimeout(i3, (0, import_time3.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, i3, s, n2;
    if (_e2()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((n2 = (s = (i3 = this.provider) == null ? void 0 : i3.connection) == null ? void 0 : s.socket) == null || n2.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o2) {
      this.logger.warn(o2, o2?.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o(new f5(si({ sdkVersion: _e3, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e, t) {
    const { topic: i3, message: s } = e;
    await this.messages.set(i3, s, t);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    if (!i3 || i3.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${i3}`), true;
    if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), true;
    const s = this.messages.has(t, i3);
    return s && this.logger.warn(`Ignoring duplicate message: ${i3}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(zt2)) return;
      const t = e.params, { topic: i3, message: s, publishedAt: n2, attestation: o2 } = t.data, a2 = { topic: i3, message: s, publishedAt: n2, transportType: Q2.relay, attestation: o2 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Pi4({ type: "event", event: t.id }, a2)), this.events.emit(t.id, a2), await this.acknowledgePayload(e), await this.onMessageEvent(a2);
    } else isJsonRpcResponse(e) && this.events.emit(C2.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, le3.inbound), this.events.emit(C2.message, e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(L.payload, this.onPayloadHandler), this.provider.off(L.connect, this.onConnectHandler), this.provider.off(L.disconnect, this.onDisconnectHandler), this.provider.off(L.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await Na();
    Ua(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((i3) => this.logger.error(i3, i3?.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    }), this.core.heartbeat.on(r.pulse, async () => {
      if (!this.transportExplicitlyClosed && !this.connected && Ta()) try {
        await this.confirmOnlineStateOrThrow(), await this.transportOpen();
      } catch (t) {
        this.logger.warn(t, t?.message);
      }
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(C2.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e, e?.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time3.toMiliseconds)(Lt3)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
};
function so3() {
}
function Oi2(r2) {
  if (!r2 || typeof r2 != "object") return false;
  const e = Object.getPrototypeOf(r2);
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r2) === "[object Object]" : false;
}
function Ri2(r2) {
  return Object.getOwnPropertySymbols(r2).filter((e) => Object.prototype.propertyIsEnumerable.call(r2, e));
}
function Ai2(r2) {
  return r2 == null ? r2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r2);
}
var ro3 = "[object RegExp]";
var no3 = "[object String]";
var oo3 = "[object Number]";
var ao3 = "[object Boolean]";
var xi2 = "[object Arguments]";
var co3 = "[object Symbol]";
var ho3 = "[object Date]";
var lo3 = "[object Map]";
var uo3 = "[object Set]";
var go3 = "[object Array]";
var po3 = "[object Function]";
var yo3 = "[object ArrayBuffer]";
var Je3 = "[object Object]";
var bo3 = "[object Error]";
var mo3 = "[object DataView]";
var fo3 = "[object Uint8Array]";
var Do2 = "[object Uint8ClampedArray]";
var vo3 = "[object Uint16Array]";
var wo3 = "[object Uint32Array]";
var _o3 = "[object BigUint64Array]";
var Eo3 = "[object Int8Array]";
var Io3 = "[object Int16Array]";
var To3 = "[object Int32Array]";
var Co3 = "[object BigInt64Array]";
var Po3 = "[object Float32Array]";
var So3 = "[object Float64Array]";
function Oo3(r2, e) {
  return r2 === e || Number.isNaN(r2) && Number.isNaN(e);
}
function Ro3(r2, e, t) {
  return pe3(r2, e, void 0, void 0, void 0, void 0, t);
}
function pe3(r2, e, t, i3, s, n2, o2) {
  const a2 = o2(r2, e, t, i3, s, n2);
  if (a2 !== void 0) return a2;
  if (typeof r2 == typeof e) switch (typeof r2) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r2 === e;
    case "number":
      return r2 === e || Object.is(r2, e);
    case "function":
      return r2 === e;
    case "object":
      return ye3(r2, e, n2, o2);
  }
  return ye3(r2, e, n2, o2);
}
function ye3(r2, e, t, i3) {
  if (Object.is(r2, e)) return true;
  let s = Ai2(r2), n2 = Ai2(e);
  if (s === xi2 && (s = Je3), n2 === xi2 && (n2 = Je3), s !== n2) return false;
  switch (s) {
    case no3:
      return r2.toString() === e.toString();
    case oo3: {
      const c3 = r2.valueOf(), h5 = e.valueOf();
      return Oo3(c3, h5);
    }
    case ao3:
    case ho3:
    case co3:
      return Object.is(r2.valueOf(), e.valueOf());
    case ro3:
      return r2.source === e.source && r2.flags === e.flags;
    case po3:
      return r2 === e;
  }
  t = t ?? /* @__PURE__ */ new Map();
  const o2 = t.get(r2), a2 = t.get(e);
  if (o2 != null && a2 != null) return o2 === e;
  t.set(r2, e), t.set(e, r2);
  try {
    switch (s) {
      case lo3: {
        if (r2.size !== e.size) return false;
        for (const [c3, h5] of r2.entries()) if (!e.has(c3) || !pe3(h5, e.get(c3), c3, r2, e, t, i3)) return false;
        return true;
      }
      case uo3: {
        if (r2.size !== e.size) return false;
        const c3 = Array.from(r2.values()), h5 = Array.from(e.values());
        for (let l4 = 0; l4 < c3.length; l4++) {
          const d4 = c3[l4], g2 = h5.findIndex((_) => pe3(d4, _, void 0, r2, e, t, i3));
          if (g2 === -1) return false;
          h5.splice(g2, 1);
        }
        return true;
      }
      case go3:
      case fo3:
      case Do2:
      case vo3:
      case wo3:
      case _o3:
      case Eo3:
      case Io3:
      case To3:
      case Co3:
      case Po3:
      case So3: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r2) !== Buffer.isBuffer(e) || r2.length !== e.length) return false;
        for (let c3 = 0; c3 < r2.length; c3++) if (!pe3(r2[c3], e[c3], c3, r2, e, t, i3)) return false;
        return true;
      }
      case yo3:
        return r2.byteLength !== e.byteLength ? false : ye3(new Uint8Array(r2), new Uint8Array(e), t, i3);
      case mo3:
        return r2.byteLength !== e.byteLength || r2.byteOffset !== e.byteOffset ? false : ye3(new Uint8Array(r2), new Uint8Array(e), t, i3);
      case bo3:
        return r2.name === e.name && r2.message === e.message;
      case Je3: {
        if (!(ye3(r2.constructor, e.constructor, t, i3) || Oi2(r2) && Oi2(e))) return false;
        const h5 = [...Object.keys(r2), ...Ri2(r2)], l4 = [...Object.keys(e), ...Ri2(e)];
        if (h5.length !== l4.length) return false;
        for (let d4 = 0; d4 < h5.length; d4++) {
          const g2 = h5[d4], _ = r2[g2];
          if (!Object.hasOwn(e, g2)) return false;
          const u3 = e[g2];
          if (!pe3(_, u3, g2, r2, e, t, i3)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t.delete(r2), t.delete(e);
  }
}
function Ao3(r2, e) {
  return Ro3(r2, e, so3);
}
var xo3 = Object.defineProperty;
var Ni2 = Object.getOwnPropertySymbols;
var No3 = Object.prototype.hasOwnProperty;
var $o3 = Object.prototype.propertyIsEnumerable;
var Xe3 = (r2, e, t) => e in r2 ? xo3(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var $i2 = (r2, e) => {
  for (var t in e || (e = {})) No3.call(e, t) && Xe3(r2, t, e[t]);
  if (Ni2) for (var t of Ni2(e)) $o3.call(e, t) && Xe3(r2, t, e[t]);
  return r2;
};
var z = (r2, e, t) => Xe3(r2, typeof e != "symbol" ? e + "" : e, t);
var zi2 = class extends f2 {
  constructor(e, t, i3, s = B, n2 = void 0) {
    super(e, t, i3, s), this.core = e, this.logger = t, this.name = i3, z(this, "map", /* @__PURE__ */ new Map()), z(this, "version", kt3), z(this, "cached", []), z(this, "initialized", false), z(this, "getKey"), z(this, "storagePrefix", B), z(this, "recentlyDeleted", []), z(this, "recentlyDeletedLimit", 200), z(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o2) => {
        this.getKey && o2 !== null && !Et2(o2) ? this.map.set(this.getKey(o2), o2) : la(o2) ? this.map.set(o2.id, o2) : da(o2) && this.map.set(o2.topic, o2);
      }), this.cached = [], this.initialized = true);
    }), z(this, "set", async (o2, a2) => {
      this.isInitialized(), this.map.has(o2) ? await this.update(o2, a2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o2, value: a2 }), this.map.set(o2, a2), await this.persist());
    }), z(this, "get", (o2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o2 }), this.getData(o2))), z(this, "getAll", (o2) => (this.isInitialized(), o2 ? this.values.filter((a2) => Object.keys(o2).every((c3) => Ao3(a2[c3], o2[c3]))) : this.values)), z(this, "update", async (o2, a2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o2, update: a2 });
      const c3 = $i2($i2({}, this.getData(o2)), a2);
      this.map.set(o2, c3), await this.persist();
    }), z(this, "delete", async (o2, a2) => {
      this.isInitialized(), this.map.has(o2) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o2, reason: a2 }), this.map.delete(o2), this.addToRecentlyDeleted(o2), await this.persist());
    }), this.logger = E(t, this.name), this.storagePrefix = s, this.getKey = n2;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: s } = ht2("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(s), new Error(s);
      }
      const { message: i3 } = ht2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = ht2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var zo2 = Object.defineProperty;
var Lo3 = (r2, e, t) => e in r2 ? zo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var p2 = (r2, e, t) => Lo3(r2, typeof e != "symbol" ? e + "" : e, t);
var Li2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, p2(this, "name", Mt3), p2(this, "version", Kt3), p2(this, "events", new import_events4.default()), p2(this, "pairings"), p2(this, "initialized", false), p2(this, "storagePrefix", B), p2(this, "ignoredPayloadTypes", [Ft2]), p2(this, "registeredMethods", []), p2(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), p2(this, "register", ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }), p2(this, "create", async (i3) => {
      this.isInitialized();
      const s = jc(), n2 = await this.core.crypto.setSymKey(s), o2 = Ei(import_time3.FIVE_MINUTES), a2 = { protocol: xt3 }, c3 = { topic: n2, expiry: o2, relay: a2, active: false, methods: i3?.methods }, h5 = Wc({ protocol: this.core.protocol, version: this.core.version, topic: n2, symKey: s, relay: a2, expiryTimestamp: o2, methods: i3?.methods });
      return this.events.emit(re2.create, c3), this.core.expirer.set(n2, o2), await this.pairings.set(n2, c3), await this.core.relayer.subscribe(n2, { transportType: i3?.transportType }), { topic: n2, uri: h5 };
    }), p2(this, "pair", async (i3) => {
      this.isInitialized();
      const s = this.core.eventClient.createEvent({ properties: { topic: i3?.uri, trace: [G3.pairing_started] } });
      this.isValidPair(i3, s);
      const { topic: n2, symKey: o2, relay: a2, expiryTimestamp: c3, methods: h5 } = Gc(i3.uri);
      s.props.properties.topic = n2, s.addTrace(G3.pairing_uri_validation_success), s.addTrace(G3.pairing_uri_not_expired);
      let l4;
      if (this.pairings.keys.includes(n2)) {
        if (l4 = this.pairings.get(n2), s.addTrace(G3.existing_pairing), l4.active) throw s.setError(Y2.active_pairing_already_exists), new Error(`Pairing already exists: ${n2}. Please try again with a new connection URI.`);
        s.addTrace(G3.pairing_not_expired);
      }
      const d4 = c3 || Ei(import_time3.FIVE_MINUTES), g2 = { topic: n2, relay: a2, expiry: d4, active: false, methods: h5 };
      this.core.expirer.set(n2, d4), await this.pairings.set(n2, g2), s.addTrace(G3.store_new_pairing), i3.activatePairing && await this.activate({ topic: n2 }), this.events.emit(re2.create, g2), s.addTrace(G3.emit_inactive_pairing), this.core.crypto.keychain.has(n2) || await this.core.crypto.setSymKey(o2, n2), s.addTrace(G3.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s.setError(Y2.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n2, { relay: a2 });
      } catch (_) {
        throw s.setError(Y2.subscribe_pairing_topic_failure), _;
      }
      return s.addTrace(G3.subscribe_pairing_topic_success), g2;
    }), p2(this, "activate", async ({ topic: i3 }) => {
      this.isInitialized();
      const s = Ei(import_time3.FIVE_MINUTES);
      this.core.expirer.set(i3, s), await this.pairings.update(i3, { active: true, expiry: s });
    }), p2(this, "ping", async (i3) => {
      this.isInitialized(), await this.isValidPing(i3), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s } = i3;
      if (this.pairings.keys.includes(s)) {
        const n2 = await this.sendRequest(s, "wc_pairingPing", {}), { done: o2, resolve: a2, reject: c3 } = gi();
        this.events.once(xi("pairing_ping", n2), ({ error: h5 }) => {
          h5 ? c3(h5) : a2();
        }), await o2();
      }
    }), p2(this, "updateExpiry", async ({ topic: i3, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s });
    }), p2(this, "updateMetadata", async ({ topic: i3, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s });
    }), p2(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), p2(this, "disconnect", async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s } = i3;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", Nt2("USER_DISCONNECTED")), await this.deletePairing(s));
    }), p2(this, "formatUriFromPairing", (i3) => {
      this.isInitialized();
      const { topic: s, relay: n2, expiry: o2, methods: a2 } = i3, c3 = this.core.crypto.keychain.get(s);
      return Wc({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: c3, relay: n2, expiryTimestamp: o2, methods: a2 });
    }), p2(this, "sendRequest", async (i3, s, n2) => {
      const o2 = formatJsonRpcRequest(s, n2), a2 = await this.core.crypto.encode(i3, o2), c3 = se2[s].req;
      return this.core.history.set(i3, o2), this.core.relayer.publish(i3, a2, c3), o2.id;
    }), p2(this, "sendResult", async (i3, s, n2) => {
      const o2 = formatJsonRpcResult(i3, n2), a2 = await this.core.crypto.encode(s, o2), c3 = (await this.core.history.get(s, i3)).request.method, h5 = se2[c3].res;
      await this.core.relayer.publish(s, a2, h5), await this.core.history.resolve(o2);
    }), p2(this, "sendError", async (i3, s, n2) => {
      const o2 = formatJsonRpcError(i3, n2), a2 = await this.core.crypto.encode(s, o2), c3 = (await this.core.history.get(s, i3)).request.method, h5 = se2[c3] ? se2[c3].res : se2.unregistered_method.res;
      await this.core.relayer.publish(s, a2, h5), await this.core.history.resolve(o2);
    }), p2(this, "deletePairing", async (i3, s) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, Nt2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s ? Promise.resolve() : this.core.expirer.del(i3)]);
    }), p2(this, "cleanup", async () => {
      const i3 = this.pairings.getAll().filter((s) => vi(s.expiry));
      await Promise.all(i3.map((s) => this.deletePairing(s.topic)));
    }), p2(this, "onRelayEventRequest", async (i3) => {
      const { topic: s, payload: n2 } = i3;
      switch (n2.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s, n2);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s, n2);
        default:
          return await this.onUnknownRpcMethodRequest(s, n2);
      }
    }), p2(this, "onRelayEventResponse", async (i3) => {
      const { topic: s, payload: n2 } = i3, o2 = (await this.core.history.get(s, n2.id)).request.method;
      switch (o2) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, n2);
        default:
          return this.onUnknownRpcMethodResponse(o2);
      }
    }), p2(this, "onPairingPingRequest", async (i3, s) => {
      const { id: n2 } = s;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(n2, i3, true), this.events.emit(re2.ping, { id: n2, topic: i3 });
      } catch (o2) {
        await this.sendError(n2, i3, o2), this.logger.error(o2);
      }
    }), p2(this, "onPairingPingResponse", (i3, s) => {
      const { id: n2 } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(xi("pairing_ping", n2), {}) : isJsonRpcError(s) && this.events.emit(xi("pairing_ping", n2), { error: s.error });
      }, 500);
    }), p2(this, "onPairingDeleteRequest", async (i3, s) => {
      const { id: n2 } = s;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit(re2.delete, { id: n2, topic: i3 });
      } catch (o2) {
        await this.sendError(n2, i3, o2), this.logger.error(o2);
      }
    }), p2(this, "onUnknownRpcMethodRequest", async (i3, s) => {
      const { id: n2, method: o2 } = s;
      try {
        if (this.registeredMethods.includes(o2)) return;
        const a2 = Nt2("WC_METHOD_UNSUPPORTED", o2);
        await this.sendError(n2, i3, a2), this.logger.error(a2);
      } catch (a2) {
        await this.sendError(n2, i3, a2), this.logger.error(a2);
      }
    }), p2(this, "onUnknownRpcMethodResponse", (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(Nt2("WC_METHOD_UNSUPPORTED", i3));
    }), p2(this, "isValidPair", (i3, s) => {
      var n2;
      if (!ma(i3)) {
        const { message: a2 } = ht2("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw s.setError(Y2.malformed_pairing_uri), new Error(a2);
      }
      if (!fa(i3.uri)) {
        const { message: a2 } = ht2("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw s.setError(Y2.malformed_pairing_uri), new Error(a2);
      }
      const o2 = Gc(i3?.uri);
      if (!((n2 = o2?.relay) != null && n2.protocol)) {
        const { message: a2 } = ht2("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s.setError(Y2.malformed_pairing_uri), new Error(a2);
      }
      if (!(o2 != null && o2.symKey)) {
        const { message: a2 } = ht2("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s.setError(Y2.malformed_pairing_uri), new Error(a2);
      }
      if (o2 != null && o2.expiryTimestamp && (0, import_time3.toMiliseconds)(o2?.expiryTimestamp) < Date.now()) {
        s.setError(Y2.pairing_expired);
        const { message: a2 } = ht2("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a2);
      }
    }), p2(this, "isValidPing", async (i3) => {
      if (!ma(i3)) {
        const { message: n2 } = ht2("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(n2);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }), p2(this, "isValidDisconnect", async (i3) => {
      if (!ma(i3)) {
        const { message: n2 } = ht2("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(n2);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }), p2(this, "isValidPairingTopic", async (i3) => {
      if (!nt2(i3, false)) {
        const { message: s } = ht2("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s } = ht2("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s);
      }
      if (vi(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s } = ht2("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s);
      }
    }), this.core = e, this.logger = E(t, this.name), this.pairings = new zi2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(C2.message, async (e) => {
      const { topic: t, message: i3, transportType: s } = e;
      if (this.pairings.keys.includes(t) && s !== Q2.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3))) try {
        const n2 = await this.core.crypto.decode(t, i3);
        isJsonRpcRequest(n2) ? (this.core.history.set(t, n2), await this.onRelayEventRequest({ topic: t, payload: n2 })) : isJsonRpcResponse(n2) && (await this.core.history.resolve(n2), await this.onRelayEventResponse({ topic: t, payload: n2 }), this.core.history.delete(t, n2.id)), await this.core.relayer.messages.ack(t, i3);
      } catch (n2) {
        this.logger.error(n2);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M3.expired, async (e) => {
      const { topic: t } = bi(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(re2.expire, { topic: t }));
    });
  }
};
var ko2 = Object.defineProperty;
var jo2 = (r2, e, t) => e in r2 ? ko2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var O2 = (r2, e, t) => jo2(r2, typeof e != "symbol" ? e + "" : e, t);
var ki2 = class extends I {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, O2(this, "records", /* @__PURE__ */ new Map()), O2(this, "events", new import_events4.EventEmitter()), O2(this, "name", Bt3), O2(this, "version", Vt3), O2(this, "cached", []), O2(this, "initialized", false), O2(this, "storagePrefix", B), O2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), O2(this, "set", (i3, s, n2) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s, chainId: n2 }), this.records.has(s.id)) return;
      const o2 = { id: s.id, topic: i3, request: { method: s.method, params: s.params || null }, chainId: n2, expiry: Ei(import_time3.THIRTY_DAYS) };
      this.records.set(o2.id, o2), this.persist(), this.events.emit(F2.created, o2);
    }), O2(this, "resolve", async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id)) return;
      const s = await this.getRecord(i3.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s.id, s), this.persist(), this.events.emit(F2.updated, s));
    }), O2(this, "get", async (i3, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s }), await this.getRecord(s))), O2(this, "delete", (i3, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((n2) => {
        if (n2.topic === i3) {
          if (typeof s < "u" && n2.id !== s) return;
          this.records.delete(n2.id), this.events.emit(F2.deleted, n2);
        }
      }), this.persist();
    }), O2(this, "exists", async (i3, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i3 : false)), O2(this, "on", (i3, s) => {
      this.events.on(i3, s);
    }), O2(this, "once", (i3, s) => {
      this.events.once(i3, s);
    }), O2(this, "off", (i3, s) => {
      this.events.off(i3, s);
    }), O2(this, "removeListener", (i3, s) => {
      this.events.removeListener(i3, s);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const i3 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i3);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i3 } = ht2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = ht2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(F2.created, (e) => {
      const t = F2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F2.updated, (e) => {
      const t = F2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F2.deleted, (e) => {
      const t = F2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time3.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(F2.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Uo3 = Object.defineProperty;
var Fo2 = (r2, e, t) => e in r2 ? Uo3(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var A2 = (r2, e, t) => Fo2(r2, typeof e != "symbol" ? e + "" : e, t);
var ji2 = class extends S {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, A2(this, "expirations", /* @__PURE__ */ new Map()), A2(this, "events", new import_events4.EventEmitter()), A2(this, "name", qt3), A2(this, "version", Gt2), A2(this, "cached", []), A2(this, "initialized", false), A2(this, "storagePrefix", B), A2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), A2(this, "has", (i3) => {
      try {
        const s = this.formatTarget(i3);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }), A2(this, "set", (i3, s) => {
      this.isInitialized();
      const n2 = this.formatTarget(i3), o2 = { target: n2, expiry: s };
      this.expirations.set(n2, o2), this.checkExpiry(n2, o2), this.events.emit(M3.created, { target: n2, expiration: o2 });
    }), A2(this, "get", (i3) => {
      this.isInitialized();
      const s = this.formatTarget(i3);
      return this.getExpiration(s);
    }), A2(this, "del", (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s = this.formatTarget(i3), n2 = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(M3.deleted, { target: s, expiration: n2 });
      }
    }), A2(this, "on", (i3, s) => {
      this.events.on(i3, s);
    }), A2(this, "once", (i3, s) => {
      this.events.once(i3, s);
    }), A2(this, "off", (i3, s) => {
      this.events.off(i3, s);
    }), A2(this, "removeListener", (i3, s) => {
      this.events.removeListener(i3, s);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return mi(e);
    if (typeof e == "number") return wi(e);
    const { message: t } = ht2("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M3.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = ht2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i3 } = ht2("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(i3), new Error(i3);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i3 } = t;
    (0, import_time3.toMiliseconds)(i3) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(M3.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(M3.created, (e) => {
      const t = M3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M3.expired, (e) => {
      const t = M3.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M3.deleted, (e) => {
      const t = M3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht2("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Mo2 = Object.defineProperty;
var Ko2 = (r2, e, t) => e in r2 ? Mo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var w2 = (r2, e, t) => Ko2(r2, typeof e != "symbol" ? e + "" : e, t);
var Ui2 = class extends M {
  constructor(e, t, i3) {
    super(e, t, i3), this.core = e, this.logger = t, this.store = i3, w2(this, "name", Wt3), w2(this, "abortController"), w2(this, "isDevEnv"), w2(this, "verifyUrlV3", Yt3), w2(this, "storagePrefix", B), w2(this, "version", Le2), w2(this, "publicKey"), w2(this, "fetchPromise"), w2(this, "init", async () => {
      var s;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time3.toMiliseconds)((s = this.publicKey) == null ? void 0 : s.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), w2(this, "register", async (s) => {
      if (!Tt2() || this.isDevEnv) return;
      const n2 = window.location.origin, { id: o2, decryptedId: a2 } = s, c3 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n2}&id=${o2}&decryptedId=${a2}`;
      try {
        const h5 = (0, import_window_getters2.getDocument)(), l4 = this.startAbortTimer(import_time3.ONE_SECOND * 5), d4 = await new Promise((g2, _) => {
          const u3 = () => {
            window.removeEventListener("message", x3), h5.body.removeChild(b5), _("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u3);
          const b5 = h5.createElement("iframe");
          b5.src = c3, b5.style.display = "none", b5.addEventListener("error", u3, { signal: this.abortController.signal });
          const x3 = (I3) => {
            if (I3.data && typeof I3.data == "string") try {
              const D2 = JSON.parse(I3.data);
              if (D2.type === "verify_attestation") {
                if (sn(D2.attestation).payload.id !== o2) return;
                clearInterval(l4), h5.body.removeChild(b5), this.abortController.signal.removeEventListener("abort", u3), window.removeEventListener("message", x3), g2(D2.attestation === null ? "" : D2.attestation);
              }
            } catch (D2) {
              this.logger.warn(D2);
            }
          };
          h5.body.appendChild(b5), window.addEventListener("message", x3, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", d4), d4;
      } catch (h5) {
        this.logger.warn(h5);
      }
      return "";
    }), w2(this, "resolve", async (s) => {
      if (this.isDevEnv) return "";
      const { attestationId: n2, hash: o2, encryptedId: a2 } = s;
      if (n2 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n2) {
        if (sn(n2).payload.id !== a2) return;
        const h5 = await this.isValidJwtAttestation(n2);
        if (h5) {
          if (!h5.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h5;
        }
      }
      if (!o2) return;
      const c3 = this.getVerifyUrl(s?.verifyUrl);
      return this.fetchAttestation(o2, c3);
    }), w2(this, "fetchAttestation", async (s, n2) => {
      this.logger.debug(`resolving attestation: ${s} from url: ${n2}`);
      const o2 = this.startAbortTimer(import_time3.ONE_SECOND * 5), a2 = await fetch(`${n2}/attestation/${s}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o2), a2.status === 200 ? await a2.json() : void 0;
    }), w2(this, "getVerifyUrl", (s) => {
      let n2 = s || ue2;
      return Jt3.includes(n2) || (this.logger.info(`verify url: ${n2}, not included in trusted list, assigning default: ${ue2}`), n2 = ue2), n2;
    }), w2(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s = this.startAbortTimer(import_time3.FIVE_SECONDS), n2 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s), await n2.json();
      } catch (s) {
        this.logger.warn(s);
      }
    }), w2(this, "persistPublicKey", async (s) => {
      this.logger.debug("persisting public key to local storage", s), await this.store.setItem(this.storeKey, s), this.publicKey = s;
    }), w2(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), w2(this, "isValidJwtAttestation", async (s) => {
      const n2 = await this.getPublicKey();
      try {
        if (n2) return this.validateAttestation(s, n2);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
      const o2 = await this.fetchAndPersistPublicKey();
      try {
        if (o2) return this.validateAttestation(s, o2);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
    }), w2(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), w2(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n2) => {
        const o2 = await this.fetchPublicKey();
        o2 && (await this.persistPublicKey(o2), n2(o2));
      });
      const s = await this.fetchPromise;
      return this.fetchPromise = void 0, s;
    }), w2(this, "validateAttestation", (s, n2) => {
      const o2 = zc(s, n2.publicKey), a2 = { hasExpired: (0, import_time3.toMiliseconds)(o2.exp) < Date.now(), payload: o2 };
      if (a2.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a2.payload.origin, isScam: a2.payload.isScam, isVerified: a2.payload.isVerified };
    }), this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Ii(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time3.toMiliseconds)(e));
  }
};
var Bo3 = Object.defineProperty;
var Vo2 = (r2, e, t) => e in r2 ? Bo3(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Fi2 = (r2, e, t) => Vo2(r2, typeof e != "symbol" ? e + "" : e, t);
var Mi2 = class extends O {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, Fi2(this, "context", Xt3), Fi2(this, "registerDeviceToken", async (i3) => {
      const { clientId: s, token: n2, notificationType: o2, enableEncrypted: a2 = false } = i3, c3 = `${Zt2}/${this.projectId}/clients`;
      await fetch(c3, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s, type: o2, token: n2, always_raw: a2 }) });
    }), this.logger = E(t, this.context);
  }
};
var qo2 = Object.defineProperty;
var Ki2 = Object.getOwnPropertySymbols;
var Go3 = Object.prototype.hasOwnProperty;
var Wo3 = Object.prototype.propertyIsEnumerable;
var Ze3 = (r2, e, t) => e in r2 ? qo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var be3 = (r2, e) => {
  for (var t in e || (e = {})) Go3.call(e, t) && Ze3(r2, t, e[t]);
  if (Ki2) for (var t of Ki2(e)) Wo3.call(e, t) && Ze3(r2, t, e[t]);
  return r2;
};
var E2 = (r2, e, t) => Ze3(r2, typeof e != "symbol" ? e + "" : e, t);
var Bi2 = class extends R {
  constructor(e, t, i3 = true) {
    super(e, t, i3), this.core = e, this.logger = t, E2(this, "context", ei2), E2(this, "storagePrefix", B), E2(this, "storageVersion", Qt3), E2(this, "events", /* @__PURE__ */ new Map()), E2(this, "shouldPersist", false), E2(this, "init", async () => {
      if (!Ii()) try {
        const s = { eventId: Bi(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Mn2(this.core.relayer.protocol, this.core.relayer.version, _e3) } } };
        await this.sendEvent([s]);
      } catch (s) {
        this.logger.warn(s);
      }
    }), E2(this, "createEvent", (s) => {
      const { event: n2 = "ERROR", type: o2 = "", properties: { topic: a2, trace: c3 } } = s, h5 = Bi(), l4 = this.core.projectId || "", d4 = Date.now(), g2 = be3({ eventId: h5, timestamp: d4, props: { event: n2, type: o2, properties: { topic: a2, trace: c3 } }, bundleId: l4, domain: this.getAppDomain() }, this.setMethods(h5));
      return this.telemetryEnabled && (this.events.set(h5, g2), this.shouldPersist = true), g2;
    }), E2(this, "getEvent", (s) => {
      const { eventId: n2, topic: o2 } = s;
      if (n2) return this.events.get(n2);
      const a2 = Array.from(this.events.values()).find((c3) => c3.props.properties.topic === o2);
      if (a2) return be3(be3({}, a2), this.setMethods(a2.eventId));
    }), E2(this, "deleteEvent", (s) => {
      const { eventId: n2 } = s;
      this.events.delete(n2), this.shouldPersist = true;
    }), E2(this, "setEventListeners", () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s) => {
          (0, import_time3.fromMiliseconds)(Date.now()) - (0, import_time3.fromMiliseconds)(s.timestamp) > ti && (this.events.delete(s.eventId), this.shouldPersist = true);
        });
      });
    }), E2(this, "setMethods", (s) => ({ addTrace: (n2) => this.addTrace(s, n2), setError: (n2) => this.setError(s, n2) })), E2(this, "addTrace", (s, n2) => {
      const o2 = this.events.get(s);
      o2 && (o2.props.properties.trace.push(n2), this.events.set(s, o2), this.shouldPersist = true);
    }), E2(this, "setError", (s, n2) => {
      const o2 = this.events.get(s);
      o2 && (o2.props.type = n2, o2.timestamp = Date.now(), this.events.set(s, o2), this.shouldPersist = true);
    }), E2(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E2(this, "restore", async () => {
      try {
        const s = await this.core.storage.getItem(this.storageKey) || [];
        if (!s.length) return;
        s.forEach((n2) => {
          this.events.set(n2.eventId, be3(be3({}, n2), this.setMethods(n2.eventId)));
        });
      } catch (s) {
        this.logger.warn(s);
      }
    }), E2(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const s = [];
      for (const [n2, o2] of this.events) o2.props.type && s.push(o2);
      if (s.length !== 0) try {
        if ((await this.sendEvent(s)).ok) for (const n2 of s) this.events.delete(n2.eventId), this.shouldPersist = true;
      } catch (n2) {
        this.logger.warn(n2);
      }
    }), E2(this, "sendEvent", async (s) => {
      const n2 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${ii}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${_e3}${n2}`, { method: "POST", body: JSON.stringify(s) });
    }), E2(this, "getAppDomain", () => Pn2().url), this.logger = E(t, this.context), this.telemetryEnabled = i3, i3 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Ho2 = Object.defineProperty;
var Vi2 = Object.getOwnPropertySymbols;
var Yo3 = Object.prototype.hasOwnProperty;
var Jo3 = Object.prototype.propertyIsEnumerable;
var Qe3 = (r2, e, t) => e in r2 ? Ho2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var qi2 = (r2, e) => {
  for (var t in e || (e = {})) Yo3.call(e, t) && Qe3(r2, t, e[t]);
  if (Vi2) for (var t of Vi2(e)) Jo3.call(e, t) && Qe3(r2, t, e[t]);
  return r2;
};
var v3 = (r2, e, t) => Qe3(r2, typeof e != "symbol" ? e + "" : e, t);
var Te2 = class _Te extends h2 {
  constructor(e) {
    var t;
    super(e), v3(this, "protocol", ze3), v3(this, "version", Le2), v3(this, "name", he3), v3(this, "relayUrl"), v3(this, "projectId"), v3(this, "customStoragePrefix"), v3(this, "events", new import_events4.EventEmitter()), v3(this, "logger"), v3(this, "heartbeat"), v3(this, "relayer"), v3(this, "crypto"), v3(this, "storage"), v3(this, "history"), v3(this, "expirer"), v3(this, "pairing"), v3(this, "verify"), v3(this, "echoClient"), v3(this, "linkModeSupportedApps"), v3(this, "eventClient"), v3(this, "initialized", false), v3(this, "logChunkController"), v3(this, "on", (a2, c3) => this.events.on(a2, c3)), v3(this, "once", (a2, c3) => this.events.once(a2, c3)), v3(this, "off", (a2, c3) => this.events.off(a2, c3)), v3(this, "removeListener", (a2, c3) => this.events.removeListener(a2, c3)), v3(this, "dispatchEnvelope", ({ topic: a2, message: c3, sessionExists: h5 }) => {
      if (!a2 || !c3) return;
      const l4 = { topic: a2, message: c3, publishedAt: Date.now(), transportType: Q2.link_mode };
      this.relayer.onLinkMessageEvent(l4, { sessionExists: h5 });
    });
    const i3 = this.getGlobalCore(e?.customStoragePrefix);
    if (i3) try {
      return this.customStoragePrefix = i3.customStoragePrefix, this.logger = i3.logger, this.heartbeat = i3.heartbeat, this.crypto = i3.crypto, this.history = i3.history, this.expirer = i3.expirer, this.storage = i3.storage, this.relayer = i3.relayer, this.pairing = i3.pairing, this.verify = i3.verify, this.echoClient = i3.echoClient, this.linkModeSupportedApps = i3.linkModeSupportedApps, this.eventClient = i3.eventClient, this.initialized = i3.initialized, this.logChunkController = i3.logChunkController, i3;
    } catch (a2) {
      console.warn("Failed to copy global core", a2);
    }
    this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || Ue2, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s = k({ level: typeof e?.logger == "string" && e.logger ? e.logger : Et3.logger, name: he3 }), { logger: n2, chunkLoggerController: o2 } = A({ opts: s, maxSizeInBytes: e?.maxLogBlobSizeInBytes, loggerOverride: e?.logger });
    this.logChunkController = o2, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a2, c3;
      (a2 = this.logChunkController) != null && a2.downloadLogsBlobInBrowser && ((c3 = this.logChunkController) == null || c3.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(n2, this.name), this.heartbeat = new i(), this.crypto = new vi2(this, this.logger, e?.keychain), this.history = new ki2(this, this.logger), this.expirer = new ji2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(qi2(qi2({}, It3), e?.storageOptions)), this.relayer = new Si2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Li2(this, this.logger), this.verify = new Ui2(this, this.logger, this.storage), this.echoClient = new Mi2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Bi2(this, this.logger, e?.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e) {
    const t = new _Te(e);
    await t.initialize();
    const i3 = await t.crypto.getClientId();
    return await t.storage.setItem(jt3, i3), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(Fe2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Fe2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
  getGlobalCore(e = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t = `_walletConnectCore_${e}`, i3 = `${t}_count`;
      return globalThis[i3] = (globalThis[i3] || 0) + 1, globalThis[i3] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i3]} times.`), globalThis[t];
    } catch (t) {
      console.warn("Failed to get global WalletConnect core", t);
      return;
    }
  }
  setGlobalCore(e) {
    var t;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const i3 = `_walletConnectCore_${((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
      globalThis[i3] = e;
    } catch (i3) {
      console.warn("Failed to set global WalletConnect core", i3);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return true;
    }
  }
};
var Xo2 = Te2;

// node_modules/@reown/appkit/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_time4 = __toESM(require_cjs());
var import_events5 = __toESM(require_events());
var De3 = "wc";
var Le3 = 2;
var ke4 = "client";
var we3 = `${De3}@${Le3}:${ke4}:`;
var me3 = { name: ke4, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var Me4 = "WALLETCONNECT_DEEPLINK_CHOICE";
var pt2 = "proposal";
var $e3 = "Proposal expired";
var ht3 = "session";
var J3 = import_time4.SEVEN_DAYS;
var dt3 = "engine";
var N2 = { wc_sessionPropose: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time4.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time4.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var _e4 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var $2 = { idle: "IDLE", active: "ACTIVE" };
var Ke4 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" } };
var ut3 = "request";
var gt3 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var yt3 = "wc";
var wt3 = "auth";
var mt2 = "authKeys";
var _t3 = "pairingTopics";
var Et4 = "requests";
var ae2 = `${yt3}@${1.5}:${wt3}:`;
var ce2 = `${ae2}:PUB_KEY`;
var vs2 = Object.defineProperty;
var Is2 = Object.defineProperties;
var Ts2 = Object.getOwnPropertyDescriptors;
var ft3 = Object.getOwnPropertySymbols;
var qs3 = Object.prototype.hasOwnProperty;
var Ps2 = Object.prototype.propertyIsEnumerable;
var Ue3 = (S4, n2, e) => n2 in S4 ? vs2(S4, n2, { enumerable: true, configurable: true, writable: true, value: e }) : S4[n2] = e;
var v4 = (S4, n2) => {
  for (var e in n2 || (n2 = {})) qs3.call(n2, e) && Ue3(S4, e, n2[e]);
  if (ft3) for (var e of ft3(n2)) Ps2.call(n2, e) && Ue3(S4, e, n2[e]);
  return S4;
};
var b3 = (S4, n2) => Is2(S4, Ts2(n2));
var c2 = (S4, n2, e) => Ue3(S4, typeof n2 != "symbol" ? n2 + "" : n2, e);
var Ns2 = class extends V {
  constructor(n2) {
    super(n2), c2(this, "name", dt3), c2(this, "events", new import_events5.default()), c2(this, "initialized", false), c2(this, "requestQueue", { state: $2.idle, queue: [] }), c2(this, "sessionRequestQueue", { state: $2.idle, queue: [] }), c2(this, "requestQueueDelay", import_time4.ONE_SECOND), c2(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c2(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c2(this, "recentlyDeletedLimit", 200), c2(this, "relayMessageCache", []), c2(this, "pendingSessions", /* @__PURE__ */ new Map()), c2(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N2) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay)));
    }), c2(this, "connect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = b3(v4({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(t), t.optionalNamespaces = aa(t.requiredNamespaces, t.optionalNamespaces), t.requiredNamespaces = {};
      const { pairingTopic: s, requiredNamespaces: i3, optionalNamespaces: r2, sessionProperties: o2, scopedProperties: a2, relays: l4 } = t;
      let p3 = s, h5, u3 = false;
      try {
        if (p3) {
          const T2 = this.client.core.pairing.pairings.get(p3);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u3 = T2.active;
        }
      } catch (T2) {
        throw this.client.logger.error(`connect() -> pairing.get(${p3}) failed`), T2;
      }
      if (!p3 || !u3) {
        const { topic: T2, uri: K4 } = await this.client.core.pairing.create();
        p3 = T2, h5 = K4;
      }
      if (!p3) {
        const { message: T2 } = ht2("NO_MATCHING_KEY", `connect() pairing topic: ${p3}`);
        throw new Error(T2);
      }
      const d4 = await this.client.core.crypto.generateKeyPair(), w3 = N2.wc_sessionPropose.req.ttl || import_time4.FIVE_MINUTES, m2 = Ei(w3), f7 = b3(v4(v4({ requiredNamespaces: i3, optionalNamespaces: r2, relays: l4 ?? [{ protocol: xt3 }], proposer: { publicKey: d4, metadata: this.client.metadata }, expiryTimestamp: m2, pairingTopic: p3 }, o2 && { sessionProperties: o2 }), a2 && { scopedProperties: a2 }), { id: payloadId() }), _ = xi("session_connect", f7.id), { reject: g2, resolve: A4, done: D2 } = gi(w3, $e3), I3 = ({ id: T2 }) => {
        T2 === f7.id && (this.client.events.off("proposal_expire", I3), this.pendingSessions.delete(f7.id), this.events.emit(_, { error: { message: $e3, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", I3), this.events.once(_, ({ error: T2, session: K4 }) => {
        this.client.events.off("proposal_expire", I3), T2 ? g2(T2) : K4 && A4(K4);
      }), await this.sendRequest({ topic: p3, method: "wc_sessionPropose", params: f7, throwOnFailedPublish: true, clientRpcId: f7.id }), await this.setProposal(f7.id, f7), { uri: h5, approval: D2 };
    }), c2(this, "pair", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }), c2(this, "approve", async (e) => {
      var t, s, i3;
      const r2 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e?.id) == null ? void 0 : t.toString(), trace: [er3.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (q3) {
        throw r2.setError(tr3.no_internet_connection), q3;
      }
      try {
        await this.isValidProposalId(e?.id);
      } catch (q3) {
        throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`), r2.setError(tr3.proposal_not_found), q3;
      }
      try {
        await this.isValidApprove(e);
      } catch (q3) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r2.setError(tr3.session_approve_namespace_validation_failure), q3;
      }
      const { id: o2, relayProtocol: a2, namespaces: l4, sessionProperties: p3, scopedProperties: h5, sessionConfig: u3 } = e, d4 = this.client.proposal.get(o2);
      this.client.core.eventClient.deleteEvent({ eventId: r2.eventId });
      const { pairingTopic: w3, proposer: m2, requiredNamespaces: f7, optionalNamespaces: _ } = d4;
      let g2 = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({ topic: w3 });
      g2 || (g2 = (i3 = this.client.core.eventClient) == null ? void 0 : i3.createEvent({ type: er3.session_approve_started, properties: { topic: w3, trace: [er3.session_approve_started, er3.session_namespaces_validation_success] } }));
      const A4 = await this.client.core.crypto.generateKeyPair(), D2 = m2.publicKey, I3 = await this.client.core.crypto.generateSharedKey(A4, D2), T2 = v4(v4(v4({ relay: { protocol: a2 ?? "irn" }, namespaces: l4, controller: { publicKey: A4, metadata: this.client.metadata }, expiry: Ei(J3) }, p3 && { sessionProperties: p3 }), h5 && { scopedProperties: h5 }), u3 && { sessionConfig: u3 }), K4 = Q2.relay;
      g2.addTrace(er3.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(I3, { transportType: K4 });
      } catch (q3) {
        throw g2.setError(tr3.subscribe_session_topic_failure), q3;
      }
      g2.addTrace(er3.subscribe_session_topic_success);
      const fe4 = b3(v4({}, T2), { topic: I3, requiredNamespaces: f7, optionalNamespaces: _, pairingTopic: w3, acknowledged: false, self: T2.controller, peer: { publicKey: m2.publicKey, metadata: m2.metadata }, controller: A4, transportType: Q2.relay });
      await this.client.session.set(I3, fe4), g2.addTrace(er3.store_session);
      try {
        g2.addTrace(er3.publishing_session_settle), await this.sendRequest({ topic: I3, method: "wc_sessionSettle", params: T2, throwOnFailedPublish: true }).catch((q3) => {
          throw g2?.setError(tr3.session_settle_publish_failure), q3;
        }), g2.addTrace(er3.session_settle_publish_success), g2.addTrace(er3.publishing_session_approve), await this.sendResult({ id: o2, topic: w3, result: { relay: { protocol: a2 ?? "irn" }, responderPublicKey: A4 }, throwOnFailedPublish: true }).catch((q3) => {
          throw g2?.setError(tr3.session_approve_publish_failure), q3;
        }), g2.addTrace(er3.session_approve_publish_success);
      } catch (q3) {
        throw this.client.logger.error(q3), this.client.session.delete(I3, Nt2("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(I3), q3;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: g2.eventId }), await this.client.core.pairing.updateMetadata({ topic: w3, metadata: m2.metadata }), await this.client.proposal.delete(o2, Nt2("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: w3 }), await this.setExpiry(I3, Ei(J3)), { topic: I3, acknowledged: () => Promise.resolve(this.client.session.get(I3)) };
    }), c2(this, "reject", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e);
      } catch (r2) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r2;
      }
      const { id: t, reason: s } = e;
      let i3;
      try {
        i3 = this.client.proposal.get(t).pairingTopic;
      } catch (r2) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r2;
      }
      i3 && (await this.sendError({ id: t, topic: i3, error: s, rpcOpts: N2.wc_sessionPropose.reject }), await this.client.proposal.delete(t, Nt2("USER_DISCONNECTED")));
    }), c2(this, "update", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e);
      } catch (h5) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h5;
      }
      const { topic: t, namespaces: s } = e, { done: i3, resolve: r2, reject: o2 } = gi(), a2 = payloadId(), l4 = getBigIntRpcId().toString(), p3 = this.client.session.get(t).namespaces;
      return this.events.once(xi("session_update", a2), ({ error: h5 }) => {
        h5 ? o2(h5) : r2();
      }), await this.client.session.update(t, { namespaces: s }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s }, throwOnFailedPublish: true, clientRpcId: a2, relayRpcId: l4 }).catch((h5) => {
        this.client.logger.error(h5), this.client.session.update(t, { namespaces: p3 }), o2(h5);
      }), { acknowledged: i3 };
    }), c2(this, "extend", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e);
      } catch (a2) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a2;
      }
      const { topic: t } = e, s = payloadId(), { done: i3, resolve: r2, reject: o2 } = gi();
      return this.events.once(xi("session_extend", s), ({ error: a2 }) => {
        a2 ? o2(a2) : r2();
      }), await this.setExpiry(t, Ei(J3)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s, throwOnFailedPublish: true }).catch((a2) => {
        o2(a2);
      }), { acknowledged: i3 };
    }), c2(this, "request", async (e) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e);
      } catch (_) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), _;
      }
      const { chainId: t, request: s, topic: i3, expiry: r2 = N2.wc_sessionRequest.req.ttl } = e, o2 = this.client.session.get(i3);
      o2?.transportType === Q2.relay && await this.confirmOnlineStateOrThrow();
      const a2 = payloadId(), l4 = getBigIntRpcId().toString(), { done: p3, resolve: h5, reject: u3 } = gi(r2, "Request expired. Please try again.");
      this.events.once(xi("session_request", a2), ({ error: _, result: g2 }) => {
        _ ? u3(_) : h5(g2);
      });
      const d4 = "wc_sessionRequest", w3 = this.getAppLinkIfEnabled(o2.peer.metadata, o2.transportType);
      if (w3) return await this.sendRequest({ clientRpcId: a2, relayRpcId: l4, topic: i3, method: d4, params: { request: b3(v4({}, s), { expiryTimestamp: Ei(r2) }), chainId: t }, expiry: r2, throwOnFailedPublish: true, appLink: w3 }).catch((_) => u3(_)), this.client.events.emit("session_request_sent", { topic: i3, request: s, chainId: t, id: a2 }), await p3();
      const m2 = { request: b3(v4({}, s), { expiryTimestamp: Ei(r2) }), chainId: t }, f7 = this.shouldSetTVF(d4, m2);
      return await Promise.all([new Promise(async (_) => {
        await this.sendRequest(v4({ clientRpcId: a2, relayRpcId: l4, topic: i3, method: d4, params: m2, expiry: r2, throwOnFailedPublish: true }, f7 && { tvf: this.getTVFParams(a2, m2) })).catch((g2) => u3(g2)), this.client.events.emit("session_request_sent", { topic: i3, request: s, chainId: t, id: a2 }), _();
      }), new Promise(async (_) => {
        var g2;
        if (!((g2 = o2.sessionConfig) != null && g2.disableDeepLink)) {
          const A4 = await Oi(this.client.core.storage, Me4);
          await Si({ id: a2, topic: i3, wcDeepLink: A4 });
        }
        _();
      }), p3()]).then((_) => _[2]);
    }), c2(this, "respond", async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: t, response: s } = e, { id: i3 } = s, r2 = this.client.session.get(t);
      r2.transportType === Q2.relay && await this.confirmOnlineStateOrThrow();
      const o2 = this.getAppLinkIfEnabled(r2.peer.metadata, r2.transportType);
      isJsonRpcResult(s) ? await this.sendResult({ id: i3, topic: t, result: s.result, throwOnFailedPublish: true, appLink: o2 }) : isJsonRpcError(s) && await this.sendError({ id: i3, topic: t, error: s.error, appLink: o2 }), this.cleanupAfterResponse(e);
    }), c2(this, "ping", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e);
      } catch (s) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s;
      }
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) {
        const s = payloadId(), i3 = getBigIntRpcId().toString(), { done: r2, resolve: o2, reject: a2 } = gi();
        this.events.once(xi("session_ping", s), ({ error: l4 }) => {
          l4 ? a2(l4) : o2();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s, relayRpcId: i3 }), r2()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: t }));
    }), c2(this, "emit", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
      const { topic: t, event: s, chainId: i3 } = e, r2 = getBigIntRpcId().toString(), o2 = payloadId();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s, chainId: i3 }, throwOnFailedPublish: true, relayRpcId: r2, clientRpcId: o2 });
    }), c2(this, "disconnect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: Nt2("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s } = ht2("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s);
      }
    }), c2(this, "find", (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => ua(t, e)))), c2(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c2(this, "authenticate", async (e, t) => {
      var s;
      this.isInitialized(), this.isValidAuthenticate(e);
      const i3 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode), r2 = i3 ? Q2.link_mode : Q2.relay;
      r2 === Q2.relay && await this.confirmOnlineStateOrThrow();
      const { chains: o2, statement: a2 = "", uri: l4, domain: p3, nonce: h5, type: u3, exp: d4, nbf: w3, methods: m2 = [], expiry: f7 } = e, _ = [...e.resources || []], { topic: g2, uri: A4 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r2 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: g2, uri: A4 } });
      const D2 = await this.client.core.crypto.generateKeyPair(), I3 = Pc(D2);
      if (await Promise.all([this.client.auth.authKeys.set(ce2, { responseTopic: I3, publicKey: D2 }), this.client.auth.pairingTopics.set(I3, { topic: I3, pairingTopic: g2 })]), await this.client.core.relayer.subscribe(I3, { transportType: r2 }), this.client.logger.info(`sending request to new pairing topic: ${g2}`), m2.length > 0) {
        const { namespace: x3 } = Ne2(o2[0]);
        let L3 = fs(x3, "request", m2);
        pe2(_) && (L3 = ls(L3, _.pop())), _.push(L3);
      }
      const T2 = f7 && f7 > N2.wc_sessionAuthenticate.req.ttl ? f7 : N2.wc_sessionAuthenticate.req.ttl, K4 = { authPayload: { type: u3 ?? "caip122", chains: o2, statement: a2, aud: l4, domain: p3, version: "1", nonce: h5, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d4, nbf: w3, resources: _ }, requester: { publicKey: D2, metadata: this.client.metadata }, expiryTimestamp: Ei(T2) }, fe4 = { eip155: { chains: o2, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m2])], events: ["chainChanged", "accountsChanged"] } }, q3 = { requiredNamespaces: {}, optionalNamespaces: fe4, relays: [{ protocol: "irn" }], pairingTopic: g2, proposer: { publicKey: D2, metadata: this.client.metadata }, expiryTimestamp: Ei(N2.wc_sessionPropose.req.ttl), id: payloadId() }, { done: Rt5, resolve: je5, reject: Se5 } = gi(T2, "Request expired"), te4 = payloadId(), le5 = xi("session_connect", q3.id), Re3 = xi("session_request", te4), pe5 = async ({ error: x3, session: L3 }) => {
        this.events.off(Re3, ve4), x3 ? Se5(x3) : L3 && je5({ session: L3 });
      }, ve4 = async (x3) => {
        var L3, Fe4, Qe5;
        if (await this.deletePendingAuthRequest(te4, { message: "fulfilled", code: 0 }), x3.error) {
          const ie4 = Nt2("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return x3.error.code === ie4.code ? void 0 : (this.events.off(le5, pe5), Se5(x3.error.message));
        }
        await this.deleteProposal(q3.id), this.events.off(le5, pe5);
        const { cacaos: He5, responder: Q4 } = x3.result, Te4 = [], ze5 = [];
        for (const ie4 of He5) {
          await is({ cacao: ie4, projectId: this.client.core.projectId }) || (this.client.logger.error(ie4, "Signature verification failed"), Se5(Nt2("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe5 } = ie4, Pe5 = pe2(qe5.resources), Ye5 = [dr2(qe5.iss)], vt3 = De2(qe5.iss);
          if (Pe5) {
            const Ne4 = ds(Pe5), It5 = hs(Pe5);
            Te4.push(...Ne4), Ye5.push(...It5);
          }
          for (const Ne4 of Ye5) ze5.push(`${Ne4}:${vt3}`);
        }
        const se4 = await this.client.core.crypto.generateSharedKey(D2, Q4.publicKey);
        let he5;
        Te4.length > 0 && (he5 = { topic: se4, acknowledged: true, self: { publicKey: D2, metadata: this.client.metadata }, peer: Q4, controller: Q4.publicKey, expiry: Ei(J3), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: g2, namespaces: ca([...new Set(Te4)], [...new Set(ze5)]), transportType: r2 }, await this.client.core.relayer.subscribe(se4, { transportType: r2 }), await this.client.session.set(se4, he5), g2 && await this.client.core.pairing.updateMetadata({ topic: g2, metadata: Q4.metadata }), he5 = this.client.session.get(se4)), (L3 = this.client.metadata.redirect) != null && L3.linkMode && (Fe4 = Q4.metadata.redirect) != null && Fe4.linkMode && (Qe5 = Q4.metadata.redirect) != null && Qe5.universal && t && (this.client.core.addLinkModeSupportedApp(Q4.metadata.redirect.universal), this.client.session.update(se4, { transportType: Q2.link_mode })), je5({ auths: He5, session: he5 });
      };
      this.events.once(le5, pe5), this.events.once(Re3, ve4);
      let Ie5;
      try {
        if (i3) {
          const x3 = formatJsonRpcRequest("wc_sessionAuthenticate", K4, te4);
          this.client.core.history.set(g2, x3);
          const L3 = await this.client.core.crypto.encode("", x3, { type: re, encoding: xe2 });
          Ie5 = Xc(t, g2, L3);
        } else await Promise.all([this.sendRequest({ topic: g2, method: "wc_sessionAuthenticate", params: K4, expiry: e.expiry, throwOnFailedPublish: true, clientRpcId: te4 }), this.sendRequest({ topic: g2, method: "wc_sessionPropose", params: q3, expiry: N2.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: q3.id })]);
      } catch (x3) {
        throw this.events.off(le5, pe5), this.events.off(Re3, ve4), x3;
      }
      return await this.setProposal(q3.id, q3), await this.setAuthRequest(te4, { request: b3(v4({}, K4), { verifyContext: {} }), pairingTopic: g2, transportType: r2 }), { uri: Ie5 ?? A4, response: Rt5 };
    }), c2(this, "approveSessionAuthenticate", async (e) => {
      const { id: t, auths: s } = e, i3 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [ir3.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (f7) {
        throw i3.setError(sr3.no_internet_connection), f7;
      }
      const r2 = this.getPendingAuthRequest(t);
      if (!r2) throw i3.setError(sr3.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const o2 = r2.transportType || Q2.relay;
      o2 === Q2.relay && await this.confirmOnlineStateOrThrow();
      const a2 = r2.requester.publicKey, l4 = await this.client.core.crypto.generateKeyPair(), p3 = Pc(a2), h5 = { type: Ft2, receiverPublicKey: a2, senderPublicKey: l4 }, u3 = [], d4 = [];
      for (const f7 of s) {
        if (!await is({ cacao: f7, projectId: this.client.core.projectId })) {
          i3.setError(sr3.invalid_cacao);
          const I3 = Nt2("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: p3, error: I3, encodeOpts: h5 }), new Error(I3.message);
        }
        i3.addTrace(ir3.cacaos_verified);
        const { p: _ } = f7, g2 = pe2(_.resources), A4 = [dr2(_.iss)], D2 = De2(_.iss);
        if (g2) {
          const I3 = ds(g2), T2 = hs(g2);
          u3.push(...I3), A4.push(...T2);
        }
        for (const I3 of A4) d4.push(`${I3}:${D2}`);
      }
      const w3 = await this.client.core.crypto.generateSharedKey(l4, a2);
      i3.addTrace(ir3.create_authenticated_session_topic);
      let m2;
      if (u3?.length > 0) {
        m2 = { topic: w3, acknowledged: true, self: { publicKey: l4, metadata: this.client.metadata }, peer: { publicKey: a2, metadata: r2.requester.metadata }, controller: a2, expiry: Ei(J3), authentication: s, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r2.pairingTopic, namespaces: ca([...new Set(u3)], [...new Set(d4)]), transportType: o2 }, i3.addTrace(ir3.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w3, { transportType: o2 });
        } catch (f7) {
          throw i3.setError(sr3.subscribe_authenticated_session_topic_failure), f7;
        }
        i3.addTrace(ir3.subscribe_authenticated_session_topic_success), await this.client.session.set(w3, m2), i3.addTrace(ir3.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r2.pairingTopic, metadata: r2.requester.metadata });
      }
      i3.addTrace(ir3.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: p3, id: t, result: { cacaos: s, responder: { publicKey: l4, metadata: this.client.metadata } }, encodeOpts: h5, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r2.requester.metadata, o2) });
      } catch (f7) {
        throw i3.setError(sr3.authenticated_session_approve_publish_failure), f7;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r2.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i3.eventId }), { session: m2 };
    }), c2(this, "rejectSessionAuthenticate", async (e) => {
      this.isInitialized();
      const { id: t, reason: s } = e, i3 = this.getPendingAuthRequest(t);
      if (!i3) throw new Error(`Could not find pending auth request with id ${t}`);
      i3.transportType === Q2.relay && await this.confirmOnlineStateOrThrow();
      const r2 = i3.requester.publicKey, o2 = await this.client.core.crypto.generateKeyPair(), a2 = Pc(r2), l4 = { type: Ft2, receiverPublicKey: r2, senderPublicKey: o2 };
      await this.sendError({ id: t, topic: a2, error: s, encodeOpts: l4, rpcOpts: N2.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i3.requester.metadata, i3.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, Nt2("USER_DISCONNECTED"));
    }), c2(this, "formatAuthMessage", (e) => {
      this.isInitialized();
      const { request: t, iss: s } = e;
      return hr2(t, s);
    }), c2(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e = this.relayMessageCache.shift();
          e && await this.onRelayMessage(e);
        } catch (e) {
          this.client.logger.error(e);
        }
      }, 50);
    }), c2(this, "cleanupDuplicatePairings", async (e) => {
      if (e.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((i3) => {
          var r2, o2;
          return ((r2 = i3.peerMetadata) == null ? void 0 : r2.url) && ((o2 = i3.peerMetadata) == null ? void 0 : o2.url) === e.peer.metadata.url && i3.topic && i3.topic !== t.topic;
        });
        if (s.length === 0) return;
        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c2(this, "deleteSession", async (e) => {
      var t;
      const { topic: s, expirerHasDeleted: i3 = false, emitEvent: r2 = true, id: o2 = 0 } = e, { self: a2 } = this.client.session.get(s);
      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, Nt2("USER_DISCONNECTED")), this.addToRecentlyDeleted(s, "session"), this.client.core.crypto.keychain.has(a2.publicKey) && await this.client.core.crypto.deleteKeyPair(a2.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), i3 || this.client.core.expirer.del(s), this.client.core.storage.removeItem(Me4).catch((l4) => this.client.logger.warn(l4)), this.getPendingSessionRequests().forEach((l4) => {
        l4.topic === s && this.deletePendingSessionRequest(l4.id, Nt2("USER_DISCONNECTED"));
      }), s === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = $2.idle), r2 && this.client.events.emit("session_delete", { id: o2, topic: s });
    }), c2(this, "deleteProposal", async (e, t) => {
      if (t) try {
        const s = this.client.proposal.get(e), i3 = this.client.core.eventClient.getEvent({ topic: s.pairingTopic });
        i3?.setError(tr3.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e, Nt2("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
    }), c2(this, "deletePendingSessionRequest", async (e, t, s = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e), s && (this.sessionRequestQueue.state = $2.idle, this.client.events.emit("session_request_expire", { id: e }));
    }), c2(this, "deletePendingAuthRequest", async (e, t, s = false) => {
      await Promise.all([this.client.auth.requests.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }), c2(this, "setExpiry", async (e, t) => {
      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
    }), c2(this, "setProposal", async (e, t) => {
      this.client.core.expirer.set(e, Ei(N2.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
    }), c2(this, "setAuthRequest", async (e, t) => {
      const { request: s, pairingTopic: i3, transportType: r2 = Q2.relay } = t;
      this.client.core.expirer.set(e, s.expiryTimestamp), await this.client.auth.requests.set(e, { authPayload: s.authPayload, requester: s.requester, expiryTimestamp: s.expiryTimestamp, id: e, pairingTopic: i3, verifyContext: s.verifyContext, transportType: r2 });
    }), c2(this, "setPendingSessionRequest", async (e) => {
      const { id: t, topic: s, params: i3, verifyContext: r2 } = e, o2 = i3.request.expiryTimestamp || Ei(N2.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, o2), await this.client.pendingRequest.set(t, { id: t, topic: s, params: i3, verifyContext: r2 });
    }), c2(this, "sendRequest", async (e) => {
      const { topic: t, method: s, params: i3, expiry: r2, relayRpcId: o2, clientRpcId: a2, throwOnFailedPublish: l4, appLink: p3, tvf: h5 } = e, u3 = formatJsonRpcRequest(s, i3, a2);
      let d4;
      const w3 = !!p3;
      try {
        const _ = w3 ? xe2 : qt2;
        d4 = await this.client.core.crypto.encode(t, u3, { encoding: _ });
      } catch (_) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), _;
      }
      let m2;
      if (gt3.includes(s)) {
        const _ = kc(JSON.stringify(u3)), g2 = kc(d4);
        m2 = await this.client.core.verify.register({ id: g2, decryptedId: _ });
      }
      const f7 = N2[s].req;
      if (f7.attestation = m2, r2 && (f7.ttl = r2), o2 && (f7.id = o2), this.client.core.history.set(t, u3), w3) {
        const _ = Xc(p3, t, d4);
        await global.Linking.openURL(_, this.client.name);
      } else {
        const _ = N2[s].req;
        r2 && (_.ttl = r2), o2 && (_.id = o2), _.tvf = b3(v4({}, h5), { correlationId: u3.id }), l4 ? (_.internal = b3(v4({}, _.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d4, _)) : this.client.core.relayer.publish(t, d4, _).catch((g2) => this.client.logger.error(g2));
      }
      return u3.id;
    }), c2(this, "sendResult", async (e) => {
      const { id: t, topic: s, result: i3, throwOnFailedPublish: r2, encodeOpts: o2, appLink: a2 } = e, l4 = formatJsonRpcResult(t, i3);
      let p3;
      const h5 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const w3 = h5 ? xe2 : qt2;
        p3 = await this.client.core.crypto.encode(s, l4, b3(v4({}, o2 || {}), { encoding: w3 }));
      } catch (w3) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), w3;
      }
      let u3, d4;
      try {
        u3 = await this.client.core.history.get(s, t);
        const w3 = u3.request;
        try {
          this.shouldSetTVF(w3.method, w3.params) && (d4 = this.getTVFParams(t, w3.params, i3));
        } catch (m2) {
          this.client.logger.warn("sendResult() -> getTVFParams() failed", m2);
        }
      } catch (w3) {
        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`), w3;
      }
      if (h5) {
        const w3 = Xc(a2, s, p3);
        await global.Linking.openURL(w3, this.client.name);
      } else {
        const w3 = u3.request.method, m2 = N2[w3].res;
        m2.tvf = b3(v4({}, d4), { correlationId: t }), r2 ? (m2.internal = b3(v4({}, m2.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s, p3, m2)) : this.client.core.relayer.publish(s, p3, m2).catch((f7) => this.client.logger.error(f7));
      }
      await this.client.core.history.resolve(l4);
    }), c2(this, "sendError", async (e) => {
      const { id: t, topic: s, error: i3, encodeOpts: r2, rpcOpts: o2, appLink: a2 } = e, l4 = formatJsonRpcError(t, i3);
      let p3;
      const h5 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d4 = h5 ? xe2 : qt2;
        p3 = await this.client.core.crypto.encode(s, l4, b3(v4({}, r2 || {}), { encoding: d4 }));
      } catch (d4) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), d4;
      }
      let u3;
      try {
        u3 = await this.client.core.history.get(s, t);
      } catch (d4) {
        throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`), d4;
      }
      if (h5) {
        const d4 = Xc(a2, s, p3);
        await global.Linking.openURL(d4, this.client.name);
      } else {
        const d4 = u3.request.method, w3 = o2 || N2[d4].res;
        this.client.core.relayer.publish(s, p3, w3);
      }
      await this.client.core.history.resolve(l4);
    }), c2(this, "cleanup", async () => {
      const e = [], t = [];
      this.client.session.getAll().forEach((s) => {
        let i3 = false;
        vi(s.expiry) && (i3 = true), this.client.core.crypto.keychain.has(s.topic) || (i3 = true), i3 && e.push(s.topic);
      }), this.client.proposal.getAll().forEach((s) => {
        vi(s.expiryTimestamp) && t.push(s.id);
      }), await Promise.all([...e.map((s) => this.deleteSession({ topic: s })), ...t.map((s) => this.deleteProposal(s))]);
    }), c2(this, "onProviderMessageEvent", async (e) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : await this.onRelayMessage(e);
    }), c2(this, "onRelayEventRequest", async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }), c2(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $2.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $2.active;
        const e = this.requestQueue.queue.shift();
        if (e) try {
          await this.processRequest(e);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = $2.idle;
    }), c2(this, "processRequest", async (e) => {
      const { topic: t, payload: s, attestation: i3, transportType: r2, encryptedId: o2 } = e, a2 = s.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a2 })) switch (a2) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s, attestation: i3, encryptedId: o2 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s, attestation: i3, encryptedId: o2, transportType: r2 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s, attestation: i3, encryptedId: o2, transportType: r2 });
        default:
          return this.client.logger.info(`Unsupported request method ${a2}`);
      }
    }), c2(this, "onRelayEventResponse", async (e) => {
      const { topic: t, payload: s, transportType: i3 } = e, r2 = (await this.client.core.history.get(t, s.id)).request.method;
      switch (r2) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s, i3);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s);
        default:
          return this.client.logger.info(`Unsupported response method ${r2}`);
      }
    }), c2(this, "onRelayEventUnknownPayload", (e) => {
      const { topic: t } = e, { message: s } = ht2("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s);
    }), c2(this, "shouldIgnorePairingRequest", (e) => {
      const { topic: t, requestMethod: s } = e, i3 = this.expectedPairingMethodMap.get(t);
      return !i3 || i3.includes(s) ? false : !!(i3.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c2(this, "onSessionProposeRequest", async (e) => {
      const { topic: t, payload: s, attestation: i3, encryptedId: r2 } = e, { params: o2, id: a2 } = s;
      try {
        const l4 = this.client.core.eventClient.getEvent({ topic: t });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l4?.setError(Y2.proposal_listener_not_found)), this.isValidConnect(v4({}, s.params));
        const p3 = o2.expiryTimestamp || Ei(N2.wc_sessionPropose.req.ttl), h5 = v4({ id: a2, pairingTopic: t, expiryTimestamp: p3 }, o2);
        await this.setProposal(a2, h5);
        const u3 = await this.getVerifyContext({ attestationId: i3, hash: kc(JSON.stringify(s)), encryptedId: r2, metadata: h5.proposer.metadata });
        l4?.addTrace(G3.emit_session_proposal), this.client.events.emit("session_proposal", { id: a2, params: h5, verifyContext: u3 });
      } catch (l4) {
        await this.sendError({ id: a2, topic: t, error: l4, rpcOpts: N2.wc_sessionPropose.autoReject }), this.client.logger.error(l4);
      }
    }), c2(this, "onSessionProposeResponse", async (e, t, s) => {
      const { id: i3 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r2 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r2 });
        const o2 = this.client.proposal.get(i3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: o2 });
        const a2 = o2.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a2 });
        const l4 = r2.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l4 });
        const p3 = await this.client.core.crypto.generateSharedKey(a2, l4);
        this.pendingSessions.set(i3, { sessionTopic: p3, pairingTopic: e, proposalId: i3, publicKey: a2 });
        const h5 = await this.client.core.relayer.subscribe(p3, { transportType: s });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h5 }), await this.client.core.pairing.activate({ topic: e });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i3, Nt2("USER_DISCONNECTED"));
        const r2 = xi("session_connect", i3);
        if (this.events.listenerCount(r2) === 0) throw new Error(`emitting ${r2} without any listeners, 954`);
        this.events.emit(r2, { error: t.error });
      }
    }), c2(this, "onSessionSettleRequest", async (e, t) => {
      const { id: s, params: i3 } = t;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: r2, controller: o2, expiry: a2, namespaces: l4, sessionProperties: p3, scopedProperties: h5, sessionConfig: u3 } = t.params, d4 = [...this.pendingSessions.values()].find((f7) => f7.sessionTopic === e);
        if (!d4) return this.client.logger.error(`Pending session not found for topic ${e}`);
        const w3 = this.client.proposal.get(d4.proposalId), m2 = b3(v4(v4(v4({ topic: e, relay: r2, expiry: a2, namespaces: l4, acknowledged: true, pairingTopic: d4.pairingTopic, requiredNamespaces: w3.requiredNamespaces, optionalNamespaces: w3.optionalNamespaces, controller: o2.publicKey, self: { publicKey: d4.publicKey, metadata: this.client.metadata }, peer: { publicKey: o2.publicKey, metadata: o2.metadata } }, p3 && { sessionProperties: p3 }), h5 && { scopedProperties: h5 }), u3 && { sessionConfig: u3 }), { transportType: Q2.relay });
        await this.client.session.set(m2.topic, m2), await this.setExpiry(m2.topic, m2.expiry), await this.client.core.pairing.updateMetadata({ topic: d4.pairingTopic, metadata: m2.peer.metadata }), this.client.events.emit("session_connect", { session: m2 }), this.events.emit(xi("session_connect", d4.proposalId), { session: m2 }), this.pendingSessions.delete(d4.proposalId), this.deleteProposal(d4.proposalId, false), this.cleanupDuplicatePairings(m2), await this.sendResult({ id: t.id, topic: e, result: true, throwOnFailedPublish: true });
      } catch (r2) {
        await this.sendError({ id: s, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c2(this, "onSessionSettleResponse", async (e, t) => {
      const { id: s } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(xi("session_approve", s), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, Nt2("USER_DISCONNECTED")), this.events.emit(xi("session_approve", s), { error: t.error }));
    }), c2(this, "onSessionUpdateRequest", async (e, t) => {
      const { params: s, id: i3 } = t;
      try {
        const r2 = `${e}_session_update`, o2 = Ra.get(r2);
        if (o2 && this.isRequestOutOfSync(o2, i3)) {
          this.client.logger.warn(`Discarding out of sync request - ${i3}`), this.sendError({ id: i3, topic: e, error: Nt2("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(v4({ topic: e }, s));
        try {
          Ra.set(r2, i3), await this.client.session.update(e, { namespaces: s.namespaces }), await this.sendResult({ id: i3, topic: e, result: true, throwOnFailedPublish: true });
        } catch (a2) {
          throw Ra.delete(r2), a2;
        }
        this.client.events.emit("session_update", { id: i3, topic: e, params: s });
      } catch (r2) {
        await this.sendError({ id: i3, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c2(this, "isRequestOutOfSync", (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)), c2(this, "onSessionUpdateResponse", (e, t) => {
      const { id: s } = t, i3 = xi("session_update", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_update", s), {}) : isJsonRpcError(t) && this.events.emit(xi("session_update", s), { error: t.error });
    }), c2(this, "onSessionExtendRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, Ei(J3)), await this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s, topic: e });
      } catch (i3) {
        await this.sendError({ id: s, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }), c2(this, "onSessionExtendResponse", (e, t) => {
      const { id: s } = t, i3 = xi("session_extend", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_extend", s), {}) : isJsonRpcError(t) && this.events.emit(xi("session_extend", s), { error: t.error });
    }), c2(this, "onSessionPingRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s, topic: e });
      } catch (i3) {
        await this.sendError({ id: s, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }), c2(this, "onSessionPingResponse", (e, t) => {
      const { id: s } = t, i3 = xi("session_ping", s);
      setTimeout(() => {
        if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners 2176`);
        isJsonRpcResult(t) ? this.events.emit(xi("session_ping", s), {}) : isJsonRpcError(t) && this.events.emit(xi("session_ping", s), { error: t.error });
      }, 500);
    }), c2(this, "onSessionDeleteRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidDisconnect({ topic: e, reason: t.params }), Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(C2.publish, async () => {
            i3(await this.deleteSession({ topic: e, id: s }));
          });
        }), this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e, error: Nt2("USER_DISCONNECTED") })]).catch((i3) => this.client.logger.error(i3));
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }), c2(this, "onSessionRequest", async (e) => {
      var t, s, i3;
      const { topic: r2, payload: o2, attestation: a2, encryptedId: l4, transportType: p3 } = e, { id: h5, params: u3 } = o2;
      try {
        await this.isValidRequest(v4({ topic: r2 }, u3));
        const d4 = this.client.session.get(r2), w3 = await this.getVerifyContext({ attestationId: a2, hash: kc(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u3, h5))), encryptedId: l4, metadata: d4.peer.metadata, transportType: p3 }), m2 = { id: h5, topic: r2, params: u3, verifyContext: w3 };
        await this.setPendingSessionRequest(m2), p3 === Q2.link_mode && (t = d4.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s = d4.peer.metadata.redirect) == null ? void 0 : s.universal), (i3 = this.client.signConfig) != null && i3.disableRequestQueue ? this.emitSessionRequest(m2) : (this.addSessionRequestToSessionRequestQueue(m2), this.processSessionRequestQueue());
      } catch (d4) {
        await this.sendError({ id: h5, topic: r2, error: d4 }), this.client.logger.error(d4);
      }
    }), c2(this, "onSessionRequestResponse", (e, t) => {
      const { id: s } = t, i3 = xi("session_request", s);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(xi("session_request", s), { error: t.error });
    }), c2(this, "onSessionEventRequest", async (e, t) => {
      const { id: s, params: i3 } = t;
      try {
        const r2 = `${e}_session_event_${i3.event.name}`, o2 = Ra.get(r2);
        if (o2 && this.isRequestOutOfSync(o2, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidEmit(v4({ topic: e }, i3)), this.client.events.emit("session_event", { id: s, topic: e, params: i3 }), Ra.set(r2, s);
      } catch (r2) {
        await this.sendError({ id: s, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c2(this, "onSessionAuthenticateResponse", (e, t) => {
      const { id: s } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e, payload: t }), isJsonRpcResult(t) ? this.events.emit(xi("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(xi("session_request", s), { error: t.error });
    }), c2(this, "onSessionAuthenticateRequest", async (e) => {
      var t;
      const { topic: s, payload: i3, attestation: r2, encryptedId: o2, transportType: a2 } = e;
      try {
        const { requester: l4, authPayload: p3, expiryTimestamp: h5 } = i3.params, u3 = await this.getVerifyContext({ attestationId: r2, hash: kc(JSON.stringify(i3)), encryptedId: o2, metadata: l4.metadata, transportType: a2 }), d4 = { requester: l4, pairingTopic: s, id: i3.id, authPayload: p3, verifyContext: u3, expiryTimestamp: h5 };
        await this.setAuthRequest(i3.id, { request: d4, pairingTopic: s, transportType: a2 }), a2 === Q2.link_mode && (t = l4.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(l4.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s, params: i3.params, id: i3.id, verifyContext: u3 });
      } catch (l4) {
        this.client.logger.error(l4);
        const p3 = i3.params.requester.publicKey, h5 = await this.client.core.crypto.generateKeyPair(), u3 = this.getAppLinkIfEnabled(i3.params.requester.metadata, a2), d4 = { type: Ft2, receiverPublicKey: p3, senderPublicKey: h5 };
        await this.sendError({ id: i3.id, topic: s, error: l4, encodeOpts: d4, rpcOpts: N2.wc_sessionAuthenticate.autoReject, appLink: u3 });
      }
    }), c2(this, "addSessionRequestToSessionRequestQueue", (e) => {
      this.sessionRequestQueue.queue.push(e);
    }), c2(this, "cleanupAfterResponse", (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $2.idle, this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay));
    }), c2(this, "cleanupPendingSentRequestsForTopic", ({ topic: e, error: t }) => {
      const s = this.client.core.history.pending;
      s.length > 0 && s.filter((i3) => i3.topic === e && i3.request.method === "wc_sessionRequest").forEach((i3) => {
        const r2 = i3.request.id, o2 = xi("session_request", r2);
        if (this.events.listenerCount(o2) === 0) throw new Error(`emitting ${o2} without any listeners`);
        this.events.emit(xi("session_request", i3.request.id), { error: t });
      });
    }), c2(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $2.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = $2.active, this.emitSessionRequest(e);
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c2(this, "emitSessionRequest", (e) => {
      this.client.events.emit("session_request", e);
    }), c2(this, "onPairingCreated", (e) => {
      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;
      const t = this.client.proposal.getAll().find((s) => s.pairingTopic === e.topic);
      t && this.onSessionProposeRequest({ topic: e.topic, payload: formatJsonRpcRequest("wc_sessionPropose", b3(v4({}, t), { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties, scopedProperties: t.scopedProperties }), t.id) });
    }), c2(this, "isValidConnect", async (e) => {
      if (!ma(e)) {
        const { message: l4 } = ht2("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(l4);
      }
      const { pairingTopic: t, requiredNamespaces: s, optionalNamespaces: i3, sessionProperties: r2, scopedProperties: o2, relays: a2 } = e;
      if (Et2(t) || await this.isValidPairingTopic(t), !ga(a2, true)) {
        const { message: l4 } = ht2("MISSING_OR_INVALID", `connect() relays: ${a2}`);
        throw new Error(l4);
      }
      if (!Et2(s) && Oe2(s) !== 0) {
        const l4 = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l4) : this.client.logger.warn(l4), this.validateNamespaces(s, "requiredNamespaces");
      }
      if (!Et2(i3) && Oe2(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), Et2(r2) || this.validateSessionProps(r2, "sessionProperties"), !Et2(o2)) {
        this.validateSessionProps(o2, "scopedProperties");
        const l4 = Object.keys(s || {}).concat(Object.keys(i3 || {}));
        if (!Object.keys(o2).every((p3) => l4.includes(p3))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o2)}, required/optional namespaces: ${JSON.stringify(l4)}`);
      }
    }), c2(this, "validateNamespaces", (e, t) => {
      const s = pa(e, "connect()", t);
      if (s) throw new Error(s.message);
    }), c2(this, "isValidApprove", async (e) => {
      if (!ma(e)) throw new Error(ht2("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: t, namespaces: s, relayProtocol: i3, sessionProperties: r2, scopedProperties: o2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const a2 = this.client.proposal.get(t), l4 = Bo2(s, "approve()");
      if (l4) throw new Error(l4.message);
      const p3 = No2(a2.requiredNamespaces, s, "approve()");
      if (p3) throw new Error(p3.message);
      if (!nt2(i3, true)) {
        const { message: h5 } = ht2("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(h5);
      }
      if (Et2(r2) || this.validateSessionProps(r2, "sessionProperties"), !Et2(o2)) {
        this.validateSessionProps(o2, "scopedProperties");
        const h5 = new Set(Object.keys(s));
        if (!Object.keys(o2).every((u3) => h5.has(u3))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o2)}, approved namespaces: ${Array.from(h5).join(", ")}`);
      }
    }), c2(this, "isValidReject", async (e) => {
      if (!ma(e)) {
        const { message: i3 } = ht2("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i3);
      }
      const { id: t, reason: s } = e;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !wa(s)) {
        const { message: i3 } = ht2("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
        throw new Error(i3);
      }
    }), c2(this, "isValidSessionSettleRequest", (e) => {
      if (!ma(e)) {
        const { message: l4 } = ht2("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(l4);
      }
      const { relay: t, controller: s, namespaces: i3, expiry: r2 } = e;
      if (!Io2(t)) {
        const { message: l4 } = ht2("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l4);
      }
      const o2 = ha(s, "onSessionSettleRequest()");
      if (o2) throw new Error(o2.message);
      const a2 = Bo2(i3, "onSessionSettleRequest()");
      if (a2) throw new Error(a2.message);
      if (vi(r2)) {
        const { message: l4 } = ht2("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l4);
      }
    }), c2(this, "isValidUpdate", async (e) => {
      if (!ma(e)) {
        const { message: a2 } = ht2("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: t, namespaces: s } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i3 = this.client.session.get(t), r2 = Bo2(s, "update()");
      if (r2) throw new Error(r2.message);
      const o2 = No2(i3.requiredNamespaces, s, "update()");
      if (o2) throw new Error(o2.message);
    }), c2(this, "isValidExtend", async (e) => {
      if (!ma(e)) {
        const { message: s } = ht2("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }), c2(this, "isValidRequest", async (e) => {
      if (!ma(e)) {
        const { message: a2 } = ht2("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: t, request: s, chainId: i3, expiry: r2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: o2 } = this.client.session.get(t);
      if (!xa(o2, i3)) {
        const { message: a2 } = ht2("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a2);
      }
      if (!ba(s)) {
        const { message: a2 } = ht2("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
        throw new Error(a2);
      }
      if (!Sa(o2, i3, s.method)) {
        const { message: a2 } = ht2("MISSING_OR_INVALID", `request() method: ${s.method}`);
        throw new Error(a2);
      }
      if (r2 && !Ia(r2, _e4)) {
        const { message: a2 } = ht2("MISSING_OR_INVALID", `request() expiry: ${r2}. Expiry must be a number (in seconds) between ${_e4.min} and ${_e4.max}`);
        throw new Error(a2);
      }
    }), c2(this, "isValidRespond", async (e) => {
      var t;
      if (!ma(e)) {
        const { message: r2 } = ht2("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(r2);
      }
      const { topic: s, response: i3 } = e;
      try {
        await this.isValidSessionTopic(s);
      } catch (r2) {
        throw (t = e?.response) != null && t.id && this.cleanupAfterResponse(e), r2;
      }
      if (!Ea(i3)) {
        const { message: r2 } = ht2("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(r2);
      }
    }), c2(this, "isValidPing", async (e) => {
      if (!ma(e)) {
        const { message: s } = ht2("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c2(this, "isValidEmit", async (e) => {
      if (!ma(e)) {
        const { message: o2 } = ht2("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(o2);
      }
      const { topic: t, event: s, chainId: i3 } = e;
      await this.isValidSessionTopic(t);
      const { namespaces: r2 } = this.client.session.get(t);
      if (!xa(r2, i3)) {
        const { message: o2 } = ht2("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(o2);
      }
      if (!va(s)) {
        const { message: o2 } = ht2("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(o2);
      }
      if (!Oa(r2, i3, s.name)) {
        const { message: o2 } = ht2("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(o2);
      }
    }), c2(this, "isValidDisconnect", async (e) => {
      if (!ma(e)) {
        const { message: s } = ht2("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c2(this, "isValidAuthenticate", (e) => {
      const { chains: t, uri: s, domain: i3, nonce: r2 } = e;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!nt2(s, false)) throw new Error("uri is required parameter");
      if (!nt2(i3, false)) throw new Error("domain is required parameter");
      if (!nt2(r2, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a2) => Ne2(a2).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: o2 } = Ne2(t[0]);
      if (o2 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c2(this, "getVerifyContext", async (e) => {
      const { attestationId: t, hash: s, encryptedId: i3, metadata: r2, transportType: o2 } = e, a2 = { verified: { verifyUrl: r2.verifyUrl || ue2, validation: "UNKNOWN", origin: r2.url || "" } };
      try {
        if (o2 === Q2.link_mode) {
          const p3 = this.getAppLinkIfEnabled(r2, o2);
          return a2.verified.validation = p3 && new URL(p3).origin === new URL(r2.url).origin ? "VALID" : "INVALID", a2;
        }
        const l4 = await this.client.core.verify.resolve({ attestationId: t, hash: s, encryptedId: i3, verifyUrl: r2.verifyUrl });
        l4 && (a2.verified.origin = l4.origin, a2.verified.isScam = l4.isScam, a2.verified.validation = l4.origin === new URL(r2.url).origin ? "VALID" : "INVALID");
      } catch (l4) {
        this.client.logger.warn(l4);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a2)}`), a2;
    }), c2(this, "validateSessionProps", (e, t) => {
      Object.values(e).forEach((s, i3) => {
        if (s == null) {
          const { message: r2 } = ht2("MISSING_OR_INVALID", `${t} must contain an existing value for each key. Received: ${s} for key ${Object.keys(e)[i3]}`);
          throw new Error(r2);
        }
      });
    }), c2(this, "getPendingAuthRequest", (e) => {
      const t = this.client.auth.requests.get(e);
      return typeof t == "object" ? t : void 0;
    }), c2(this, "addToRecentlyDeleted", (e, t) => {
      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s = 0;
        const i3 = this.recentlyDeletedLimit / 2;
        for (const r2 of this.recentlyDeletedMap.keys()) {
          if (s++ >= i3) break;
          this.recentlyDeletedMap.delete(r2);
        }
      }
    }), c2(this, "checkRecentlyDeleted", (e) => {
      const t = this.recentlyDeletedMap.get(e);
      if (t) {
        const { message: s } = ht2("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
        throw new Error(s);
      }
    }), c2(this, "isLinkModeEnabled", (e, t) => {
      var s, i3, r2, o2, a2, l4, p3, h5, u3;
      return !e || t !== Q2.link_mode ? false : ((i3 = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i3.linkMode) === true && ((o2 = (r2 = this.client.metadata) == null ? void 0 : r2.redirect) == null ? void 0 : o2.universal) !== void 0 && ((l4 = (a2 = this.client.metadata) == null ? void 0 : a2.redirect) == null ? void 0 : l4.universal) !== "" && ((p3 = e?.redirect) == null ? void 0 : p3.universal) !== void 0 && ((h5 = e?.redirect) == null ? void 0 : h5.universal) !== "" && ((u3 = e?.redirect) == null ? void 0 : u3.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c2(this, "getAppLinkIfEnabled", (e, t) => {
      var s;
      return this.isLinkModeEnabled(e, t) ? (s = e?.redirect) == null ? void 0 : s.universal : void 0;
    }), c2(this, "handleLinkModeMessage", ({ url: e }) => {
      if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
      const t = Ai(e, "topic") || "", s = decodeURIComponent(Ai(e, "wc_ev") || ""), i3 = this.client.session.keys.includes(t);
      i3 && this.client.session.update(t, { transportType: Q2.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s, sessionExists: i3 });
    }), c2(this, "registerLinkModeListeners", async () => {
      var e;
      if (Ii() || pt() && (e = this.client.metadata.redirect) != null && e.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s = await t.getInitialURL();
          s && setTimeout(() => {
            this.handleLinkModeMessage({ url: s });
          }, 50);
        }
      }
    }), c2(this, "shouldSetTVF", (e, t) => {
      if (!t || e !== "wc_sessionRequest") return false;
      const { request: s } = t;
      return Object.keys(Ke4).includes(s.method);
    }), c2(this, "getTVFParams", (e, t, s) => {
      var i3, r2;
      try {
        const o2 = t.request.method, a2 = this.extractTxHashesFromResult(o2, s);
        return b3(v4({ correlationId: e, rpcMethods: [o2], chainId: t.chainId }, this.isValidContractData(t.request.params) && { contractAddresses: [(r2 = (i3 = t.request.params) == null ? void 0 : i3[0]) == null ? void 0 : r2.to] }), { txHashes: a2 });
      } catch (o2) {
        this.client.logger.warn("Error getting TVF params", o2);
      }
      return {};
    }), c2(this, "isValidContractData", (e) => {
      var t;
      if (!e) return false;
      try {
        const s = e?.data || ((t = e?.[0]) == null ? void 0 : t.data);
        if (!s.startsWith("0x")) return false;
        const i3 = s.slice(2);
        return /^[0-9a-fA-F]*$/.test(i3) ? i3.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c2(this, "extractTxHashesFromResult", (e, t) => {
      try {
        const s = Ke4[e];
        if (typeof t == "string") return [t];
        const i3 = t[s.key];
        if (se(i3)) return e === "solana_signAllTransactions" ? i3.map((r2) => Ji(r2)) : i3;
        if (typeof i3 == "string") return [i3];
      } catch (s) {
        this.client.logger.warn("Error extracting tx hashes from result", s);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const n2 = this.client.session.keys, e = this.client.core.relayer.messages.getWithoutAck(n2);
      for (const [t, s] of Object.entries(e)) for (const i3 of s) try {
        await this.onProviderMessageEvent({ topic: t, message: i3, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${t}, message: ${i3}`);
      }
    } catch (n2) {
      this.client.logger.warn("processPendingMessageEvents failed", n2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: n2 } = ht2("NOT_INITIALIZED", this.name);
      throw new Error(n2);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C2.message, (n2) => {
      this.onProviderMessageEvent(n2);
    });
  }
  async onRelayMessage(n2) {
    const { topic: e, message: t, attestation: s, transportType: i3 } = n2, { publicKey: r2 } = this.client.auth.authKeys.keys.includes(ce2) ? this.client.auth.authKeys.get(ce2) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const o2 = await this.client.core.crypto.decode(e, t, { receiverPublicKey: r2, encoding: i3 === Q2.link_mode ? xe2 : qt2 });
      isJsonRpcRequest(o2) ? (this.client.core.history.set(e, o2), await this.onRelayEventRequest({ topic: e, payload: o2, attestation: s, transportType: i3, encryptedId: kc(t) })) : isJsonRpcResponse(o2) ? (await this.client.core.history.resolve(o2), await this.onRelayEventResponse({ topic: e, payload: o2, transportType: i3 }), this.client.core.history.delete(e, o2.id)) : await this.onRelayEventUnknownPayload({ topic: e, payload: o2, transportType: i3 }), await this.client.core.relayer.messages.ack(e, t);
    } catch (o2) {
      this.client.logger.error(o2);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(M3.expired, async (n2) => {
      const { topic: e, id: t } = bi(n2.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, ht2("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, ht2("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession({ topic: e, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(re2.create, (n2) => this.onPairingCreated(n2)), this.client.core.pairing.events.on(re2.delete, (n2) => {
      this.addToRecentlyDeleted(n2.topic, "pairing");
    });
  }
  isValidPairingTopic(n2) {
    if (!nt2(n2, false)) {
      const { message: e } = ht2("MISSING_OR_INVALID", `pairing topic should be a string: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(n2)) {
      const { message: e } = ht2("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (vi(this.client.core.pairing.pairings.get(n2).expiry)) {
      const { message: e } = ht2("EXPIRED", `pairing topic: ${n2}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(n2) {
    if (!nt2(n2, false)) {
      const { message: e } = ht2("MISSING_OR_INVALID", `session topic should be a string: ${n2}`);
      throw new Error(e);
    }
    if (this.checkRecentlyDeleted(n2), !this.client.session.keys.includes(n2)) {
      const { message: e } = ht2("NO_MATCHING_KEY", `session topic doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (vi(this.client.session.get(n2).expiry)) {
      await this.deleteSession({ topic: n2 });
      const { message: e } = ht2("EXPIRED", `session topic: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.core.crypto.keychain.has(n2)) {
      const { message: e } = ht2("MISSING_OR_INVALID", `session topic does not exist in keychain: ${n2}`);
      throw await this.deleteSession({ topic: n2 }), new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(n2) {
    if (this.checkRecentlyDeleted(n2), this.client.session.keys.includes(n2)) await this.isValidSessionTopic(n2);
    else if (this.client.core.pairing.pairings.keys.includes(n2)) this.isValidPairingTopic(n2);
    else if (nt2(n2, false)) {
      const { message: e } = ht2("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n2}`);
      throw new Error(e);
    } else {
      const { message: e } = ht2("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n2}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(n2) {
    if (!ya(n2)) {
      const { message: e } = ht2("MISSING_OR_INVALID", `proposal id should be a number: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(n2)) {
      const { message: e } = ht2("NO_MATCHING_KEY", `proposal id doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (vi(this.client.proposal.get(n2).expiryTimestamp)) {
      await this.deleteProposal(n2);
      const { message: e } = ht2("EXPIRED", `proposal id: ${n2}`);
      throw new Error(e);
    }
  }
};
var Os2 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, pt2, we3), this.core = n2, this.logger = e;
  }
};
var St4 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, ht3, we3), this.core = n2, this.logger = e;
  }
};
var bs2 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, ut3, we3, (t) => t.id), this.core = n2, this.logger = e;
  }
};
var As2 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, mt2, ae2, () => ce2), this.core = n2, this.logger = e;
  }
};
var xs2 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, _t3, ae2), this.core = n2, this.logger = e;
  }
};
var Cs2 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, Et4, ae2, (t) => t.id), this.core = n2, this.logger = e;
  }
};
var Vs2 = Object.defineProperty;
var Ds2 = (S4, n2, e) => n2 in S4 ? Vs2(S4, n2, { enumerable: true, configurable: true, writable: true, value: e }) : S4[n2] = e;
var Ge4 = (S4, n2, e) => Ds2(S4, typeof n2 != "symbol" ? n2 + "" : n2, e);
var Ls2 = class {
  constructor(n2, e) {
    this.core = n2, this.logger = e, Ge4(this, "authKeys"), Ge4(this, "pairingTopics"), Ge4(this, "requests"), this.authKeys = new As2(this.core, this.logger), this.pairingTopics = new xs2(this.core, this.logger), this.requests = new Cs2(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var ks2 = Object.defineProperty;
var Ms2 = (S4, n2, e) => n2 in S4 ? ks2(S4, n2, { enumerable: true, configurable: true, writable: true, value: e }) : S4[n2] = e;
var E3 = (S4, n2, e) => Ms2(S4, typeof n2 != "symbol" ? n2 + "" : n2, e);
var Ee4 = class _Ee extends J {
  constructor(n2) {
    super(n2), E3(this, "protocol", De3), E3(this, "version", Le3), E3(this, "name", me3.name), E3(this, "metadata"), E3(this, "core"), E3(this, "logger"), E3(this, "events", new import_events5.EventEmitter()), E3(this, "engine"), E3(this, "session"), E3(this, "proposal"), E3(this, "pendingRequest"), E3(this, "auth"), E3(this, "signConfig"), E3(this, "on", (t, s) => this.events.on(t, s)), E3(this, "once", (t, s) => this.events.once(t, s)), E3(this, "off", (t, s) => this.events.off(t, s)), E3(this, "removeListener", (t, s) => this.events.removeListener(t, s)), E3(this, "removeAllListeners", (t) => this.events.removeAllListeners(t)), E3(this, "connect", async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "pair", async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "approve", async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "reject", async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "update", async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "extend", async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "request", async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "respond", async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "ping", async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "emit", async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "disconnect", async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "find", (t) => {
      try {
        return this.engine.find(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }), E3(this, "authenticate", async (t, s) => {
      try {
        return await this.engine.authenticate(t, s);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }), E3(this, "formatAuthMessage", (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "approveSessionAuthenticate", async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E3(this, "rejectSessionAuthenticate", async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), this.name = n2?.name || me3.name, this.metadata = oi(n2?.metadata), this.signConfig = n2?.signConfig;
    const e = typeof n2?.logger < "u" && typeof n2?.logger != "string" ? n2.logger : (0, import_pino.default)(k({ level: n2?.logger || me3.logger }));
    this.core = n2?.core || new Xo2(n2), this.logger = E(e, this.name), this.session = new St4(this.core, this.logger), this.proposal = new Os2(this.core, this.logger), this.pendingRequest = new bs2(this.core, this.logger), this.engine = new Ns2(this), this.auth = new Ls2(this.core, this.logger);
  }
  static async init(n2) {
    const e = new _Ee(n2);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, (0, import_time4.toMiliseconds)(import_time4.ONE_SECOND));
    } catch (n2) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n2.message), n2;
    }
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events6 = __toESM(require_events());
var et2 = "error";
var St5 = "wss://relay.walletconnect.org";
var Dt3 = "wc";
var qt4 = "universal_provider";
var U3 = `${Dt3}@2:${qt4}:`;
var st = "https://rpc.walletconnect.org/v1/";
var I2 = "generic";
var jt4 = `${st}bundler`;
var u2 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function Rt4() {
}
function k5(s) {
  return s == null || typeof s != "object" && typeof s != "function";
}
function W3(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function _t4(s) {
  if (k5(s)) return s;
  if (Array.isArray(s) || W3(s) || s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
  const t = Object.getPrototypeOf(s), e = t.constructor;
  if (s instanceof Date || s instanceof Map || s instanceof Set) return new e(s);
  if (s instanceof RegExp) {
    const i3 = new e(s);
    return i3.lastIndex = s.lastIndex, i3;
  }
  if (s instanceof DataView) return new e(s.buffer.slice(0));
  if (s instanceof Error) {
    const i3 = new e(s.message);
    return i3.stack = s.stack, i3.name = s.name, i3.cause = s.cause, i3;
  }
  if (typeof File < "u" && s instanceof File) return new e([s], s.name, { type: s.type, lastModified: s.lastModified });
  if (typeof s == "object") {
    const i3 = Object.create(t);
    return Object.assign(i3, s);
  }
  return s;
}
function it4(s) {
  return typeof s == "object" && s !== null;
}
function rt2(s) {
  return Object.getOwnPropertySymbols(s).filter((t) => Object.prototype.propertyIsEnumerable.call(s, t));
}
function nt3(s) {
  return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s);
}
var Ut3 = "[object RegExp]";
var at2 = "[object String]";
var ct3 = "[object Number]";
var ot2 = "[object Boolean]";
var ht4 = "[object Arguments]";
var Ft4 = "[object Symbol]";
var Lt4 = "[object Date]";
var Mt4 = "[object Map]";
var xt4 = "[object Set]";
var Bt4 = "[object Array]";
var Gt3 = "[object ArrayBuffer]";
var Jt4 = "[object Object]";
var zt3 = "[object DataView]";
var kt5 = "[object Uint8Array]";
var Wt4 = "[object Uint8ClampedArray]";
var Kt4 = "[object Uint16Array]";
var Vt4 = "[object Uint32Array]";
var Xt4 = "[object Int8Array]";
var Yt4 = "[object Int16Array]";
var Qt4 = "[object Int32Array]";
var Zt3 = "[object Float32Array]";
var Tt4 = "[object Float64Array]";
function te3(s, t) {
  return $3(s, void 0, s, /* @__PURE__ */ new Map(), t);
}
function $3(s, t, e, i3 = /* @__PURE__ */ new Map(), n2 = void 0) {
  const a2 = n2?.(s, t, e, i3);
  if (a2 != null) return a2;
  if (k5(s)) return s;
  if (i3.has(s)) return i3.get(s);
  if (Array.isArray(s)) {
    const r2 = new Array(s.length);
    i3.set(s, r2);
    for (let c3 = 0; c3 < s.length; c3++) r2[c3] = $3(s[c3], c3, e, i3, n2);
    return Object.hasOwn(s, "index") && (r2.index = s.index), Object.hasOwn(s, "input") && (r2.input = s.input), r2;
  }
  if (s instanceof Date) return new Date(s.getTime());
  if (s instanceof RegExp) {
    const r2 = new RegExp(s.source, s.flags);
    return r2.lastIndex = s.lastIndex, r2;
  }
  if (s instanceof Map) {
    const r2 = /* @__PURE__ */ new Map();
    i3.set(s, r2);
    for (const [c3, o2] of s) r2.set(c3, $3(o2, c3, e, i3, n2));
    return r2;
  }
  if (s instanceof Set) {
    const r2 = /* @__PURE__ */ new Set();
    i3.set(s, r2);
    for (const c3 of s) r2.add($3(c3, void 0, e, i3, n2));
    return r2;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(s)) return s.subarray();
  if (W3(s)) {
    const r2 = new (Object.getPrototypeOf(s)).constructor(s.length);
    i3.set(s, r2);
    for (let c3 = 0; c3 < s.length; c3++) r2[c3] = $3(s[c3], c3, e, i3, n2);
    return r2;
  }
  if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
  if (s instanceof DataView) {
    const r2 = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);
    return i3.set(s, r2), y4(r2, s, e, i3, n2), r2;
  }
  if (typeof File < "u" && s instanceof File) {
    const r2 = new File([s], s.name, { type: s.type });
    return i3.set(s, r2), y4(r2, s, e, i3, n2), r2;
  }
  if (s instanceof Blob) {
    const r2 = new Blob([s], { type: s.type });
    return i3.set(s, r2), y4(r2, s, e, i3, n2), r2;
  }
  if (s instanceof Error) {
    const r2 = new s.constructor();
    return i3.set(s, r2), r2.message = s.message, r2.name = s.name, r2.stack = s.stack, r2.cause = s.cause, y4(r2, s, e, i3, n2), r2;
  }
  if (typeof s == "object" && ee3(s)) {
    const r2 = Object.create(Object.getPrototypeOf(s));
    return i3.set(s, r2), y4(r2, s, e, i3, n2), r2;
  }
  return s;
}
function y4(s, t, e = s, i3, n2) {
  const a2 = [...Object.keys(t), ...rt2(t)];
  for (let r2 = 0; r2 < a2.length; r2++) {
    const c3 = a2[r2], o2 = Object.getOwnPropertyDescriptor(s, c3);
    (o2 == null || o2.writable) && (s[c3] = $3(t[c3], c3, e, i3, n2));
  }
}
function ee3(s) {
  switch (nt3(s)) {
    case ht4:
    case Bt4:
    case Gt3:
    case zt3:
    case ot2:
    case Lt4:
    case Zt3:
    case Tt4:
    case Xt4:
    case Yt4:
    case Qt4:
    case Mt4:
    case ct3:
    case Jt4:
    case Ut3:
    case xt4:
    case at2:
    case Ft4:
    case kt5:
    case Wt4:
    case Kt4:
    case Vt4:
      return true;
    default:
      return false;
  }
}
function se3(s, t) {
  return te3(s, (e, i3, n2, a2) => {
    const r2 = t?.(e, i3, n2, a2);
    if (r2 != null) return r2;
    if (typeof s == "object") switch (Object.prototype.toString.call(s)) {
      case ct3:
      case at2:
      case ot2: {
        const c3 = new s.constructor(s?.valueOf());
        return y4(c3, s), c3;
      }
      case ht4: {
        const c3 = {};
        return y4(c3, s), c3.length = s.length, c3[Symbol.iterator] = s[Symbol.iterator], c3;
      }
      default:
        return;
    }
  });
}
function pt3(s) {
  return se3(s);
}
function dt4(s) {
  return s !== null && typeof s == "object" && nt3(s) === "[object Arguments]";
}
function ie3(s) {
  return W3(s);
}
function re3(s) {
  if (typeof s != "object" || s == null) return false;
  if (Object.getPrototypeOf(s) === null) return true;
  if (Object.prototype.toString.call(s) !== "[object Object]") {
    const e = s[Symbol.toStringTag];
    return e == null || !Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)?.writable ? false : s.toString() === `[object ${e}]`;
  }
  let t = s;
  for (; Object.getPrototypeOf(t) !== null; ) t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(s) === t;
}
function ne3(s, ...t) {
  const e = t.slice(0, -1), i3 = t[t.length - 1];
  let n2 = s;
  for (let a2 = 0; a2 < e.length; a2++) {
    const r2 = e[a2];
    n2 = F3(n2, r2, i3, /* @__PURE__ */ new Map());
  }
  return n2;
}
function F3(s, t, e, i3) {
  if (k5(s) && (s = Object(s)), t == null || typeof t != "object") return s;
  if (i3.has(t)) return _t4(i3.get(t));
  if (i3.set(t, s), Array.isArray(t)) {
    t = t.slice();
    for (let a2 = 0; a2 < t.length; a2++) t[a2] = t[a2] ?? void 0;
  }
  const n2 = [...Object.keys(t), ...rt2(t)];
  for (let a2 = 0; a2 < n2.length; a2++) {
    const r2 = n2[a2];
    let c3 = t[r2], o2 = s[r2];
    if (dt4(c3) && (c3 = { ...c3 }), dt4(o2) && (o2 = { ...o2 }), typeof Buffer < "u" && Buffer.isBuffer(c3) && (c3 = pt3(c3)), Array.isArray(c3)) if (typeof o2 == "object" && o2 != null) {
      const w3 = [], v5 = Reflect.ownKeys(o2);
      for (let P4 = 0; P4 < v5.length; P4++) {
        const p3 = v5[P4];
        w3[p3] = o2[p3];
      }
      o2 = w3;
    } else o2 = [];
    const m2 = e(o2, c3, r2, s, t, i3);
    m2 != null ? s[r2] = m2 : Array.isArray(c3) || it4(o2) && it4(c3) ? s[r2] = F3(o2, c3, e, i3) : o2 == null && re3(c3) ? s[r2] = F3({}, c3, e, i3) : o2 == null && ie3(c3) ? s[r2] = pt3(c3) : (o2 === void 0 || c3 !== void 0) && (s[r2] = c3);
  }
  return s;
}
function ae3(s, ...t) {
  return ne3(s, ...t, Rt4);
}
var ce3 = Object.defineProperty;
var oe2 = Object.defineProperties;
var he4 = Object.getOwnPropertyDescriptors;
var ut4 = Object.getOwnPropertySymbols;
var pe4 = Object.prototype.hasOwnProperty;
var de4 = Object.prototype.propertyIsEnumerable;
var lt3 = (s, t, e) => t in s ? ce3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var L2 = (s, t) => {
  for (var e in t || (t = {})) pe4.call(t, e) && lt3(s, e, t[e]);
  if (ut4) for (var e of ut4(t)) de4.call(t, e) && lt3(s, e, t[e]);
  return s;
};
var ue3 = (s, t) => oe2(s, he4(t));
function d3(s, t, e) {
  var i3;
  const n2 = Ne2(s);
  return ((i3 = t.rpcMap) == null ? void 0 : i3[n2.reference]) || `${st}?chainId=${n2.namespace}:${n2.reference}&projectId=${e}`;
}
function b4(s) {
  return s.includes(":") ? s.split(":")[1] : s;
}
function ft4(s) {
  return s.map((t) => `${t.split(":")[0]}:${t.split(":")[1]}`);
}
function le4(s, t) {
  const e = Object.keys(t.namespaces).filter((n2) => n2.includes(s));
  if (!e.length) return [];
  const i3 = [];
  return e.forEach((n2) => {
    const a2 = t.namespaces[n2].accounts;
    i3.push(...a2);
  }), i3;
}
function M4(s = {}, t = {}) {
  const e = mt3(s), i3 = mt3(t);
  return ae3(e, i3);
}
function mt3(s) {
  var t, e, i3, n2, a2;
  const r2 = {};
  if (!Oe2(s)) return r2;
  for (const [c3, o2] of Object.entries(s)) {
    const m2 = yn2(c3) ? [c3] : o2.chains, w3 = o2.methods || [], v5 = o2.events || [], P4 = o2.rpcMap || {}, p3 = yo2(c3);
    r2[p3] = ue3(L2(L2({}, r2[p3]), o2), { chains: ot(m2, (t = r2[p3]) == null ? void 0 : t.chains), methods: ot(w3, (e = r2[p3]) == null ? void 0 : e.methods), events: ot(v5, (i3 = r2[p3]) == null ? void 0 : i3.events) }), (Oe2(P4) || Oe2(((n2 = r2[p3]) == null ? void 0 : n2.rpcMap) || {})) && (r2[p3].rpcMap = L2(L2({}, P4), (a2 = r2[p3]) == null ? void 0 : a2.rpcMap));
  }
  return r2;
}
function vt2(s) {
  return s.includes(":") ? s.split(":")[2] : s;
}
function gt4(s) {
  const t = {};
  for (const [e, i3] of Object.entries(s)) {
    const n2 = i3.methods || [], a2 = i3.events || [], r2 = i3.accounts || [], c3 = yn2(e) ? [e] : i3.chains ? i3.chains : ft4(i3.accounts);
    t[e] = { chains: c3, methods: n2, events: a2, accounts: r2 };
  }
  return t;
}
function K3(s) {
  return typeof s == "number" ? s : s.includes("0x") ? parseInt(s, 16) : (s = s.includes(":") ? s.split(":")[1] : s, isNaN(Number(s)) ? s : Number(s));
}
var Pt4 = {};
var h4 = (s) => Pt4[s];
var V4 = (s, t) => {
  Pt4[s] = t;
};
var fe3 = Object.defineProperty;
var me4 = (s, t, e) => t in s ? fe3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var O3 = (s, t, e) => me4(s, typeof t != "symbol" ? t + "" : t, e);
var ve3 = class {
  constructor(t) {
    O3(this, "name", "polkadot"), O3(this, "client"), O3(this, "httpProviders"), O3(this, "events"), O3(this, "namespace"), O3(this, "chainId"), this.namespace = t.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = b4(e);
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i3, h4("disableProviderPing")));
  }
};
var ge4 = Object.defineProperty;
var Pe4 = Object.defineProperties;
var we4 = Object.getOwnPropertyDescriptors;
var wt4 = Object.getOwnPropertySymbols;
var ye4 = Object.prototype.hasOwnProperty;
var be4 = Object.prototype.propertyIsEnumerable;
var X2 = (s, t, e) => t in s ? ge4(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var yt4 = (s, t) => {
  for (var e in t || (t = {})) ye4.call(t, e) && X2(s, e, t[e]);
  if (wt4) for (var e of wt4(t)) be4.call(t, e) && X2(s, e, t[e]);
  return s;
};
var bt3 = (s, t) => Pe4(s, we4(t));
var A3 = (s, t, e) => X2(s, typeof t != "symbol" ? t + "" : t, e);
var Ie4 = class {
  constructor(t) {
    A3(this, "name", "eip155"), A3(this, "client"), A3(this, "chainId"), A3(this, "namespace"), A3(this, "httpProviders"), A3(this, "events"), this.namespace = t.namespace, this.events = h4("events"), this.client = h4("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(t) {
    switch (t.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(t);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(t);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(t);
    }
    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(parseInt(t), e), this.chainId = parseInt(t), this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  createHttpProvider(t, e) {
    const i3 = e || d3(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i3, h4("disableProviderPing")));
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = parseInt(b4(e));
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const t = this.chainId, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  async handleSwitchChain(t) {
    var e, i3;
    let n2 = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : "0x0";
    n2 = n2.startsWith("0x") ? n2 : `0x${n2}`;
    const a2 = parseInt(n2, 16);
    if (this.isChainApproved(a2)) this.setDefaultChain(`${a2}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: t.topic, request: { method: t.request.method, params: [{ chainId: n2 }] }, chainId: (i3 = this.namespace.chains) == null ? void 0 : i3[0] }), this.setDefaultChain(`${a2}`);
    else throw new Error(`Failed to switch to chain 'eip155:${a2}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(t) {
    return this.namespace.chains.includes(`${this.name}:${t}`);
  }
  async getCapabilities(t) {
    var e, i3, n2, a2, r2;
    const c3 = (i3 = (e = t.request) == null ? void 0 : e.params) == null ? void 0 : i3[0], o2 = ((a2 = (n2 = t.request) == null ? void 0 : n2.params) == null ? void 0 : a2[1]) || [], m2 = `${c3}${o2.join(",")}`;
    if (!c3) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const w3 = this.client.session.get(t.topic), v5 = ((r2 = w3?.sessionProperties) == null ? void 0 : r2.capabilities) || {};
    if (v5 != null && v5[m2]) return v5?.[m2];
    const P4 = await this.client.request(t);
    try {
      await this.client.session.update(t.topic, { sessionProperties: bt3(yt4({}, w3.sessionProperties || {}), { capabilities: bt3(yt4({}, v5 || {}), { [m2]: P4 }) }) });
    } catch (p3) {
      console.warn("Failed to update session with capabilities", p3);
    }
    return P4;
  }
  async getCallStatus(t) {
    var e, i3;
    const n2 = this.client.session.get(t.topic), a2 = (e = n2.sessionProperties) == null ? void 0 : e.bundler_name;
    if (a2) {
      const c3 = this.getBundlerUrl(t.chainId, a2);
      try {
        return await this.getUserOperationReceipt(c3, t);
      } catch (o2) {
        console.warn("Failed to fetch call status from bundler", o2, c3);
      }
    }
    const r2 = (i3 = n2.sessionProperties) == null ? void 0 : i3.bundler_url;
    if (r2) try {
      return await this.getUserOperationReceipt(r2, t);
    } catch (c3) {
      console.warn("Failed to fetch call status from custom bundler", c3, r2);
    }
    if (this.namespace.methods.includes(t.request.method)) return await this.client.request(t);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(t, e) {
    var i3;
    const n2 = new URL(t), a2 = await fetch(n2, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i3 = e.request.params) == null ? void 0 : i3[0]])) });
    if (!a2.ok) throw new Error(`Failed to fetch user operation receipt - ${a2.status}`);
    return await a2.json();
  }
  getBundlerUrl(t, e) {
    return `${jt4}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`;
  }
};
var $e4 = Object.defineProperty;
var Oe4 = (s, t, e) => t in s ? $e4(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var C4 = (s, t, e) => Oe4(s, typeof t != "symbol" ? t + "" : t, e);
var Ae3 = class {
  constructor(t) {
    C4(this, "name", "solana"), C4(this, "client"), C4(this, "httpProviders"), C4(this, "events"), C4(this, "namespace"), C4(this, "chainId"), this.namespace = t.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = b4(e);
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i3, h4("disableProviderPing")));
  }
};
var Ce4 = Object.defineProperty;
var He4 = (s, t, e) => t in s ? Ce4(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var H3 = (s, t, e) => He4(s, typeof t != "symbol" ? t + "" : t, e);
var Ee5 = class {
  constructor(t) {
    H3(this, "name", "cosmos"), H3(this, "client"), H3(this, "httpProviders"), H3(this, "events"), H3(this, "namespace"), H3(this, "chainId"), this.namespace = t.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = b4(e);
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i3, h4("disableProviderPing")));
  }
};
var Ne3 = Object.defineProperty;
var Se4 = (s, t, e) => t in s ? Ne3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var E4 = (s, t, e) => Se4(s, typeof t != "symbol" ? t + "" : t, e);
var De4 = class {
  constructor(t) {
    E4(this, "name", "algorand"), E4(this, "client"), E4(this, "httpProviders"), E4(this, "events"), E4(this, "namespace"), E4(this, "chainId"), this.namespace = t.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (!this.httpProviders[t]) {
      const i3 = e || d3(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i3);
    }
    this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      t[e] = this.createHttpProvider(e, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || d3(t, this.namespace, this.client.core.projectId);
    return typeof i3 > "u" ? void 0 : new o(new f(i3, h4("disableProviderPing")));
  }
};
var qe4 = Object.defineProperty;
var je4 = (s, t, e) => t in s ? qe4(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var N3 = (s, t, e) => je4(s, typeof t != "symbol" ? t + "" : t, e);
var Re2 = class {
  constructor(t) {
    N3(this, "name", "cip34"), N3(this, "client"), N3(this, "httpProviders"), N3(this, "events"), N3(this, "namespace"), N3(this, "chainId"), this.namespace = t.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      const i3 = this.getCardanoRPCUrl(e), n2 = b4(e);
      t[n2] = this.createHttpProvider(n2, i3);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  getCardanoRPCUrl(t) {
    const e = this.namespace.rpcMap;
    if (e) return e[t];
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || this.getCardanoRPCUrl(t);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i3, h4("disableProviderPing")));
  }
};
var _e5 = Object.defineProperty;
var Ue4 = (s, t, e) => t in s ? _e5(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var S3 = (s, t, e) => Ue4(s, typeof t != "symbol" ? t + "" : t, e);
var Fe3 = class {
  constructor(t) {
    S3(this, "name", "elrond"), S3(this, "client"), S3(this, "httpProviders"), S3(this, "events"), S3(this, "namespace"), S3(this, "chainId"), this.namespace = t.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = b4(e);
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i3, h4("disableProviderPing")));
  }
};
var Le4 = Object.defineProperty;
var Me5 = (s, t, e) => t in s ? Le4(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var D = (s, t, e) => Me5(s, typeof t != "symbol" ? t + "" : t, e);
var xe3 = class {
  constructor(t) {
    D(this, "name", "multiversx"), D(this, "client"), D(this, "httpProviders"), D(this, "events"), D(this, "namespace"), D(this, "chainId"), this.namespace = t.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      const n2 = b4(e);
      t[n2] = this.createHttpProvider(n2, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i3, h4("disableProviderPing")));
  }
};
var Be4 = Object.defineProperty;
var Ge5 = (s, t, e) => t in s ? Be4(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var q2 = (s, t, e) => Ge5(s, typeof t != "symbol" ? t + "" : t, e);
var Je4 = class {
  constructor(t) {
    q2(this, "name", "near"), q2(this, "client"), q2(this, "httpProviders"), q2(this, "events"), q2(this, "namespace"), q2(this, "chainId"), this.namespace = t.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i3 = e || d3(`${this.name}:${t}`, this.namespace);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i3);
    }
    this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i3;
      t[e] = this.createHttpProvider(e, (i3 = this.namespace.rpcMap) == null ? void 0 : i3[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || d3(t, this.namespace);
    return typeof i3 > "u" ? void 0 : new o(new f(i3, h4("disableProviderPing")));
  }
};
var ze4 = Object.defineProperty;
var ke5 = (s, t, e) => t in s ? ze4(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var j2 = (s, t, e) => ke5(s, typeof t != "symbol" ? t + "" : t, e);
var We5 = class {
  constructor(t) {
    j2(this, "name", "tezos"), j2(this, "client"), j2(this, "httpProviders"), j2(this, "events"), j2(this, "namespace"), j2(this, "chainId"), this.namespace = t.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i3 = e || d3(`${this.name}:${t}`, this.namespace);
      if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i3);
    }
    this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      t[e] = this.createHttpProvider(e);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || d3(t, this.namespace);
    return typeof i3 > "u" ? void 0 : new o(new f(i3));
  }
};
var Ke5 = Object.defineProperty;
var Ve4 = (s, t, e) => t in s ? Ke5(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var R3 = (s, t, e) => Ve4(s, typeof t != "symbol" ? t + "" : t, e);
var Xe4 = class {
  constructor(t) {
    R3(this, "name", I2), R3(this, "client"), R3(this, "httpProviders"), R3(this, "events"), R3(this, "namespace"), R3(this, "chainId"), this.namespace = t.namespace, this.events = h4("events"), this.client = h4("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider(t.chainId).request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var t, e;
    const i3 = {};
    return (e = (t = this.namespace) == null ? void 0 : t.accounts) == null || e.forEach((n2) => {
      const a2 = Ne2(n2);
      i3[`${a2.namespace}:${a2.reference}`] = this.createHttpProvider(n2);
    }), i3;
  }
  getHttpProvider(t) {
    const e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i3 = this.createHttpProvider(t, e);
    i3 && (this.httpProviders[t] = i3);
  }
  createHttpProvider(t, e) {
    const i3 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i3) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i3, h4("disableProviderPing")));
  }
};
var Ye4 = Object.defineProperty;
var Qe4 = Object.defineProperties;
var Ze5 = Object.getOwnPropertyDescriptors;
var It4 = Object.getOwnPropertySymbols;
var Te3 = Object.prototype.hasOwnProperty;
var ts2 = Object.prototype.propertyIsEnumerable;
var Y3 = (s, t, e) => t in s ? Ye4(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var x2 = (s, t) => {
  for (var e in t || (t = {})) Te3.call(t, e) && Y3(s, e, t[e]);
  if (It4) for (var e of It4(t)) ts2.call(t, e) && Y3(s, e, t[e]);
  return s;
};
var Q3 = (s, t) => Qe4(s, Ze5(t));
var l3 = (s, t, e) => Y3(s, typeof t != "symbol" ? t + "" : t, e);
var B2 = class _B {
  constructor(t) {
    l3(this, "client"), l3(this, "namespaces"), l3(this, "optionalNamespaces"), l3(this, "sessionProperties"), l3(this, "scopedProperties"), l3(this, "events", new import_events6.default()), l3(this, "rpcProviders", {}), l3(this, "session"), l3(this, "providerOpts"), l3(this, "logger"), l3(this, "uri"), l3(this, "disableProviderPing", false), this.providerOpts = t, this.logger = typeof t?.logger < "u" && typeof t?.logger != "string" ? t.logger : (0, import_pino.default)(k({ level: t?.logger || et2 })), this.disableProviderPing = t?.disableProviderPing || false;
  }
  static async init(t) {
    const e = new _B(t);
    return await e.initialize(), e;
  }
  async request(t, e, i3) {
    const [n2, a2] = this.validateChain(e);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(n2).request({ request: x2({}, t), chainId: `${n2}:${a2}`, topic: this.session.topic, expiry: i3 });
  }
  sendAsync(t, e, i3, n2) {
    const a2 = (/* @__PURE__ */ new Date()).getTime();
    this.request(t, i3, n2).then((r2) => e(null, formatJsonRpcResult(a2, r2))).catch((r2) => e(r2, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var t;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (t = this.session) == null ? void 0 : t.topic, reason: Nt2("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(t) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);
  }
  async authenticate(t, e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(t), await this.cleanupPendingPairings();
    const { uri: i3, response: n2 } = await this.client.authenticate(t, e);
    i3 && (this.uri = i3, this.events.emit("display_uri", i3));
    const a2 = await n2();
    if (this.session = a2.session, this.session) {
      const r2 = gt4(this.session.namespaces);
      this.namespaces = M4(this.namespaces, r2), await this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return a2;
  }
  on(t, e) {
    this.events.on(t, e);
  }
  once(t, e) {
    this.events.once(t, e);
  }
  removeListener(t, e) {
    this.events.removeListener(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(t) {
    const { uri: e, approval: i3 } = await this.client.connect({ pairingTopic: t, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties });
    e && (this.uri = e, this.events.emit("display_uri", e));
    const n2 = await i3();
    this.session = n2;
    const a2 = gt4(n2.namespaces);
    return this.namespaces = M4(this.namespaces, a2), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
  }
  setDefaultChain(t, e) {
    try {
      if (!this.session) return;
      const [i3, n2] = this.validateChain(t), a2 = this.getProvider(i3);
      a2.name === I2 ? a2.setDefaultChain(`${i3}:${n2}`, e) : a2.setDefaultChain(n2, e);
    } catch (i3) {
      if (!/Please call connect/.test(i3.message)) throw i3;
    }
  }
  async cleanupPendingPairings(t = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const e = this.client.pairing.getAll();
    if (se(e)) {
      for (const i3 of e) t.deletePairings ? this.client.core.expirer.set(i3.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i3.topic);
      this.logger.info(`Inactive pairings cleared: ${e.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    var t, e;
    if (this.client = this.providerOpts.client || await Ee4.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || et2, relayUrl: this.providerOpts.relayUrl || St5, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.providerOpts.session) try {
      this.session = this.client.session.get(this.providerOpts.session.topic);
    } catch (i3) {
      throw this.logger.error("Failed to get session", i3), new Error(`The provided session: ${(e = (t = this.providerOpts) == null ? void 0 : t.session) == null ? void 0 : e.topic} doesn't exist in the Sign client`);
    }
    else {
      const i3 = this.client.session.getAll();
      this.session = i3[0];
    }
    this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const t = [...new Set(Object.keys(this.session.namespaces).map((e) => yo2(e)))];
    V4("client", this.client), V4("events", this.events), V4("disableProviderPing", this.disableProviderPing), t.forEach((e) => {
      if (!this.session) return;
      const i3 = le4(e, this.session), n2 = ft4(i3), a2 = M4(this.namespaces, this.optionalNamespaces), r2 = Q3(x2({}, a2[e]), { accounts: i3, chains: n2 });
      switch (e) {
        case "eip155":
          this.rpcProviders[e] = new Ie4({ namespace: r2 });
          break;
        case "algorand":
          this.rpcProviders[e] = new De4({ namespace: r2 });
          break;
        case "solana":
          this.rpcProviders[e] = new Ae3({ namespace: r2 });
          break;
        case "cosmos":
          this.rpcProviders[e] = new Ee5({ namespace: r2 });
          break;
        case "polkadot":
          this.rpcProviders[e] = new ve3({ namespace: r2 });
          break;
        case "cip34":
          this.rpcProviders[e] = new Re2({ namespace: r2 });
          break;
        case "elrond":
          this.rpcProviders[e] = new Fe3({ namespace: r2 });
          break;
        case "multiversx":
          this.rpcProviders[e] = new xe3({ namespace: r2 });
          break;
        case "near":
          this.rpcProviders[e] = new Je4({ namespace: r2 });
          break;
        case "tezos":
          this.rpcProviders[e] = new We5({ namespace: r2 });
          break;
        default:
          this.rpcProviders[I2] ? this.rpcProviders[I2].updateNamespace(r2) : this.rpcProviders[I2] = new Xe4({ namespace: r2 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (t) => {
      var e;
      const { topic: i3 } = t;
      i3 === ((e = this.session) == null ? void 0 : e.topic) && this.events.emit("session_ping", t);
    }), this.client.on("session_event", (t) => {
      var e;
      const { params: i3, topic: n2 } = t;
      if (n2 !== ((e = this.session) == null ? void 0 : e.topic)) return;
      const { event: a2 } = i3;
      if (a2.name === "accountsChanged") {
        const r2 = a2.data;
        r2 && se(r2) && this.events.emit("accountsChanged", r2.map(vt2));
      } else if (a2.name === "chainChanged") {
        const r2 = i3.chainId, c3 = i3.event.data, o2 = yo2(r2), m2 = K3(r2) !== K3(c3) ? `${o2}:${K3(c3)}` : r2;
        this.onChainChanged(m2);
      } else this.events.emit(a2.name, a2.data);
      this.events.emit("session_event", t);
    }), this.client.on("session_update", ({ topic: t, params: e }) => {
      var i3, n2;
      if (t !== ((i3 = this.session) == null ? void 0 : i3.topic)) return;
      const { namespaces: a2 } = e, r2 = (n2 = this.client) == null ? void 0 : n2.session.get(t);
      this.session = Q3(x2({}, r2), { namespaces: a2 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: t, params: e });
    }), this.client.on("session_delete", async (t) => {
      var e;
      t.topic === ((e = this.session) == null ? void 0 : e.topic) && (await this.cleanup(), this.events.emit("session_delete", t), this.events.emit("disconnect", Q3(x2({}, Nt2("USER_DISCONNECTED")), { data: t.topic })));
    }), this.on(u2.DEFAULT_CHAIN_CHANGED, (t) => {
      this.onChainChanged(t, true);
    });
  }
  getProvider(t) {
    return this.rpcProviders[t] || this.rpcProviders[I2];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((t) => {
      var e;
      this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);
    });
  }
  setNamespaces(t) {
    const { namespaces: e = {}, optionalNamespaces: i3 = {}, sessionProperties: n2, scopedProperties: a2 } = t;
    this.optionalNamespaces = M4(e, i3), this.sessionProperties = n2, this.scopedProperties = a2;
  }
  validateChain(t) {
    const [e, i3] = t?.split(":") || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [e, i3];
    if (e && !Object.keys(this.namespaces || {}).map((r2) => yo2(r2)).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);
    if (e && i3) return [e, i3];
    const n2 = yo2(Object.keys(this.namespaces)[0]), a2 = this.rpcProviders[n2].getDefaultChain();
    return [n2, a2];
  }
  async requestAccounts() {
    const [t] = this.validateChain();
    return await this.getProvider(t).requestAccounts();
  }
  async onChainChanged(t, e = false) {
    if (!this.namespaces) return;
    const [i3, n2] = this.validateChain(t);
    if (!n2) return;
    this.updateNamespaceChain(i3, n2), this.events.emit("chainChanged", n2);
    const a2 = this.getProvider(i3).getDefaultChain();
    e || this.getProvider(i3).setDefaultChain(n2), this.emitAccountsChangedOnChainChange({ namespace: i3, previousChainId: a2, newChainId: t }), await this.persist("namespaces", this.namespaces);
  }
  emitAccountsChangedOnChainChange({ namespace: t, previousChainId: e, newChainId: i3 }) {
    var n2, a2;
    try {
      if (e === i3) return;
      const r2 = (a2 = (n2 = this.session) == null ? void 0 : n2.namespaces[t]) == null ? void 0 : a2.accounts;
      if (!r2) return;
      const c3 = r2.filter((o2) => o2.includes(`${i3}:`)).map(vt2);
      if (!se(c3)) return;
      this.events.emit("accountsChanged", c3);
    } catch (r2) {
      this.logger.warn("Failed to emit accountsChanged on chain change", r2);
    }
  }
  updateNamespaceChain(t, e) {
    if (!this.namespaces) return;
    const i3 = this.namespaces[t] ? t : `${t}:${e}`, n2 = { chains: [], methods: [], events: [], defaultChain: e };
    this.namespaces[i3] ? this.namespaces[i3] && (this.namespaces[i3].defaultChain = e) : this.namespaces[i3] = n2;
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({ deletePairings: true }), await this.cleanupStorage();
  }
  async persist(t, e) {
    var i3;
    const n2 = ((i3 = this.session) == null ? void 0 : i3.topic) || "";
    await this.client.core.storage.setItem(`${U3}/${t}${n2}`, e);
  }
  async getFromStore(t) {
    var e;
    const i3 = ((e = this.session) == null ? void 0 : e.topic) || "";
    return await this.client.core.storage.getItem(`${U3}/${t}${i3}`);
  }
  async deleteFromStore(t) {
    var e;
    const i3 = ((e = this.session) == null ? void 0 : e.topic) || "";
    await this.client.core.storage.removeItem(`${U3}/${t}${i3}`);
  }
  async cleanupStorage() {
    var t;
    try {
      if (((t = this.client) == null ? void 0 : t.session.length) > 0) return;
      const e = await this.client.core.storage.getKeys();
      for (const i3 of e) i3.startsWith(U3) && await this.client.core.storage.removeItem(i3);
    } catch (e) {
      this.logger.warn("Failed to cleanup storage", e);
    }
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConnectorControllerUtil.js
function checkNamespaceConnectorId(namespace, connectorId) {
  return ConnectorController.getConnectorId(namespace) === connectorId;
}

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ChainControllerUtil.js
function getChainsToDisconnect(namespace) {
  const namespaces = Array.from(ChainController.state.chains.keys());
  let chains = [];
  if (namespace) {
    chains.push([namespace, ChainController.state.chains.get(namespace)]);
    if (checkNamespaceConnectorId(namespace, ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT)) {
      namespaces.forEach((ns2) => {
        if (ns2 !== namespace && checkNamespaceConnectorId(ns2, ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT)) {
          chains.push([ns2, ChainController.state.chains.get(ns2)]);
        }
      });
    } else if (checkNamespaceConnectorId(namespace, ConstantsUtil.CONNECTOR_ID.AUTH)) {
      namespaces.forEach((ns2) => {
        if (ns2 !== namespace && checkNamespaceConnectorId(ns2, ConstantsUtil.CONNECTOR_ID.AUTH)) {
          chains.push([ns2, ChainController.state.chains.get(ns2)]);
        }
      });
    }
  } else {
    chains = Array.from(ChainController.state.chains.entries());
  }
  return chains;
}

// node_modules/@reown/appkit/dist/esm/src/utils/ConstantsUtil.js
var WcConstantsUtil = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3,
  ERROR_INVALID_CHAIN_ID: 32603,
  DEFAULT_ALLOWED_ANCESTORS: [
    "http://localhost:*",
    "https://*.pages.dev",
    "https://*.vercel.app",
    "https://*.ngrok-free.app",
    "https://secure-mobile.walletconnect.com",
    "https://secure-mobile.walletconnect.org"
  ]
};

// node_modules/@reown/appkit/dist/esm/src/networks/utils.js
function defineChain2(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solana.js
var solana = defineChain2({
  id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  name: "Solana",
  network: "solana-mainnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: false,
  chainNamespace: "solana",
  caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"
});

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaDevnet.js
var solanaDevnet = defineChain2({
  id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  name: "Solana Devnet",
  network: "solana-devnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
});

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaTestnet.js
var solanaTestnet = defineChain2({
  id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  network: "solana-testnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
});

// node_modules/@reown/appkit/dist/esm/src/networks/bitcoin.js
var bitcoin = defineChain2({
  id: "000000000019d6689c085ae165831e93",
  caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
  chainNamespace: "bip122",
  name: "Bitcoin",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  }
});
var bitcoinTestnet = defineChain2({
  id: "000000000933ea01ad0ee984209779ba",
  caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
  chainNamespace: "bip122",
  name: "Bitcoin Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  testnet: true
});

// node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js
var DEFAULT_METHODS = {
  solana: [
    "solana_signMessage",
    "solana_signTransaction",
    "solana_requestAccounts",
    "solana_getAccounts",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction"
  ],
  eip155: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    // EIP-5792
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_sendCalls",
    "wallet_getCapabilities",
    // EIP-7715
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    //EIP-7811
    "wallet_getAssets"
  ],
  bip122: ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"]
};
var WcHelpersUtil = {
  getMethodsByChainNamespace(chainNamespace) {
    return DEFAULT_METHODS[chainNamespace] || [];
  },
  createDefaultNamespace(chainNamespace) {
    return {
      methods: this.getMethodsByChainNamespace(chainNamespace),
      events: ["accountsChanged", "chainChanged"],
      chains: [],
      rpcMap: {}
    };
  },
  applyNamespaceOverrides(baseNamespaces, overrides) {
    if (!overrides) {
      return { ...baseNamespaces };
    }
    const result = { ...baseNamespaces };
    const namespacesToOverride = /* @__PURE__ */ new Set();
    if (overrides.methods) {
      Object.keys(overrides.methods).forEach((ns2) => namespacesToOverride.add(ns2));
    }
    if (overrides.chains) {
      Object.keys(overrides.chains).forEach((ns2) => namespacesToOverride.add(ns2));
    }
    if (overrides.events) {
      Object.keys(overrides.events).forEach((ns2) => namespacesToOverride.add(ns2));
    }
    if (overrides.rpcMap) {
      Object.keys(overrides.rpcMap).forEach((chainId) => {
        const [ns2] = chainId.split(":");
        if (ns2) {
          namespacesToOverride.add(ns2);
        }
      });
    }
    namespacesToOverride.forEach((ns2) => {
      if (!result[ns2]) {
        result[ns2] = this.createDefaultNamespace(ns2);
      }
    });
    if (overrides.methods) {
      Object.entries(overrides.methods).forEach(([ns2, methods]) => {
        if (result[ns2]) {
          result[ns2].methods = methods;
        }
      });
    }
    if (overrides.chains) {
      Object.entries(overrides.chains).forEach(([ns2, chains]) => {
        if (result[ns2]) {
          result[ns2].chains = chains;
        }
      });
    }
    if (overrides.events) {
      Object.entries(overrides.events).forEach(([ns2, events]) => {
        if (result[ns2]) {
          result[ns2].events = events;
        }
      });
    }
    if (overrides.rpcMap) {
      const processedNamespaces = /* @__PURE__ */ new Set();
      Object.entries(overrides.rpcMap).forEach(([chainId, rpcUrl]) => {
        const [ns2, id] = chainId.split(":");
        if (!ns2 || !id || !result[ns2]) {
          return;
        }
        if (!result[ns2].rpcMap) {
          result[ns2].rpcMap = {};
        }
        if (!processedNamespaces.has(ns2)) {
          result[ns2].rpcMap = {};
          processedNamespaces.add(ns2);
        }
        result[ns2].rpcMap[id] = rpcUrl;
      });
    }
    return result;
  },
  createNamespaces(caipNetworks, configOverride) {
    const defaultNamespaces = caipNetworks.reduce((acc, chain) => {
      const { id, chainNamespace, rpcUrls } = chain;
      const rpcUrl = rpcUrls.default.http[0];
      if (!acc[chainNamespace]) {
        acc[chainNamespace] = this.createDefaultNamespace(chainNamespace);
      }
      const caipNetworkId = `${chainNamespace}:${id}`;
      const namespace = acc[chainNamespace];
      namespace.chains.push(caipNetworkId);
      switch (caipNetworkId) {
        case solana.caipNetworkId:
          namespace.chains.push(solana.deprecatedCaipNetworkId);
          break;
        case solanaDevnet.caipNetworkId:
          namespace.chains.push(solanaDevnet.deprecatedCaipNetworkId);
          break;
        default:
      }
      if (namespace?.rpcMap && rpcUrl) {
        namespace.rpcMap[id] = rpcUrl;
      }
      return acc;
    }, {});
    return this.applyNamespaceOverrides(defaultNamespaces, configOverride);
  },
  resolveReownName: async (name) => {
    const wcNameAddress = await EnsController.resolveName(name);
    const networkNameAddresses = Object.values(wcNameAddress?.addresses) || [];
    return networkNameAddresses[0]?.address || false;
  },
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const [chainNamespace, chainId] = account.split(":");
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  },
  isSessionEventData(data) {
    return typeof data === "object" && data !== null && "id" in data && "topic" in data && "params" in data && typeof data.params === "object" && data.params !== null && "chainId" in data.params && "event" in data.params && typeof data.params.event === "object" && data.params.event !== null;
  },
  isOriginAllowed(currentOrigin, allowedPatterns, defaultAllowedOrigins) {
    for (const pattern of [...allowedPatterns, ...defaultAllowedOrigins]) {
      if (pattern.includes("*")) {
        const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
        const regexString = `^${escapedPattern.replace(/\\\*/gu, ".*")}$`;
        const regex = new RegExp(regexString, "u");
        if (regex.test(currentOrigin)) {
          return true;
        }
      } else {
        try {
          if (new URL(pattern).origin === currentOrigin) {
            return true;
          }
        } catch (e) {
          if (pattern === currentOrigin) {
            return true;
          }
        }
      }
    }
    return false;
  }
};

// node_modules/@reown/appkit/dist/esm/src/connectors/WalletConnectConnector.js
var WalletConnectConnector = class {
  constructor({ provider, namespace }) {
    this.id = ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
    this.name = PresetsUtil.ConnectorNamesMap[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.type = "WALLET_CONNECT";
    this.imageId = PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.getCaipNetworks = ChainController.getCaipNetworks.bind(ChainController);
    this.caipNetworks = this.getCaipNetworks();
    this.provider = provider;
    this.chain = namespace;
  }
  get chains() {
    return this.getCaipNetworks();
  }
  async connectWalletConnect() {
    const isAuthenticated = await this.authenticate();
    if (!isAuthenticated) {
      const caipNetworks = this.getCaipNetworks();
      const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
      const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
      await this.provider.connect({ optionalNamespaces: namespaces });
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session
    };
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const chains = this.chains.map((network) => network.caipNetworkId);
    return SIWXUtil.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains,
      methods: OPTIONAL_METHODS
    });
  }
};
var OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  // EIP-5792
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  // EIP-7715
  "wallet_grantPermissions",
  "wallet_revokePermissions",
  //EIP-7811
  "wallet_getAssets"
];

// node_modules/@reown/appkit/dist/esm/src/adapters/ChainAdapterBlueprint.js
var AdapterBlueprint = class {
  /**
   * Creates an instance of AdapterBlueprint.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  constructor(params) {
    this.availableConnectors = [];
    this.eventListeners = /* @__PURE__ */ new Map();
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    if (params) {
      this.construct(params);
    }
  }
  /**
   * Initializes the adapter with the given parameters.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  construct(params) {
    this.projectId = params.projectId;
    this.namespace = params.namespace;
    this.adapterType = params.adapterType;
  }
  /**
   * Gets the available connectors.
   * @returns {Connector[]} An array of available connectors
   */
  get connectors() {
    return this.availableConnectors;
  }
  /**
   * Gets the supported networks.
   * @returns {CaipNetwork[]} An array of supported networks
   */
  get networks() {
    return this.getCaipNetworks(this.namespace);
  }
  /**
   * Sets the auth provider.
   * @param {W3mFrameProvider} authProvider - The auth provider instance
   */
  setAuthProvider(authProvider) {
    this.addConnector({
      id: ConstantsUtil.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
      provider: authProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Adds one or more connectors to the available connectors list.
   * @param {...Connector} connectors - The connectors to add
   */
  addConnector(...connectors) {
    const connectorsAdded = /* @__PURE__ */ new Set();
    this.availableConnectors = [...connectors, ...this.availableConnectors].filter((connector) => {
      if (connectorsAdded.has(connector.id)) {
        return false;
      }
      connectorsAdded.add(connector.id);
      return true;
    });
    this.emit("connectors", this.availableConnectors);
  }
  setStatus(status, chainNamespace) {
    AccountController.setStatus(status, chainNamespace);
  }
  /**
   * Adds an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
   */
  on(eventName, callback) {
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    this.eventListeners.get(eventName)?.add(callback);
  }
  /**
   * Removes an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be removed
   */
  off(eventName, callback) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.delete(callback);
    }
  }
  /**
   * Removes all event listeners.
   */
  removeAllEventListeners() {
    this.eventListeners.forEach((listeners) => {
      listeners.clear();
    });
  }
  /**
   * Emits an event with the given name and optional data.
   * @template T
   * @param {T} eventName - The name of the event to emit
   * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
   */
  emit(eventName, data) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.forEach((callback) => callback(data));
    }
  }
  /**
   * Connects to WalletConnect.
   * @param {number | string} [_chainId] - Optional chain ID to connect to
   */
  async connectWalletConnect(_chainId) {
    const connector = this.getWalletConnectConnector();
    const result = await connector.connectWalletConnect();
    return { clientId: result.clientId };
  }
  /**
   * Switches the network.
   * @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
   */
  async switchNetwork(params) {
    const { caipNetwork, providerType } = params;
    if (!params.provider) {
      return;
    }
    const provider = "provider" in params.provider ? params.provider.provider : params.provider;
    if (providerType === "WALLET_CONNECT") {
      ;
      provider.setDefaultChain(caipNetwork.caipNetworkId);
      return;
    }
    if (provider && providerType === "AUTH") {
      const authProvider = provider;
      const preferredAccountType = AccountController.state.preferredAccountTypes?.[caipNetwork.chainNamespace];
      await authProvider.switchNetwork(caipNetwork.caipNetworkId);
      const user = await authProvider.getUser({
        chainId: caipNetwork.caipNetworkId,
        preferredAccountType
      });
      this.emit("switchNetwork", user);
    }
  }
  getWalletConnectConnector() {
    const connector = this.connectors.find((c3) => c3 instanceof WalletConnectConnector);
    if (!connector) {
      throw new Error("WalletConnectConnector not found");
    }
    return connector;
  }
};

// node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js
var UniversalAdapter = class extends AdapterBlueprint {
  setUniversalProvider(universalProvider) {
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.getCaipNetworks(),
      namespace: this.namespace
    }));
  }
  async connect(params) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(params.chainId),
      provider: this.provider,
      address: ""
    });
  }
  async disconnect() {
    try {
      const connector = this.getWalletConnectConnector();
      await connector.disconnect();
    } catch (error) {
      console.warn("UniversalAdapter:disconnect - error", error);
    }
  }
  async getAccounts({ namespace }) {
    const provider = this.provider;
    const addresses = provider?.session?.namespaces?.[namespace]?.accounts?.map((account) => {
      const [, , address] = account.split(":");
      return address;
    }).filter((address, index, self2) => self2.indexOf(address) === index) || [];
    return Promise.resolve({
      accounts: addresses.map((address) => CoreHelperUtil.createAccount(namespace, address, namespace === "bip122" ? "payment" : "eoa"))
    });
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance(params) {
    const isBalanceSupported = params.caipNetwork && ConstantsUtil2.BALANCE_SUPPORTED_CHAINS.includes(params.caipNetwork?.chainNamespace);
    if (!isBalanceSupported || params.caipNetwork?.testnet) {
      return {
        balance: "0.00",
        symbol: params.caipNetwork?.nativeCurrency.symbol || ""
      };
    }
    if (AccountController.state.balanceLoading && params.chainId === ChainController.state.activeCaipNetwork?.id) {
      return {
        balance: AccountController.state.balance || "0.00",
        symbol: AccountController.state.balanceSymbol || ""
      };
    }
    const balances = await AccountController.fetchTokenBalance();
    const balance = balances.find((b5) => b5.chainId === `${params.caipNetwork?.chainNamespace}:${params.chainId}` && b5.symbol === params.caipNetwork?.nativeCurrency.symbol);
    return {
      balance: balance?.quantity.numeric || "0.00",
      symbol: balance?.symbol || params.caipNetwork?.nativeCurrency.symbol || ""
    };
  }
  async signMessage(params) {
    const { provider, message, address } = params;
    if (!provider) {
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    }
    let signature = "";
    if (ChainController.state.activeCaipNetwork?.chainNamespace === ConstantsUtil.CHAIN.SOLANA) {
      const response = await provider.request({
        method: "solana_signMessage",
        params: {
          message: esm_default.encode(new TextEncoder().encode(message)),
          pubkey: address
        }
      }, ChainController.state.activeCaipNetwork?.caipNetworkId);
      signature = response.signature;
    } else {
      signature = await provider.request({
        method: "personal_sign",
        params: [message, address]
      }, ChainController.state.activeCaipNetwork?.caipNetworkId);
    }
    return { signature };
  }
  // -- Transaction methods ---------------------------------------------------
  /**
   *
   * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
   * These function definition is to have a type parity between the clients. Currently not in use.
   */
  async estimateGas() {
    return Promise.resolve({
      gas: BigInt(0)
    });
  }
  async sendTransaction() {
    return Promise.resolve({
      hash: ""
    });
  }
  walletGetAssets(_params) {
    return Promise.resolve({});
  }
  async writeContract() {
    return Promise.resolve({
      hash: ""
    });
  }
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: ""
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async switchNetwork(params) {
    const { caipNetwork } = params;
    const connector = this.getWalletConnectConnector();
    if (caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
      try {
        await connector.provider?.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: toHex(caipNetwork.id) }]
        });
      } catch (switchError) {
        if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || switchError?.data?.originalError?.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
          try {
            await connector.provider?.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: toHex(caipNetwork.id),
                  rpcUrls: [caipNetwork?.rpcUrls["chainDefault"]?.http],
                  chainName: caipNetwork.name,
                  nativeCurrency: caipNetwork.nativeCurrency,
                  blockExplorerUrls: [caipNetwork.blockExplorers?.default.url]
                }
              ]
            });
          } catch (error) {
            throw new Error("Chain is not supported");
          }
        }
      }
    }
    connector.provider.setDefaultChain(caipNetwork.caipNetworkId);
  }
  getWalletConnectProvider() {
    const connector = this.connectors.find((c3) => c3.type === "WALLET_CONNECT");
    const provider = connector?.provider;
    return provider;
  }
};

// node_modules/@reown/appkit/dist/esm/src/utils/ConfigUtil.js
var FEATURE_KEYS = [
  "email",
  "socials",
  "swaps",
  "onramp",
  "activity",
  "reownBranding"
];
var featureConfig = {
  email: {
    apiFeatureName: "social_login",
    localFeatureName: "email",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.includes("email");
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.email;
      }
      return Boolean(localValue);
    }
  },
  socials: {
    apiFeatureName: "social_login",
    localFeatureName: "socials",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config.filter((s) => s !== "email") : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials : false;
      }
      return localValue;
    }
  },
  swaps: {
    apiFeatureName: "swap",
    localFeatureName: "swaps",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps : false;
      }
      return localValue;
    }
  },
  onramp: {
    apiFeatureName: "onramp",
    localFeatureName: "onramp",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp : false;
      }
      return localValue;
    }
  },
  activity: {
    apiFeatureName: "activity",
    localFeatureName: "history",
    returnType: false,
    isLegacy: true,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.activity;
      }
      return Boolean(localValue);
    }
  },
  reownBranding: {
    apiFeatureName: "reown_branding",
    localFeatureName: "reownBranding",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.reownBranding;
      }
      return Boolean(localValue);
    }
  }
};
var ConfigUtil = {
  localSettingsOverridden: /* @__PURE__ */ new Set(),
  getApiConfig(id, apiProjectConfig) {
    return apiProjectConfig?.find((f7) => f7.id === id);
  },
  addWarning(localFeatureValue, featureKey) {
    if (localFeatureValue !== void 0) {
      const config = featureConfig[featureKey];
      const warningName = config.isLegacy ? `"features.${config.localFeatureName}" (now "${featureKey}")` : `"features.${featureKey}"`;
      this.localSettingsOverridden.add(warningName);
    }
  },
  processFeature(featureKey, localFeatures, apiProjectConfig, useApi, isBasic) {
    const config = featureConfig[featureKey];
    const localValue = localFeatures[config.localFeatureName];
    if (isBasic && !config.isAvailableOnBasic) {
      return false;
    }
    if (useApi) {
      const apiConfig = this.getApiConfig(config.apiFeatureName, apiProjectConfig);
      if (apiConfig?.config === null) {
        return this.processFallbackFeature(featureKey, localValue);
      }
      if (!apiConfig?.config) {
        return false;
      }
      if (localValue !== void 0) {
        this.addWarning(localValue, featureKey);
      }
      return this.processApiFeature(featureKey, apiConfig);
    }
    return this.processFallbackFeature(featureKey, localValue);
  },
  processApiFeature(featureKey, apiConfig) {
    return featureConfig[featureKey].processApi(apiConfig);
  },
  processFallbackFeature(featureKey, localValue) {
    return featureConfig[featureKey].processFallback(localValue);
  },
  async fetchRemoteFeatures(config) {
    const isBasic = config.basic ?? false;
    const localFeatures = config.features || {};
    this.localSettingsOverridden.clear();
    let apiProjectConfig = null;
    let useApiConfig = false;
    try {
      apiProjectConfig = await ApiController.fetchProjectConfig();
      useApiConfig = apiProjectConfig !== null && apiProjectConfig !== void 0;
    } catch (e) {
      console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.", e);
    }
    const remoteFeaturesConfig = useApiConfig && !isBasic ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES : ConstantsUtil2.DEFAULT_REMOTE_FEATURES_DISABLED;
    try {
      for (const featureKey of FEATURE_KEYS) {
        const result = this.processFeature(featureKey, localFeatures, apiProjectConfig, useApiConfig, isBasic);
        Object.assign(remoteFeaturesConfig, { [featureKey]: result });
      }
    } catch (e) {
      console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.", e);
      return ConstantsUtil2.DEFAULT_REMOTE_FEATURES;
    }
    if (useApiConfig && this.localSettingsOverridden.size > 0) {
      const warningMessage = `Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;
      AlertController.open({
        shortMessage: "Local configuration ignored",
        longMessage: `[Reown Config Notice] ${warningMessage}`
      }, "warning");
    }
    return remoteFeaturesConfig;
  }
};

// node_modules/@reown/appkit/dist/esm/src/client/appkit-base-client.js
var AppKitBaseClient = class {
  constructor(options) {
    this.chainNamespaces = [];
    this.remoteFeatures = {};
    this.reportedAlertErrors = {};
    this.getCaipNetwork = (chainNamespace, id) => {
      if (chainNamespace) {
        const caipNetworkWithId = ChainController.getNetworkData(chainNamespace)?.requestedCaipNetworks?.find((c3) => c3.id === id);
        if (caipNetworkWithId) {
          return caipNetworkWithId;
        }
        const namespaceCaipNetwork = ChainController.getNetworkData(chainNamespace)?.caipNetwork;
        if (namespaceCaipNetwork) {
          return namespaceCaipNetwork;
        }
        const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(chainNamespace);
        return requestedCaipNetworks.filter((c3) => c3.chainNamespace === chainNamespace)?.[0];
      }
      return ChainController.state.activeCaipNetwork || this.defaultCaipNetwork;
    };
    this.getCaipNetworkId = () => {
      const network = this.getCaipNetwork();
      if (network) {
        return network.id;
      }
      return void 0;
    };
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    this.getActiveChainNamespace = () => ChainController.state.activeChain;
    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
      ChainController.setRequestedCaipNetworks(requestedCaipNetworks, chain);
    };
    this.getApprovedCaipNetworkIds = () => ChainController.getAllApprovedCaipNetworkIds();
    this.getCaipAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return ChainController.state.activeCaipAddress;
      }
      return ChainController.getAccountProp("caipAddress", chainNamespace);
    };
    this.setClientId = (clientId) => {
      BlockchainApiController.setClientId(clientId);
    };
    this.getProvider = (namespace) => ProviderUtil.getProvider(namespace);
    this.getProviderType = (namespace) => ProviderUtil.getProviderId(namespace);
    this.getPreferredAccountType = (namespace) => AccountController.state.preferredAccountTypes?.[namespace];
    this.setCaipAddress = (caipAddress, chain) => {
      AccountController.setCaipAddress(caipAddress, chain);
      if (caipAddress && OptionsController.state.enableEmbedded) {
        this.close();
      }
    };
    this.setBalance = (balance, balanceSymbol, chain) => {
      AccountController.setBalance(balance, balanceSymbol, chain);
    };
    this.setProfileName = (profileName, chain) => {
      AccountController.setProfileName(profileName, chain);
    };
    this.setProfileImage = (profileImage, chain) => {
      AccountController.setProfileImage(profileImage, chain);
    };
    this.setUser = (user, chain) => {
      AccountController.setUser(user, chain);
    };
    this.resetAccount = (chain) => {
      AccountController.resetAccount(chain);
    };
    this.setCaipNetwork = (caipNetwork) => {
      ChainController.setActiveCaipNetwork(caipNetwork);
    };
    this.setCaipNetworkOfNamespace = (caipNetwork, chainNamespace) => {
      ChainController.setChainNetworkData(chainNamespace, { caipNetwork });
    };
    this.setAllAccounts = (addresses, chain) => {
      AccountController.setAllAccounts(addresses, chain);
      OptionsController.setHasMultipleAddresses(addresses?.length > 1);
    };
    this.setStatus = (status, chain) => {
      AccountController.setStatus(status, chain);
      if (ConnectorController.isConnected()) {
        StorageUtil.setConnectionStatus("connected");
      } else {
        StorageUtil.setConnectionStatus("disconnected");
      }
    };
    this.getAddressByChainNamespace = (chainNamespace) => ChainController.getAccountProp("address", chainNamespace);
    this.setConnectors = (connectors) => {
      const allConnectors = [...ConnectorController.state.allConnectors, ...connectors];
      ConnectorController.setConnectors(allConnectors);
    };
    this.setConnections = (connections, chainNamespace) => {
      ConnectionController.setConnections(connections, chainNamespace);
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.getReownName = (address) => EnsController.getNamesForAddress(address);
    this.getConnectors = () => ConnectorController.getConnectors();
    this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
    this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
      const type = ProviderUtil.getProviderId(chain);
      const walletInfo = connectedWalletInfo ? { ...connectedWalletInfo, type } : void 0;
      AccountController.setConnectedWalletInfo(walletInfo, chain);
    };
    this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);
    this.addAddressLabel = (address, label, chain) => {
      AccountController.addAddressLabel(address, label, chain);
    };
    this.removeAddressLabel = (address, chain) => {
      AccountController.removeAddressLabel(address, chain);
    };
    this.getAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return AccountController.state.address;
      }
      return ChainController.getAccountProp("address", chainNamespace);
    };
    this.setApprovedCaipNetworksData = (namespace) => ChainController.setApprovedCaipNetworksData(namespace);
    this.resetNetwork = (namespace) => {
      ChainController.resetNetwork(namespace);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl, chain);
    };
    this.setSmartAccountDeployed = (isDeployed, chain) => {
      AccountController.setSmartAccountDeployed(isDeployed, chain);
    };
    this.setSmartAccountEnabledNetworks = (smartAccountEnabledNetworks, chain) => {
      ChainController.setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain);
    };
    this.setPreferredAccountType = (preferredAccountType, chain) => {
      AccountController.setPreferredAccountType(preferredAccountType, chain);
    };
    this.setEIP6963Enabled = (enabled) => {
      OptionsController.setEIP6963Enabled(enabled);
    };
    this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty()) {
          return;
        }
        this.redirect("ApproveTransaction");
      } else {
        this.open({ view: "ApproveTransaction" });
      }
    };
    this.options = options;
    this.version = options.sdkVersion;
    this.caipNetworks = this.extendCaipNetworks(options);
    this.chainNamespaces = this.getChainNamespacesSet(options.adapters, this.caipNetworks);
    this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);
    this.chainAdapters = this.createAdapters(options.adapters);
    this.readyPromise = this.initialize(options);
  }
  getChainNamespacesSet(adapters, caipNetworks) {
    const adapterNamespaces = adapters?.map((adapter) => adapter.namespace).filter((namespace) => Boolean(namespace));
    if (adapterNamespaces?.length) {
      return [...new Set(adapterNamespaces)];
    }
    const networkNamespaces = caipNetworks?.map((network) => network.chainNamespace);
    return [...new Set(networkNamespaces)];
  }
  async initialize(options) {
    this.initializeProjectSettings(options);
    this.initControllers(options);
    await this.initChainAdapters();
    this.sendInitializeEvent(options);
    await this.syncExistingConnection();
    this.remoteFeatures = await ConfigUtil.fetchRemoteFeatures(options);
    OptionsController.setRemoteFeatures(this.remoteFeatures);
    if (this.remoteFeatures.onramp) {
      OnRampController.setOnrampProviders(this.remoteFeatures.onramp);
    }
    if (OptionsController.state.remoteFeatures?.email || Array.isArray(OptionsController.state.remoteFeatures?.socials) && OptionsController.state.remoteFeatures?.socials.length > 0) {
      await this.checkAllowedOrigins();
    }
  }
  async checkAllowedOrigins() {
    const allowedOrigins = await ApiController.fetchAllowedOrigins();
    if (allowedOrigins && CoreHelperUtil.isClient()) {
      const currentOrigin = window.location.origin;
      const isOriginAllowed = WcHelpersUtil.isOriginAllowed(currentOrigin, allowedOrigins, WcConstantsUtil.DEFAULT_ALLOWED_ANCESTORS);
      if (!isOriginAllowed) {
        AlertController.open(ErrorUtil.ALERT_ERRORS.INVALID_APP_CONFIGURATION, "error");
      }
    } else {
      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
    }
  }
  sendInitializeEvent(options) {
    const { ...optionsCopy } = options;
    delete optionsCopy.adapters;
    delete optionsCopy.universalProvider;
    EventsController.sendEvent({
      type: "track",
      event: "INITIALIZE",
      properties: {
        ...optionsCopy,
        networks: options.networks.map((n2) => n2.id),
        siweConfig: {
          options: options.siweConfig?.options || {}
        }
      }
    });
  }
  // -- Controllers initialization ---------------------------------------------------
  initControllers(options) {
    this.initializeOptionsController(options);
    this.initializeChainController(options);
    this.initializeThemeController(options);
    this.initializeConnectionController(options);
    this.initializeConnectorController();
  }
  initializeThemeController(options) {
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
  }
  initializeChainController(options) {
    if (!this.connectionControllerClient || !this.networkControllerClient) {
      throw new Error("ConnectionControllerClient and NetworkControllerClient must be set");
    }
    ChainController.initialize(options.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    });
    const network = this.getDefaultNetwork();
    if (network) {
      ChainController.setActiveCaipNetwork(network);
    }
  }
  initializeConnectionController(options) {
    ConnectionController.setWcBasic(options.basic ?? false);
  }
  initializeConnectorController() {
    ConnectorController.initialize(this.chainNamespaces);
  }
  initializeProjectSettings(options) {
    OptionsController.setProjectId(options.projectId);
    OptionsController.setSdkVersion(options.sdkVersion);
  }
  initializeOptionsController(options) {
    OptionsController.setDebug(options.debug !== false);
    OptionsController.setEnableWalletConnect(options.enableWalletConnect !== false);
    OptionsController.setEnableWalletGuide(options.enableWalletGuide !== false);
    OptionsController.setEnableWallets(options.enableWallets !== false);
    OptionsController.setEIP6963Enabled(options.enableEIP6963 !== false);
    OptionsController.setEnableNetworkSwitch(options.enableNetworkSwitch !== false);
    OptionsController.setEnableAuthLogger(options.enableAuthLogger !== false);
    OptionsController.setCustomRpcUrls(options.customRpcUrls);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setAllWallets(options.allWallets);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setFeatures(options.features);
    OptionsController.setAllowUnsupportedChain(options.allowUnsupportedChain);
    OptionsController.setUniversalProviderConfigOverride(options.universalProviderConfigOverride);
    OptionsController.setPreferUniversalLinks(options.experimental_preferUniversalLinks);
    OptionsController.setDefaultAccountTypes(options.defaultAccountTypes);
    const storedAccountTypes = StorageUtil.getPreferredAccountTypes() || {};
    const defaultTypes = { ...OptionsController.state.defaultAccountTypes, ...storedAccountTypes };
    AccountController.setPreferredAccountTypes(defaultTypes);
    const defaultMetaData = this.getDefaultMetaData();
    if (!options.metadata && defaultMetaData) {
      options.metadata = defaultMetaData;
    }
    OptionsController.setMetadata(options.metadata);
    OptionsController.setDisableAppend(options.disableAppend);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setSIWX(options.siwx);
    if (!options.projectId) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    const evmAdapter = options.adapters?.find((adapter) => adapter.namespace === ConstantsUtil.CHAIN.EVM);
    if (evmAdapter) {
      if (options.siweConfig) {
        if (options.siwx) {
          throw new Error("Cannot set both `siweConfig` and `siwx` options");
        }
        OptionsController.setSIWX(options.siweConfig.mapToSIWX());
      }
    }
  }
  getDefaultMetaData() {
    if (CoreHelperUtil.isClient()) {
      return {
        name: document.getElementsByTagName("title")?.[0]?.textContent || "",
        description: document.querySelector('meta[property="og:description"]')?.content || "",
        url: window.location.origin,
        icons: [document.querySelector('link[rel~="icon"]')?.href || ""]
      };
    }
    return null;
  }
  // -- Network Initialization ---------------------------------------------------
  setUnsupportedNetwork(chainId) {
    const namespace = this.getActiveChainNamespace();
    if (namespace) {
      const unsupportedNetwork = CaipNetworksUtil.getUnsupportedNetwork(`${namespace}:${chainId}`);
      ChainController.setActiveCaipNetwork(unsupportedNetwork);
    }
  }
  getDefaultNetwork() {
    return CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork);
  }
  extendCaipNetwork(network, options) {
    const extendedNetwork = CaipNetworksUtil.extendCaipNetwork(network, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    });
    return extendedNetwork;
  }
  extendCaipNetworks(options) {
    const extendedNetworks = CaipNetworksUtil.extendCaipNetworks(options.networks, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    });
    return extendedNetworks;
  }
  extendDefaultCaipNetwork(options) {
    const defaultNetwork = options.networks.find((n2) => n2.id === options.defaultNetwork?.id);
    const extendedNetwork = defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    }) : void 0;
    return extendedNetwork;
  }
  async disconnectNamespace(namespace) {
    try {
      const adapter = this.getAdapter(namespace);
      const provider = ProviderUtil.getProvider(namespace);
      const providerType = ProviderUtil.getProviderId(namespace);
      const { caipAddress } = ChainController.getAccountData(namespace) || {};
      this.setLoading(true, namespace);
      if (caipAddress && adapter?.disconnect) {
        await adapter.disconnect({ provider, providerType });
      }
      StorageUtil.removeConnectedNamespace(namespace);
      ProviderUtil.resetChain(namespace);
      this.setUser(void 0, namespace);
      this.setStatus("disconnected", namespace);
      this.setConnectedWalletInfo(void 0, namespace);
      ConnectorController.removeConnectorId(namespace);
      ChainController.resetAccount(namespace);
      ChainController.resetNetwork(namespace);
      this.setLoading(false, namespace);
    } catch (error) {
      this.setLoading(false, namespace);
      throw new Error(`Failed to disconnect chain ${namespace}: ${error.message}`);
    }
  }
  // -- Client Initialization ---------------------------------------------------
  createClients() {
    this.connectionControllerClient = {
      connectWalletConnect: async () => {
        const activeChain = ChainController.state.activeChain;
        const adapter = this.getAdapter(activeChain);
        const chainId = this.getCaipNetwork(activeChain)?.id;
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const result = await adapter.connectWalletConnect(chainId);
        this.close();
        this.setClientId(result?.clientId || null);
        StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);
        this.chainNamespaces.forEach((namespace) => {
          ConnectorController.setConnectorId(ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT, namespace);
        });
        await this.syncWalletConnectAccount();
      },
      connectExternal: async ({ id, info, type, provider, chain, caipNetwork, socialUri }) => {
        const activeChain = ChainController.state.activeChain;
        const chainToUse = chain || activeChain;
        const adapter = this.getAdapter(chainToUse);
        if (chain && chain !== activeChain && !caipNetwork) {
          const toConnectNetwork = this.getCaipNetworks().find((network) => network.chainNamespace === chain);
          if (toConnectNetwork) {
            this.setCaipNetwork(toConnectNetwork);
          }
        }
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const fallbackCaipNetwork = this.getCaipNetwork(chainToUse);
        const res = await adapter.connect({
          id,
          info,
          type,
          provider,
          socialUri,
          chainId: caipNetwork?.id || fallbackCaipNetwork?.id,
          rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0] || fallbackCaipNetwork?.rpcUrls?.default?.http?.[0]
        });
        if (!res) {
          return;
        }
        StorageUtil.addConnectedNamespace(chainToUse);
        this.syncProvider({ ...res, chainNamespace: chainToUse });
        const syncedAccounts = AccountController.state.allAccounts;
        const { accounts } = syncedAccounts?.length > 0 ? (
          // eslint-disable-next-line line-comment-position
          // Using new array else the accounts will have the same reference and react will not re-render
          { accounts: [...syncedAccounts] }
        ) : await adapter.getAccounts({ namespace: chainToUse, id });
        this.setAllAccounts(accounts, chainToUse);
        this.setStatus("connected", chainToUse);
        this.syncConnectedWalletInfo(chainToUse);
      },
      reconnectExternal: async ({ id, info, type, provider }) => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (adapter?.reconnect) {
          await adapter?.reconnect({ id, info, type, provider, chainId: this.getCaipNetwork()?.id });
          StorageUtil.addConnectedNamespace(namespace);
          this.syncConnectedWalletInfo(namespace);
        }
      },
      disconnect: async (chainNamespace) => {
        const chainsToDisconnect = getChainsToDisconnect(chainNamespace);
        try {
          const disconnectResults = await Promise.allSettled(chainsToDisconnect.map(async ([ns2]) => this.disconnectNamespace(ns2)));
          SendController.resetSend();
          ConnectionController.resetWcConnection();
          await SIWXUtil.clearSessions();
          ConnectorController.setFilterByNamespace(void 0);
          const failures = disconnectResults.filter((result) => result.status === "rejected");
          if (failures.length > 0) {
            throw new Error(failures.map((f7) => f7.reason.message).join(", "));
          }
          StorageUtil.deleteConnectedSocialProvider();
          EventsController.sendEvent({
            type: "track",
            event: "DISCONNECT_SUCCESS",
            properties: {
              namespace: chainNamespace || "all"
            }
          });
        } catch (error) {
          throw new Error(`Failed to disconnect chains: ${error.message}`);
        }
      },
      checkInstalled: (ids) => {
        if (!ids) {
          return Boolean(window.ethereum);
        }
        return ids.some((id) => Boolean(window.ethereum?.[String(id)]));
      },
      signMessage: async (message) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const result = await adapter?.signMessage({
          message,
          address: AccountController.state.address,
          provider: ProviderUtil.getProvider(ChainController.state.activeChain)
        });
        return result?.signature || "";
      },
      sendTransaction: async (args) => {
        const namespace = args.chainNamespace;
        if (ConstantsUtil2.SEND_SUPPORTED_NAMESPACES.includes(namespace)) {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const provider = ProviderUtil.getProvider(namespace);
          const result = await adapter?.sendTransaction({
            ...args,
            caipNetwork: this.getCaipNetwork(),
            provider
          });
          return result?.hash || "";
        }
        return "";
      },
      estimateGas: async (args) => {
        if (args.chainNamespace === ConstantsUtil.CHAIN.EVM) {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
          const caipNetwork = this.getCaipNetwork();
          if (!caipNetwork) {
            throw new Error("CaipNetwork is undefined");
          }
          const result = await adapter?.estimateGas({
            ...args,
            provider,
            caipNetwork
          });
          return result?.gas || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        await this.syncIdentity({
          address: AccountController.state.address,
          chainId: Number(this.getCaipNetwork()?.id),
          chainNamespace: ChainController.state.activeChain
        });
        return AccountController.state.profileImage || false;
      },
      getEnsAddress: async (name) => await WcHelpersUtil.resolveReownName(name),
      writeContract: async (args) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const caipNetwork = this.getCaipNetwork();
        const caipAddress = this.getCaipAddress();
        const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
        if (!caipNetwork || !caipAddress) {
          throw new Error("CaipNetwork or CaipAddress is undefined");
        }
        const result = await adapter?.writeContract({ ...args, caipNetwork, provider, caipAddress });
        return result?.hash;
      },
      parseUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return adapter?.parseUnits({ value, decimals }) ?? 0n;
      },
      formatUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return adapter?.formatUnits({ value, decimals }) ?? "0";
      },
      getCapabilities: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await adapter?.getCapabilities(params);
      },
      grantPermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await adapter?.grantPermissions(params);
      },
      revokePermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (adapter?.revokePermissions) {
          return await adapter.revokePermissions(params);
        }
        return "0x";
      },
      walletGetAssets: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await adapter?.walletGetAssets(params) ?? {};
      },
      updateBalance: (namespace) => {
        const caipNetwork = this.getCaipNetwork(namespace);
        if (!caipNetwork || !AccountController.state.address) {
          return;
        }
        this.updateNativeBalance(AccountController.state.address, caipNetwork?.id, namespace);
      }
    };
    this.networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => await this.switchCaipNetwork(caipNetwork),
      // eslint-disable-next-line @typescript-eslint/require-await
      getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
    };
    ConnectionController.setClient(this.connectionControllerClient);
  }
  getApprovedCaipNetworksData() {
    const providerType = ProviderUtil.getProviderId(ChainController.state.activeChain);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const namespaces = this.universalProvider?.session?.namespaces;
      return {
        /*
         * MetaMask Wallet only returns 1 namespace in the session object. This makes it imposible
         * to switch to other networks. Setting supportsAllNetworks to true for MetaMask Wallet
         * will make it possible to switch to other networks.
         */
        supportsAllNetworks: this.universalProvider?.session?.peer?.metadata.name === "MetaMask Wallet",
        approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)
      };
    }
    return { supportsAllNetworks: true, approvedCaipNetworkIds: [] };
  }
  async switchCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    const networkNamespace = caipNetwork.chainNamespace;
    const namespaceAddress = this.getAddressByChainNamespace(caipNetwork.chainNamespace);
    if (namespaceAddress) {
      const provider = ProviderUtil.getProvider(networkNamespace);
      const providerType = ProviderUtil.getProviderId(networkNamespace);
      if (caipNetwork.chainNamespace === ChainController.state.activeChain) {
        const adapter = this.getAdapter(networkNamespace);
        await adapter?.switchNetwork({ caipNetwork, provider, providerType });
      } else {
        this.setCaipNetwork(caipNetwork);
        if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
          this.syncWalletConnectAccount();
        } else {
          const address = this.getAddressByChainNamespace(networkNamespace);
          if (address) {
            this.syncAccount({
              address,
              chainId: caipNetwork.id,
              chainNamespace: networkNamespace
            });
          }
        }
      }
    } else {
      this.setCaipNetwork(caipNetwork);
    }
  }
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(account);
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  }
  // -- Adapter Initialization ---------------------------------------------------
  createAdapters(blueprints) {
    this.createClients();
    return this.chainNamespaces.reduce((adapters, namespace) => {
      const blueprint = blueprints?.find((b5) => b5.namespace === namespace);
      if (blueprint) {
        blueprint.construct({
          namespace,
          projectId: this.options?.projectId,
          networks: this.getCaipNetworks()
        });
        adapters[namespace] = blueprint;
      } else {
        adapters[namespace] = new UniversalAdapter({
          namespace,
          networks: this.getCaipNetworks()
        });
      }
      return adapters;
    }, {});
  }
  async initChainAdapter(namespace) {
    this.onConnectors(namespace);
    this.listenAdapter(namespace);
    await this.chainAdapters?.[namespace].syncConnectors(this.options, this);
    await this.createUniversalProviderForAdapter(namespace);
  }
  async initChainAdapters() {
    await Promise.all(this.chainNamespaces.map(async (namespace) => {
      await this.initChainAdapter(namespace);
    }));
  }
  onConnectors(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    adapter?.on("connectors", this.setConnectors.bind(this));
  }
  listenAdapter(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    if (!adapter) {
      return;
    }
    const connectionStatus = StorageUtil.getConnectionStatus();
    if (connectionStatus === "connected") {
      this.setStatus("connecting", chainNamespace);
    } else if (connectionStatus === "disconnected") {
      StorageUtil.clearAddressCache();
      this.setStatus(connectionStatus, chainNamespace);
    } else {
      this.setStatus(connectionStatus, chainNamespace);
    }
    adapter.on("switchNetwork", ({ address, chainId }) => {
      const caipNetwork = this.getCaipNetworks().find((n2) => n2.id === chainId || n2.caipNetworkId === chainId);
      const isSameNamespace = ChainController.state.activeChain === chainNamespace;
      const accountAddress = ChainController.getAccountProp("address", chainNamespace);
      if (caipNetwork) {
        const account = isSameNamespace && address ? address : accountAddress;
        if (account) {
          this.syncAccount({ address: account, chainId: caipNetwork.id, chainNamespace });
        }
      } else {
        this.setUnsupportedNetwork(chainId);
      }
    });
    adapter.on("disconnect", this.disconnect.bind(this, chainNamespace));
    adapter.on("connections", (connections) => {
      this.setConnections(connections, chainNamespace);
    });
    adapter.on("pendingTransactions", () => {
      const address = AccountController.state.address;
      const activeCaipNetwork = ChainController.state.activeCaipNetwork;
      if (!address || !activeCaipNetwork?.id) {
        return;
      }
      this.updateNativeBalance(address, activeCaipNetwork.id, activeCaipNetwork.chainNamespace);
    });
    adapter.on("accountChanged", ({ address, chainId }) => {
      const isActiveChain = ChainController.state.activeChain === chainNamespace;
      if (isActiveChain && chainId) {
        this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else if (isActiveChain && ChainController.state.activeCaipNetwork?.id) {
        this.syncAccount({
          address,
          chainId: ChainController.state.activeCaipNetwork?.id,
          chainNamespace
        });
      } else {
        this.syncAccountInfo(address, chainId, chainNamespace);
      }
      this.syncAllAccounts(chainNamespace);
    });
  }
  async createUniversalProviderForAdapter(chainNamespace) {
    await this.getUniversalProvider();
    if (this.universalProvider) {
      this.chainAdapters?.[chainNamespace]?.setUniversalProvider?.(this.universalProvider);
    }
  }
  // -- Connection Sync ---------------------------------------------------
  async syncExistingConnection() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => this.syncNamespaceConnection(namespace)));
  }
  async syncNamespaceConnection(namespace) {
    try {
      if (namespace === ConstantsUtil.CHAIN.EVM && CoreHelperUtil.isSafeApp()) {
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.SAFE, namespace);
      }
      const connectorId = ConnectorController.getConnectorId(namespace);
      this.setStatus("connecting", namespace);
      switch (connectorId) {
        case ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:
          await this.syncWalletConnectAccount();
          break;
        case ConstantsUtil.CONNECTOR_ID.AUTH:
          break;
        default:
          await this.syncAdapterConnection(namespace);
      }
    } catch (err) {
      console.warn("AppKit couldn't sync existing connection", err);
      this.setStatus("disconnected", namespace);
    }
  }
  async syncAdapterConnection(namespace) {
    const adapter = this.getAdapter(namespace);
    const connectorId = ConnectorController.getConnectorId(namespace);
    const caipNetwork = this.getCaipNetwork(namespace);
    const connectors = ConnectorController.getConnectors(namespace);
    const connector = connectors.find((c3) => c3.id === connectorId);
    try {
      if (!adapter || !connector) {
        throw new Error(`Adapter or connector not found for namespace ${namespace}`);
      }
      if (!caipNetwork?.id) {
        throw new Error("CaipNetwork not found");
      }
      const connection = await adapter?.syncConnection({
        namespace,
        id: connector.id,
        chainId: caipNetwork.id,
        rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0]
      });
      if (connection) {
        const accounts = await adapter?.getAccounts({
          namespace,
          id: connector.id
        });
        if (accounts && accounts.accounts.length > 0) {
          this.setAllAccounts(accounts.accounts, namespace);
        } else {
          this.setAllAccounts([CoreHelperUtil.createAccount(namespace, connection.address, "eoa")], namespace);
        }
        this.syncProvider({ ...connection, chainNamespace: namespace });
        await this.syncAccount({ ...connection, chainNamespace: namespace });
        this.setStatus("connected", namespace);
      } else {
        this.setStatus("disconnected", namespace);
      }
    } catch (e) {
      this.setStatus("disconnected", namespace);
    }
  }
  async syncWalletConnectAccount() {
    const syncTasks = this.chainNamespaces.map(async (chainNamespace) => {
      const adapter = this.getAdapter(chainNamespace);
      const namespaceAccounts = this.universalProvider?.session?.namespaces?.[chainNamespace]?.accounts || [];
      const activeChainId = ChainController.state.activeCaipNetwork?.id;
      const sessionAddress = namespaceAccounts.find((account) => {
        const { chainId } = ParseUtil.parseCaipAddress(account);
        return chainId === activeChainId?.toString();
      }) || namespaceAccounts[0];
      if (sessionAddress) {
        const caipAddress = ParseUtil.validateCaipAddress(sessionAddress);
        const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
        ProviderUtil.setProviderId(chainNamespace, ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT);
        if (this.caipNetworks && ChainController.state.activeCaipNetwork && adapter?.namespace !== ConstantsUtil.CHAIN.EVM) {
          const provider = adapter?.getWalletConnectProvider({
            caipNetworks: this.getCaipNetworks(),
            provider: this.universalProvider,
            activeCaipNetwork: ChainController.state.activeCaipNetwork
          });
          ProviderUtil.setProvider(chainNamespace, provider);
        } else {
          ProviderUtil.setProvider(chainNamespace, this.universalProvider);
        }
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT, chainNamespace);
        StorageUtil.addConnectedNamespace(chainNamespace);
        this.syncWalletConnectAccounts(chainNamespace);
        await this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else {
        this.setStatus("disconnected", chainNamespace);
      }
      this.syncConnectedWalletInfo(chainNamespace);
      await ChainController.setApprovedCaipNetworksData(chainNamespace);
    });
    await Promise.all(syncTasks);
  }
  syncWalletConnectAccounts(chainNamespace) {
    const addresses = this.universalProvider?.session?.namespaces?.[chainNamespace]?.accounts?.map((account) => {
      const { address } = ParseUtil.parseCaipAddress(account);
      return address;
    }).filter((address, index, self2) => self2.indexOf(address) === index);
    if (addresses) {
      this.setAllAccounts(addresses.map((address) => CoreHelperUtil.createAccount(chainNamespace, address, chainNamespace === "bip122" ? "payment" : "eoa")), chainNamespace);
    }
  }
  syncProvider({ type, provider, id, chainNamespace }) {
    ProviderUtil.setProviderId(chainNamespace, type);
    ProviderUtil.setProvider(chainNamespace, provider);
    ConnectorController.setConnectorId(id, chainNamespace);
  }
  async syncAllAccounts(namespace) {
    const connectorId = ConnectorController.getConnectorId(namespace);
    if (!connectorId) {
      return;
    }
    const adapter = this.getAdapter(namespace);
    const accounts = await adapter?.getAccounts({ namespace, id: connectorId });
    if (accounts && accounts.accounts.length > 0) {
      this.setAllAccounts(accounts.accounts, namespace);
    }
  }
  async syncAccount(params) {
    const isActiveNamespace = params.chainNamespace === ChainController.state.activeChain;
    const networkOfChain = ChainController.getCaipNetworkByNamespace(params.chainNamespace, params.chainId);
    const { address, chainId, chainNamespace } = params;
    const { chainId: activeChainId } = StorageUtil.getActiveNetworkProps();
    const chainIdToUse = chainId || activeChainId;
    const isUnsupportedNetwork = ChainController.state.activeCaipNetwork?.name === ConstantsUtil.UNSUPPORTED_NETWORK_NAME;
    const shouldSupportAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", chainNamespace);
    this.setStatus("connected", chainNamespace);
    if (isUnsupportedNetwork && !shouldSupportAllNetworks) {
      return;
    }
    if (chainIdToUse) {
      let caipNetwork = this.getCaipNetworks().find((n2) => n2.id.toString() === chainIdToUse.toString());
      let fallbackCaipNetwork = this.getCaipNetworks().find((n2) => n2.chainNamespace === chainNamespace);
      if (!shouldSupportAllNetworks && !caipNetwork && !fallbackCaipNetwork) {
        const caipNetworkIds = this.getApprovedCaipNetworkIds() || [];
        const caipNetworkId = caipNetworkIds.find((id) => ParseUtil.parseCaipNetworkId(id)?.chainId === chainIdToUse.toString());
        const fallBackCaipNetworkId = caipNetworkIds.find((id) => ParseUtil.parseCaipNetworkId(id)?.chainNamespace === chainNamespace);
        caipNetwork = this.getCaipNetworks().find((n2) => n2.caipNetworkId === caipNetworkId);
        fallbackCaipNetwork = this.getCaipNetworks().find((n2) => n2.caipNetworkId === fallBackCaipNetworkId || // This is a workaround used in Solana network to support deprecated caipNetworkId
        "deprecatedCaipNetworkId" in n2 && n2.deprecatedCaipNetworkId === fallBackCaipNetworkId);
      }
      const network = caipNetwork || fallbackCaipNetwork;
      if (network?.chainNamespace === ChainController.state.activeChain) {
        if (OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && ChainController.state.activeCaipNetwork?.name === ConstantsUtil.UNSUPPORTED_NETWORK_NAME) {
          ChainController.showUnsupportedChainUI();
        } else {
          this.setCaipNetwork(network);
        }
      } else if (!isActiveNamespace) {
        if (networkOfChain) {
          this.setCaipNetworkOfNamespace(networkOfChain, chainNamespace);
        }
      }
      this.syncConnectedWalletInfo(chainNamespace);
      if (!HelpersUtil.isLowerCaseMatch(address, AccountController.state.address)) {
        this.syncAccountInfo(address, network?.id, chainNamespace);
      }
      if (isActiveNamespace) {
        await this.syncBalance({ address, chainId: network?.id, chainNamespace });
      } else {
        await this.syncBalance({ address, chainId: networkOfChain?.id, chainNamespace });
      }
    }
  }
  async syncAccountInfo(address, chainId, chainNamespace) {
    const caipAddress = this.getCaipAddress(chainNamespace);
    const newChainId = chainId || caipAddress?.split(":")[1];
    if (!newChainId) {
      return;
    }
    const newCaipAddress = `${chainNamespace}:${newChainId}:${address}`;
    this.setCaipAddress(newCaipAddress, chainNamespace);
    await this.syncIdentity({
      address,
      chainId: newChainId,
      chainNamespace
    });
  }
  async syncReownName(address, chainNamespace) {
    try {
      const registeredWcNames = await this.getReownName(address);
      if (registeredWcNames[0]) {
        const wcName = registeredWcNames[0];
        this.setProfileName(wcName.name, chainNamespace);
      } else {
        this.setProfileName(null, chainNamespace);
      }
    } catch {
      this.setProfileName(null, chainNamespace);
    }
  }
  syncConnectedWalletInfo(chainNamespace) {
    const connectorId = ConnectorController.getConnectorId(chainNamespace);
    const providerType = ProviderUtil.getProviderId(chainNamespace);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_ANNOUNCED || providerType === ConstantsUtil3.CONNECTOR_TYPE_INJECTED) {
      if (connectorId) {
        const connector = this.getConnectors().find((c3) => c3.id === connectorId);
        if (connector) {
          const { info, name, imageUrl } = connector;
          const icon = imageUrl || this.getConnectorImage(connector);
          this.setConnectedWalletInfo({ name, icon, ...info }, chainNamespace);
        }
      }
    } else if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const provider = ProviderUtil.getProvider(chainNamespace);
      if (provider?.session) {
        this.setConnectedWalletInfo({
          ...provider.session.peer.metadata,
          name: provider.session.peer.metadata.name,
          icon: provider.session.peer.metadata.icons?.[0]
        }, chainNamespace);
      }
    } else if (connectorId) {
      if (connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE) {
        const connector = this.getConnectors().find((c3) => c3.id === ConstantsUtil.CONNECTOR_ID.COINBASE);
        this.setConnectedWalletInfo({ name: "Coinbase Wallet", icon: this.getConnectorImage(connector) }, chainNamespace);
      }
    }
  }
  async syncBalance(params) {
    const caipNetwork = NetworkUtil.getNetworksByNamespace(this.getCaipNetworks(), params.chainNamespace).find((n2) => n2.id.toString() === params.chainId?.toString());
    if (!caipNetwork || !params.chainId) {
      return;
    }
    await this.updateNativeBalance(params.address, params.chainId, params.chainNamespace);
  }
  async ready() {
    await this.readyPromise;
  }
  async updateNativeBalance(address, chainId, namespace) {
    const adapter = this.getAdapter(namespace);
    const caipNetwork = ChainController.getCaipNetworkByNamespace(namespace, chainId);
    if (adapter) {
      const balance = await adapter.getBalance({
        address,
        chainId,
        caipNetwork,
        tokens: this.options.tokens
      });
      this.setBalance(balance.balance, balance.symbol, namespace);
      return balance;
    }
    return void 0;
  }
  // -- Universal Provider ---------------------------------------------------
  async initializeUniversalAdapter() {
    const logger = LoggerUtil.createLogger((error, ...args) => {
      if (error) {
        this.handleAlertError(error);
      }
      console.error(...args);
    });
    const universalProviderOptions = {
      projectId: this.options?.projectId,
      metadata: {
        name: this.options?.metadata ? this.options?.metadata.name : "",
        description: this.options?.metadata ? this.options?.metadata.description : "",
        url: this.options?.metadata ? this.options?.metadata.url : "",
        icons: this.options?.metadata ? this.options?.metadata.icons : [""]
      },
      logger
    };
    OptionsController.setManualWCControl(Boolean(this.options?.manualWCControl));
    this.universalProvider = this.options.universalProvider ?? await B2.init(universalProviderOptions);
    this.listenWalletConnect();
  }
  listenWalletConnect() {
    if (this.universalProvider) {
      this.universalProvider.on("display_uri", (uri) => {
        ConnectionController.setUri(uri);
      });
      this.universalProvider.on("connect", ConnectionController.finalizeWcConnection);
      this.universalProvider.on("disconnect", () => {
        this.chainNamespaces.forEach((namespace) => {
          this.resetAccount(namespace);
        });
        ConnectionController.resetWcConnection();
      });
      this.universalProvider.on("chainChanged", (chainId) => {
        const caipNetwork = this.getCaipNetworks().find((c3) => c3.id == chainId);
        const currentCaipNetwork = this.getCaipNetwork();
        if (!caipNetwork) {
          this.setUnsupportedNetwork(chainId);
          return;
        }
        if (currentCaipNetwork?.id !== caipNetwork?.id) {
          this.setCaipNetwork(caipNetwork);
        }
      });
      this.universalProvider.on("session_event", (callbackData) => {
        if (WcHelpersUtil.isSessionEventData(callbackData)) {
          const { name, data } = callbackData.params.event;
          if (name === "accountsChanged" && Array.isArray(data) && CoreHelperUtil.isCaipAddress(data[0])) {
            this.syncAccount(ParseUtil.parseCaipAddress(data[0]));
          }
        }
      });
    }
  }
  createUniversalProvider() {
    if (!this.universalProviderInitPromise && CoreHelperUtil.isClient() && this.options?.projectId) {
      this.universalProviderInitPromise = this.initializeUniversalAdapter();
    }
    return this.universalProviderInitPromise;
  }
  async getUniversalProvider() {
    if (!this.universalProvider) {
      try {
        await this.createUniversalProvider();
      } catch (err) {
        EventsController.sendEvent({
          type: "error",
          event: "INTERNAL_SDK_ERROR",
          properties: {
            errorType: "UniversalProviderInitError",
            errorMessage: err instanceof Error ? err.message : "Unknown",
            uncaught: false
          }
        });
        console.error("AppKit:getUniversalProvider - Cannot create provider", err);
      }
    }
    return this.universalProvider;
  }
  // - Utils -------------------------------------------------------------------
  handleAlertError(error) {
    const matchedUniversalProviderError = Object.entries(ErrorUtil.UniversalProviderErrors).find(([, { message: message2 }]) => error.message.includes(message2));
    const [errorKey, errorValue] = matchedUniversalProviderError ?? [];
    const { message, alertErrorKey } = errorValue ?? {};
    if (errorKey && message && !this.reportedAlertErrors[errorKey]) {
      const alertError = ErrorUtil.ALERT_ERRORS[alertErrorKey];
      if (alertError) {
        AlertController.open(alertError, "error");
        this.reportedAlertErrors[errorKey] = true;
      }
    }
  }
  getAdapter(namespace) {
    if (!namespace) {
      return void 0;
    }
    return this.chainAdapters?.[namespace];
  }
  createAdapter(blueprint) {
    if (!blueprint) {
      return;
    }
    const namespace = blueprint.namespace;
    if (!namespace) {
      return;
    }
    this.createClients();
    const adapterBlueprint = blueprint;
    adapterBlueprint.namespace = namespace;
    adapterBlueprint.construct({
      namespace,
      projectId: this.options?.projectId,
      networks: this.getCaipNetworks()
    });
    if (!this.chainNamespaces.includes(namespace)) {
      this.chainNamespaces.push(namespace);
    }
    if (this.chainAdapters) {
      this.chainAdapters[namespace] = adapterBlueprint;
    }
  }
  // -- Public -------------------------------------------------------------------
  async open(options) {
    await this.injectModalUi();
    if (options?.uri) {
      ConnectionController.setUri(options.uri);
    }
    if (options?.arguments) {
      switch (options?.view) {
        case "Swap":
          return ModalController.open({ ...options, data: { swap: options.arguments } });
        default:
      }
    }
    return ModalController.open(options);
  }
  async close() {
    await this.injectModalUi();
    ModalController.close();
  }
  setLoading(loading, namespace) {
    ModalController.setLoading(loading, namespace);
  }
  async disconnect(chainNamespace) {
    await ConnectionController.disconnect(chainNamespace);
  }
  getSIWX() {
    return OptionsController.state.siwx;
  }
  // -- review these -------------------------------------------------------------------
  getError() {
    return "";
  }
  getChainId() {
    return ChainController.state.activeCaipNetwork?.id;
  }
  async switchNetwork(appKitNetwork) {
    const network = this.getCaipNetworks().find((n2) => n2.id === appKitNetwork.id);
    if (!network) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    await ChainController.switchActiveNetwork(network);
  }
  getWalletProvider() {
    return ChainController.state.activeChain ? ProviderUtil.state.providers[ChainController.state.activeChain] : null;
  }
  getWalletProviderType() {
    return ProviderUtil.getProviderId(ChainController.state.activeChain);
  }
  subscribeProviders(callback) {
    return ProviderUtil.subscribeProviders(callback);
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setTermsConditionsUrl(termsConditionsUrl) {
    OptionsController.setTermsConditionsUrl(termsConditionsUrl);
  }
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    OptionsController.setPrivacyPolicyUrl(privacyPolicyUrl);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  getWalletInfo() {
    return AccountController.state.connectedWalletInfo;
  }
  getAccount(namespace) {
    const authConnector = ConnectorController.getAuthConnector(namespace);
    const accountState = ChainController.getAccountData(namespace);
    const activeChain = ChainController.state.activeChain;
    const activeConnectorId = StorageUtil.getConnectedConnectorId(namespace || activeChain);
    if (!accountState) {
      return void 0;
    }
    return {
      allAccounts: accountState.allAccounts,
      caipAddress: accountState.caipAddress,
      address: CoreHelperUtil.getPlainAddress(accountState.caipAddress),
      isConnected: Boolean(accountState.caipAddress),
      status: accountState.status,
      embeddedWalletInfo: authConnector && activeConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH ? {
        user: accountState.user ? {
          ...accountState.user,
          /*
           * Getting the username from the chain controller works well for social logins,
           * but Farcaster uses a different connection flow and doesn't emit the username via events.
           * Since the username is stored in local storage before the chain controller updates,
           * it's safe to use the local storage value here.
           */
          username: StorageUtil.getConnectedSocialUsername()
        } : void 0,
        authProvider: accountState.socialProvider || "email",
        accountType: accountState.preferredAccountTypes?.[namespace || activeChain],
        isSmartAccountDeployed: Boolean(accountState.smartAccountDeployed)
      } : void 0
    };
  }
  subscribeAccount(callback, namespace) {
    const updateVal = () => {
      const account = this.getAccount(namespace);
      if (!account) {
        return;
      }
      callback(account);
    };
    if (namespace) {
      ChainController.subscribeChainProp("accountState", updateVal, namespace);
    } else {
      ChainController.subscribe(updateVal);
    }
    ConnectorController.subscribe(updateVal);
  }
  subscribeNetwork(callback) {
    return ChainController.subscribe(({ activeCaipNetwork }) => {
      callback({
        caipNetwork: activeCaipNetwork,
        chainId: activeCaipNetwork?.id,
        caipNetworkId: activeCaipNetwork?.caipNetworkId
      });
    });
  }
  subscribeWalletInfo(callback) {
    return AccountController.subscribeKey("connectedWalletInfo", callback);
  }
  subscribeShouldUpdateToAddress(callback) {
    AccountController.subscribeKey("shouldUpdateToAddress", callback);
  }
  subscribeCaipNetworkChange(callback) {
    ChainController.subscribeKey("activeCaipNetwork", callback);
  }
  getState() {
    return PublicStateController.state;
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  showErrorMessage(message) {
    SnackController.showError(message);
  }
  showSuccessMessage(message) {
    SnackController.showSuccess(message);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  replace(route) {
    RouterController.replace(route);
  }
  redirect(route) {
    RouterController.push(route);
  }
  popTransactionStack(status) {
    RouterController.popTransactionStack(status);
  }
  isOpen() {
    return ModalController.state.open;
  }
  isTransactionStackEmpty() {
    return RouterController.state.transactionStack.length === 0;
  }
  static getInstance() {
    return this.instance;
  }
  updateFeatures(newFeatures) {
    OptionsController.setFeatures(newFeatures);
  }
  updateRemoteFeatures(newRemoteFeatures) {
    OptionsController.setRemoteFeatures(newRemoteFeatures);
  }
  updateOptions(newOptions) {
    const currentOptions = OptionsController.state || {};
    const updatedOptions = { ...currentOptions, ...newOptions };
    OptionsController.setOptions(updatedOptions);
  }
  setConnectMethodsOrder(connectMethodsOrder) {
    OptionsController.setConnectMethodsOrder(connectMethodsOrder);
  }
  setWalletFeaturesOrder(walletFeaturesOrder) {
    OptionsController.setWalletFeaturesOrder(walletFeaturesOrder);
  }
  setCollapseWallets(collapseWallets) {
    OptionsController.setCollapseWallets(collapseWallets);
  }
  setSocialsOrder(socialsOrder) {
    OptionsController.setSocialsOrder(socialsOrder);
  }
  getConnectMethodsOrder() {
    return WalletUtil.getConnectOrderMethod(OptionsController.state.features, ConnectorController.getConnectors());
  }
  /**
   * Adds a network to an existing adapter in AppKit.
   * @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')
   * @param network - The network configuration to add
   * @throws Error if adapter for namespace doesn't exist
   */
  addNetwork(namespace, network) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const extendedNetwork = this.extendCaipNetwork(network, this.options);
    if (!this.getCaipNetworks().find((n2) => n2.id === extendedNetwork.id)) {
      ChainController.addNetwork(extendedNetwork);
    }
  }
  /**
   * Removes a network from an existing adapter in AppKit.
   * @param namespace - The chain namespace the network belongs to
   * @param networkId - The network ID to remove
   * @throws Error if adapter for namespace doesn't exist or if removing last network
   */
  removeNetwork(namespace, networkId) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const networkToRemove = this.getCaipNetworks().find((n2) => n2.id === networkId);
    if (!networkToRemove) {
      return;
    }
    ChainController.removeNetwork(namespace, networkId);
  }
};

// node_modules/@reown/appkit/dist/esm/src/client/appkit-core.js
var isInitialized = false;
var AppKit = class extends AppKitBaseClient {
  // -- Overrides --------------------------------------------------------------
  async open(options) {
    const isConnected = ConnectorController.isConnected();
    if (!isConnected) {
      await super.open(options);
    }
  }
  async close() {
    await super.close();
    if (this.options.manualWCControl) {
      ConnectionController.finalizeWcConnection();
    }
  }
  async syncIdentity(_request) {
    return Promise.resolve();
  }
  async syncBalance(_params) {
    return Promise.resolve();
  }
  async injectModalUi() {
    if (!isInitialized && CoreHelperUtil.isClient()) {
      await import("./basic-SM7RFJDT.js");
      await import("./w3m-modal-RMDQMVGH.js");
      const isElementCreated = document.querySelector("w3m-modal");
      if (!isElementCreated) {
        const modal = document.createElement("w3m-modal");
        if (!OptionsController.state.disableAppend && !OptionsController.state.enableEmbedded) {
          document.body.insertAdjacentElement("beforeend", modal);
        }
      }
      isInitialized = true;
    }
  }
};

// node_modules/@reown/appkit/dist/esm/exports/constants.js
var PACKAGE_VERSION = "1.7.8";

// node_modules/@reown/appkit/dist/esm/exports/core.js
function createAppKit(options) {
  return new AppKit({
    ...options,
    basic: true,
    sdkVersion: `html-core-${PACKAGE_VERSION}`
  });
}
export {
  AppKit,
  createAppKit
};
/*! Bundled license information:

@walletconnect/relay-auth/dist/index.es.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
@walletconnect/utils/dist/index.es.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=core-YRQ6C5TI.js.map
