{
  "version": 3,
  "sources": ["../../@web3modal/scaffold-react/index.ts", "../../ox/core/internal/base58.ts", "../../@noble/hashes/src/_blake.ts", "../../@noble/hashes/src/blake2.ts", "../../@noble/hashes/src/blake3.ts", "../../ox/core/Blobs.ts", "../../ox/node_modules/@noble/curves/src/abstract/bls.ts", "../../ox/node_modules/@noble/curves/src/abstract/tower.ts", "../../ox/node_modules/@noble/curves/src/bls12-381.ts", "../../ox/node_modules/@noble/curves/src/abstract/edwards.ts", "../../ox/node_modules/@noble/curves/src/abstract/montgomery.ts", "../../ox/node_modules/@noble/curves/src/ed25519.ts", "../../@noble/ciphers/src/utils.ts", "../../@noble/ciphers/src/_polyval.ts", "../../@noble/ciphers/src/aes.ts", "../../ox/core/RpcResponse.ts", "../../ox/core/Provider.ts", "../../ox/core/Ens.ts", "../../viem/utils/ens/normalize.ts", "../../@web3modal/wagmi/src/client.ts", "../../@web3modal/wagmi/exports/react/index.ts"],
  "sourcesContent": [null, "import * as Bytes from '../Bytes.js'\nimport type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\n\n/** @internal */\nexport const integerToAlphabet =\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\n/** @internal */\nexport const alphabetToInteger = /* __PURE__ */ Object.freeze<\n  Record<string, bigint>\n>({\n  1: 0n,\n  2: 1n,\n  3: 2n,\n  4: 3n,\n  5: 4n,\n  6: 5n,\n  7: 6n,\n  8: 7n,\n  9: 8n,\n  A: 9n,\n  B: 10n,\n  C: 11n,\n  D: 12n,\n  E: 13n,\n  F: 14n,\n  G: 15n,\n  H: 16n,\n  J: 17n,\n  K: 18n,\n  L: 19n,\n  M: 20n,\n  N: 21n,\n  P: 22n,\n  Q: 23n,\n  R: 24n,\n  S: 25n,\n  T: 26n,\n  U: 27n,\n  V: 28n,\n  W: 29n,\n  X: 30n,\n  Y: 31n,\n  Z: 32n,\n  a: 33n,\n  b: 34n,\n  c: 35n,\n  d: 36n,\n  e: 37n,\n  f: 38n,\n  g: 39n,\n  h: 40n,\n  i: 41n,\n  j: 42n,\n  k: 43n,\n  m: 44n,\n  n: 45n,\n  o: 46n,\n  p: 47n,\n  q: 48n,\n  r: 49n,\n  s: 50n,\n  t: 51n,\n  u: 52n,\n  v: 53n,\n  w: 54n,\n  x: 55n,\n  y: 56n,\n  z: 57n,\n})\n\n/** @internal */\nexport function from(value: Hex.Hex | Bytes.Bytes) {\n  let bytes = Bytes.from(value)\n\n  let integer = (() => {\n    let hex = value\n    if (value instanceof Uint8Array) hex = Hex.fromBytes(bytes)\n    return BigInt(hex as string)\n  })()\n\n  let result = ''\n  while (integer > 0n) {\n    const remainder = Number(integer % 58n)\n    integer = integer / 58n\n    result = integerToAlphabet[remainder] + result\n  }\n\n  while (bytes.length > 1 && bytes[0] === 0) {\n    result = '1' + result\n    bytes = bytes.slice(1)\n  }\n\n  return result\n}\n\n/** @internal */\nexport declare namespace from {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\n", "/**\n * Internal helpers for blake hash.\n * @module\n */\nimport { rotr } from './utils.ts';\n\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nexport const BSIGMA: Uint8Array = /* @__PURE__ */ Uint8Array.from([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  // Blake1, unused in others\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n]);\n\n// prettier-ignore\nexport type Num4 = { a: number; b: number; c: number; d: number; };\n\n// Mixing function G splitted in two halfs\nexport function G1s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 16);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 12);\n  return { a, b, c, d };\n}\n\nexport function G2s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 8);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 7);\n  return { a, b, c, d };\n}\n", "/**\n * blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.\n * b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.\n * @module\n */\nimport { BSIGMA, G1s, G2s } from './_blake.ts';\nimport { SHA256_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createOptHasher, Hash, swap32IfBE, swap8IfBE, toBytes, u32,\n  type CHashO, type Input\n} from './utils.ts';\n\n/** Blake hash options. dkLen is output length. key is used in MAC mode. salt is used in KDF mode. */\nexport type Blake2Opts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\n// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.\nconst B2B_IV = /* @__PURE__ */ Uint32Array.from([\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n\n// Mixing function G splitted in two halfs\nfunction G1b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 32)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 24)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction G2b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 16)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 63)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction checkBlake2Opts(\n  outputLen: number,\n  opts: Blake2Opts | undefined = {},\n  keyLen: number,\n  saltLen: number,\n  persLen: number\n) {\n  anumber(keyLen);\n  if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n  const { key, salt, personalization } = opts;\n  if (key !== undefined && (key.length < 1 || key.length > keyLen))\n    throw new Error('key length must be undefined or 1..' + keyLen);\n  if (salt !== undefined && salt.length !== saltLen)\n    throw new Error('salt must be undefined or ' + saltLen);\n  if (personalization !== undefined && personalization.length !== persLen)\n    throw new Error('personalization must be undefined or ' + persLen);\n}\n\n/** Class, from which others are subclassed. */\nexport abstract class BLAKE2<T extends BLAKE2<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected finished = false;\n  protected destroyed = false;\n  protected length: number = 0;\n  protected pos: number = 0;\n  readonly blockLen: number;\n  readonly outputLen: number;\n\n  constructor(blockLen: number, outputLen: number) {\n    super();\n    anumber(blockLen);\n    anumber(outputLen);\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.buffer = new Uint8Array(blockLen);\n    this.buffer32 = u32(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        swap32IfBE(buffer32);\n        this.compress(buffer32, 0, false);\n        swap32IfBE(buffer32);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        swap32IfBE(data32);\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        swap32IfBE(data32);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(pos));\n    swap32IfBE(buffer32);\n    this.compress(buffer32, 0, true);\n    swap32IfBE(buffer32);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = swap8IfBE(v)));\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.buffer.set(buffer);\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    // @ts-ignore\n    to.outputLen = outputLen;\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\nexport class BLAKE2b extends BLAKE2<BLAKE2b> {\n  // Same as SHA-512, but LE\n  private v0l = B2B_IV[0] | 0;\n  private v0h = B2B_IV[1] | 0;\n  private v1l = B2B_IV[2] | 0;\n  private v1h = B2B_IV[3] | 0;\n  private v2l = B2B_IV[4] | 0;\n  private v2h = B2B_IV[5] | 0;\n  private v3l = B2B_IV[6] | 0;\n  private v3h = B2B_IV[7] | 0;\n  private v4l = B2B_IV[8] | 0;\n  private v4h = B2B_IV[9] | 0;\n  private v5l = B2B_IV[10] | 0;\n  private v5h = B2B_IV[11] | 0;\n  private v6l = B2B_IV[12] | 0;\n  private v6h = B2B_IV[13] | 0;\n  private v7l = B2B_IV[14] | 0;\n  private v7h = B2B_IV[15] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 64 : opts.dkLen;\n    super(128, olen);\n    checkBlake2Opts(olen, opts, 64, 16, 16);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt);\n      this.v4l ^= swap8IfBE(slt[0]);\n      this.v4h ^= swap8IfBE(slt[1]);\n      this.v5l ^= swap8IfBE(slt[2]);\n      this.v5h ^= swap8IfBE(slt[3]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization);\n      this.v6l ^= swap8IfBE(pers[0]);\n      this.v6h ^= swap8IfBE(pers[1]);\n      this.v7l ^= swap8IfBE(pers[2]);\n      this.v7h ^= swap8IfBE(pers[3]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n  }\n  // prettier-ignore\n  protected set(\n    v0l: number, v0h: number, v1l: number, v1h: number,\n    v2l: number, v2h: number, v3l: number, v3h: number,\n    v4l: number, v4h: number, v5l: number, v5h: number,\n    v6l: number, v6h: number, v7l: number, v7h: number\n  ): void {\n    this.v0l = v0l | 0;\n    this.v0h = v0h | 0;\n    this.v1l = v1l | 0;\n    this.v1h = v1h | 0;\n    this.v2l = v2l | 0;\n    this.v2h = v2h | 0;\n    this.v3l = v3l | 0;\n    this.v3h = v3h | 0;\n    this.v4l = v4l | 0;\n    this.v4h = v4h | 0;\n    this.v5l = v5l | 0;\n    this.v5h = v5h | 0;\n    this.v6l = v6l | 0;\n    this.v6h = v6h | 0;\n    this.v7l = v7l | 0;\n    this.v7h = v7h | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n    BBUF.set(B2B_IV, 16); // Second half from IV.\n    let { h, l } = u64.fromBig(BigInt(this.length));\n    BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n    BBUF[25] = B2B_IV[9] ^ h; // High word.\n    // Invert all bits for last block\n    if (isLast) {\n      BBUF[28] = ~BBUF[28];\n      BBUF[29] = ~BBUF[29];\n    }\n    let j = 0;\n    const s = BSIGMA;\n    for (let i = 0; i < 12; i++) {\n      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n\n      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n    }\n    this.v0l ^= BBUF[0] ^ BBUF[16];\n    this.v0h ^= BBUF[1] ^ BBUF[17];\n    this.v1l ^= BBUF[2] ^ BBUF[18];\n    this.v1h ^= BBUF[3] ^ BBUF[19];\n    this.v2l ^= BBUF[4] ^ BBUF[20];\n    this.v2h ^= BBUF[5] ^ BBUF[21];\n    this.v3l ^= BBUF[6] ^ BBUF[22];\n    this.v3h ^= BBUF[7] ^ BBUF[23];\n    this.v4l ^= BBUF[8] ^ BBUF[24];\n    this.v4h ^= BBUF[9] ^ BBUF[25];\n    this.v5l ^= BBUF[10] ^ BBUF[26];\n    this.v5h ^= BBUF[11] ^ BBUF[27];\n    this.v6l ^= BBUF[12] ^ BBUF[28];\n    this.v6h ^= BBUF[13] ^ BBUF[29];\n    this.v7l ^= BBUF[14] ^ BBUF[30];\n    this.v7h ^= BBUF[15] ^ BBUF[31];\n    clean(BBUF);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2b: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2b, Blake2Opts>(\n  (opts) => new BLAKE2b(opts)\n);\n\n// =================\n// Blake2S\n// =================\n\n// prettier-ignore\nexport type Num16 = {\n  v0: number; v1: number; v2: number; v3: number;\n  v4: number; v5: number; v6: number; v7: number;\n  v8: number; v9: number; v10: number; v11: number;\n  v12: number; v13: number; v14: number; v15: number;\n};\n\n// prettier-ignore\nexport function compress(s: Uint8Array, offset: number, msg: Uint32Array, rounds: number,\n  v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number,\n  v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number,\n): Num16 {\n  let j = 0;\n  for (let i = 0; i < rounds; i++) {\n    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));\n\n    ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));\n  }\n  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };\n}\n\nconst B2S_IV = SHA256_IV;\nexport class BLAKE2s extends BLAKE2<BLAKE2s> {\n  // Internal state, same as SHA-256\n  private v0 = B2S_IV[0] | 0;\n  private v1 = B2S_IV[1] | 0;\n  private v2 = B2S_IV[2] | 0;\n  private v3 = B2S_IV[3] | 0;\n  private v4 = B2S_IV[4] | 0;\n  private v5 = B2S_IV[5] | 0;\n  private v6 = B2S_IV[6] | 0;\n  private v7 = B2S_IV[7] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 32 : opts.dkLen;\n    super(64, olen);\n    checkBlake2Opts(olen, opts, 32, 8, 8);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0 ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt as Uint8Array);\n      this.v4 ^= swap8IfBE(slt[0]);\n      this.v5 ^= swap8IfBE(slt[1]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization as Uint8Array);\n      this.v6 ^= swap8IfBE(pers[0]);\n      this.v7 ^= swap8IfBE(pers[1]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      abytes(key);\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n    return [v0, v1, v2, v3, v4, v5, v6, v7];\n  }\n  // prettier-ignore\n  protected set(\n    v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number\n  ): void {\n    this.v0 = v0 | 0;\n    this.v1 = v1 | 0;\n    this.v2 = v2 | 0;\n    this.v3 = v3 | 0;\n    this.v4 = v4 | 0;\n    this.v5 = v5 | 0;\n    this.v6 = v6 | 0;\n    this.v7 = v7 | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    const { h, l } = u64.fromBig(BigInt(this.length));\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        BSIGMA, offset, msg, 10,\n        this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7,\n        B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]\n      );\n    this.v0 ^= v0 ^ v8;\n    this.v1 ^= v1 ^ v9;\n    this.v2 ^= v2 ^ v10;\n    this.v3 ^= v3 ^ v11;\n    this.v4 ^= v4 ^ v12;\n    this.v5 ^= v5 ^ v13;\n    this.v6 ^= v6 ^ v14;\n    this.v7 ^= v7 ^ v15;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2s: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2s, Blake2Opts>(\n  (opts) => new BLAKE2s(opts)\n);\n", "/**\n * Blake3 fast hash is Blake2 with reduced security (round count). Can also be used as MAC & KDF.\n *\n * It is advertised as \"the fastest cryptographic hash\". However, it isn't true in JS.\n * Why is this so slow? While it should be 6x faster than blake2b, perf diff is only 20%:\n *\n * * There is only 30% reduction in number of rounds from blake2s\n * * Speed-up comes from tree structure, which is parallelized using SIMD & threading.\n *   These features are not present in JS, so we only get overhead from trees.\n * * Parallelization only happens on 1024-byte chunks: there is no benefit for small inputs.\n * * It is still possible to make it faster using: a) loop unrolling b) web workers c) wasm\n * @module\n */\nimport { SHA256_IV } from './_md.ts';\nimport { fromBig } from './_u64.ts';\nimport { BLAKE2, compress } from './blake2.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createXOFer, swap32IfBE, toBytes, u32, u8,\n  type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// Flag bitset\nconst B3_Flags = {\n  CHUNK_START: 0b1,\n  CHUNK_END: 0b10,\n  PARENT: 0b100,\n  ROOT: 0b1000,\n  KEYED_HASH: 0b10000,\n  DERIVE_KEY_CONTEXT: 0b100000,\n  DERIVE_KEY_MATERIAL: 0b1000000,\n} as const;\n\nconst B3_IV = SHA256_IV.slice();\n\nconst B3_SIGMA: Uint8Array = /* @__PURE__ */ (() => {\n  const Id = Array.from({ length: 16 }, (_, i) => i);\n  const permute = (arr: number[]) =>\n    [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);\n  const res: number[] = [];\n  for (let i = 0, v = Id; i < 7; i++, v = permute(v)) res.push(...v);\n  return Uint8Array.from(res);\n})();\n\n/**\n * Ensure to use EITHER `key` OR `context`, not both.\n *\n * * `key`: 32-byte MAC key.\n * * `context`: string for KDF. Should be hardcoded, globally unique, and application - specific.\n *   A good default format for the context string is \"[application] [commit timestamp] [purpose]\".\n */\nexport type Blake3Opts = { dkLen?: number; key?: Input; context?: Input };\n\n/** Blake3 hash. Can be used as MAC and KDF. */\nexport class BLAKE3 extends BLAKE2<BLAKE3> implements HashXOF<BLAKE3> {\n  private chunkPos = 0; // Position of current block in chunk\n  private chunksDone = 0; // How many chunks we already have\n  private flags = 0 | 0;\n  private IV: Uint32Array;\n  private state: Uint32Array;\n  private stack: Uint32Array[] = [];\n  // Output\n  private posOut = 0;\n  private bufferOut32 = new Uint32Array(16);\n  private bufferOut: Uint8Array;\n  private chunkOut = 0; // index of output chunk\n  private enableXOF = true;\n\n  constructor(opts: Blake3Opts = {}, flags = 0) {\n    super(64, opts.dkLen === undefined ? 32 : opts.dkLen);\n    const { key, context } = opts;\n    const hasContext = context !== undefined;\n    if (key !== undefined) {\n      if (hasContext) throw new Error('Only \"key\" or \"context\" can be specified at same time');\n      const k = toBytes(key).slice();\n      abytes(k, 32);\n      this.IV = u32(k);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.KEYED_HASH;\n    } else if (hasContext) {\n      const ctx = toBytes(context);\n      const contextKey = new BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT)\n        .update(ctx)\n        .digest();\n      this.IV = u32(contextKey);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;\n    } else {\n      this.IV = B3_IV.slice();\n      this.flags = flags;\n    }\n    this.state = this.IV.slice();\n    this.bufferOut = u8(this.bufferOut32);\n  }\n  // Unused\n  protected get(): [] {\n    return [];\n  }\n  protected set(): void {}\n  private b2Compress(counter: number, flags: number, buf: Uint32Array, bufPos: number = 0) {\n    const { state: s, pos } = this;\n    const { h, l } = fromBig(BigInt(counter), true);\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        B3_SIGMA, bufPos, buf, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags\n      );\n    s[0] = v0 ^ v8;\n    s[1] = v1 ^ v9;\n    s[2] = v2 ^ v10;\n    s[3] = v3 ^ v11;\n    s[4] = v4 ^ v12;\n    s[5] = v5 ^ v13;\n    s[6] = v6 ^ v14;\n    s[7] = v7 ^ v15;\n  }\n  protected compress(buf: Uint32Array, bufPos: number = 0, isLast: boolean = false): void {\n    // Compress last block\n    let flags = this.flags;\n    if (!this.chunkPos) flags |= B3_Flags.CHUNK_START;\n    if (this.chunkPos === 15 || isLast) flags |= B3_Flags.CHUNK_END;\n    if (!isLast) this.pos = this.blockLen;\n    this.b2Compress(this.chunksDone, flags, buf, bufPos);\n    this.chunkPos += 1;\n    // If current block is last in chunk (16 blocks), then compress chunks\n    if (this.chunkPos === 16 || isLast) {\n      let chunk = this.state;\n      this.state = this.IV.slice();\n      // If not the last one, compress only when there are trailing zeros in chunk counter\n      // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.\n      // 1 (001) - leaf not finished (just push current chunk to stack)\n      // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)\n      // 3 (011) - last leaf not finished\n      // 4 (100) - leafs finished at depth=1 and depth=2\n      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {\n        if (!(last = this.stack.pop())) break;\n        this.buffer32.set(last, 0);\n        this.buffer32.set(chunk, 8);\n        this.pos = this.blockLen;\n        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);\n        chunk = this.state;\n        this.state = this.IV.slice();\n      }\n      this.chunksDone++;\n      this.chunkPos = 0;\n      this.stack.push(chunk);\n    }\n    this.pos = 0;\n  }\n  _cloneInto(to?: BLAKE3): BLAKE3 {\n    to = super._cloneInto(to) as BLAKE3;\n    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;\n    to.state.set(state.slice());\n    to.stack = stack.map((i) => Uint32Array.from(i));\n    to.IV.set(IV);\n    to.flags = flags;\n    to.chunkPos = chunkPos;\n    to.chunksDone = chunksDone;\n    to.posOut = posOut;\n    to.chunkOut = chunkOut;\n    to.enableXOF = this.enableXOF;\n    to.bufferOut32.set(this.bufferOut32);\n    return to;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state, this.buffer32, this.IV, this.bufferOut32);\n    clean(...this.stack);\n  }\n  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)\n  private b2CompressOut() {\n    const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;\n    const { h, l } = fromBig(BigInt(this.chunkOut++));\n    swap32IfBE(buffer32);\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        B3_SIGMA, 0, buffer32, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags\n      );\n    out32[0] = v0 ^ v8;\n    out32[1] = v1 ^ v9;\n    out32[2] = v2 ^ v10;\n    out32[3] = v3 ^ v11;\n    out32[4] = v4 ^ v12;\n    out32[5] = v5 ^ v13;\n    out32[6] = v6 ^ v14;\n    out32[7] = v7 ^ v15;\n    out32[8] = s[0] ^ v8;\n    out32[9] = s[1] ^ v9;\n    out32[10] = s[2] ^ v10;\n    out32[11] = s[3] ^ v11;\n    out32[12] = s[4] ^ v12;\n    out32[13] = s[5] ^ v13;\n    out32[14] = s[6] ^ v14;\n    out32[15] = s[7] ^ v15;\n    swap32IfBE(buffer32);\n    swap32IfBE(out32);\n    this.posOut = 0;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(this.pos));\n    // Process last chunk\n    let flags = this.flags | B3_Flags.ROOT;\n    if (this.stack.length) {\n      flags |= B3_Flags.PARENT;\n      swap32IfBE(this.buffer32);\n      this.compress(this.buffer32, 0, true);\n      swap32IfBE(this.buffer32);\n      this.chunksDone = 0;\n      this.pos = this.blockLen;\n    } else {\n      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;\n    }\n    this.flags = flags;\n    this.b2CompressOut();\n  }\n  private writeInto(out: Uint8Array) {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const { blockLen, bufferOut } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.b2CompressOut();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    if (!this.enableXOF) throw new Error('XOF is not possible after digest call');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.enableXOF = false;\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n}\n\n/**\n * BLAKE3 hash function. Can be used as MAC and KDF.\n * @param msg - message that would be hashed\n * @param opts - `dkLen` for output length, `key` for MAC mode, `context` for KDF mode\n * @example\n * const data = new Uint8Array(32);\n * const hash = blake3(data);\n * const mac = blake3(data, { key: new Uint8Array(32) });\n * const kdf = blake3(data, { context: 'application name' });\n */\nexport const blake3: CHashXO = /* @__PURE__ */ createXOFer<BLAKE3, Blake3Opts>(\n  (opts) => new BLAKE3(opts)\n);\n", "import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as Cursor from './internal/cursor.js'\nimport type { Compute, Mutable, OneOf, UnionCompute } from './internal/types.js'\nimport * as Kzg from './Kzg.js'\n\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6\n\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32\n\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096\n\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\n\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction =\n  bytesPerBlob * blobsPerTransaction -\n  // terminator byte (0x80).\n  1 -\n  // zero byte (0x00) appended to each field element.\n  1 * fieldElementsPerBlob * blobsPerTransaction\n\n/** Root type for a Blob. */\nexport type Blob<type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes> =\n  type\n\n/** A list of {@link ox#Blobs.Blob}. */\nexport type Blobs<type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes> =\n  readonly Blob<type>[]\n\n/** Type for a Blob Sidecar that contains a blob, as well as its KZG commitment and proof. */\nexport type BlobSidecar<\n  type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes,\n> = Compute<{\n  /** The blob associated with the transaction. */\n  blob: type\n  /** The KZG commitment corresponding to this blob. */\n  commitment: type\n  /** The KZG proof corresponding to this blob and commitment. */\n  proof: type\n}>\n\n/**\n * Transform a list of Commitments to Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments) // [!code focus]\n * // @log: ['0x...', '0x...']\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitments - A list of commitments.\n * @param options - Options.\n * @returns A list of Blob Versioned Hashes.\n */\nexport function commitmentsToVersionedHashes<\n  const commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  as extends 'Hex' | 'Bytes' =\n    | (commitments extends readonly Hex.Hex[] ? 'Hex' : never)\n    | (commitments extends readonly Bytes.Bytes[] ? 'Bytes' : never),\n>(\n  commitments: commitments | readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  options: commitmentsToVersionedHashes.Options<as> = {},\n): commitmentsToVersionedHashes.ReturnType<as> {\n  const { version } = options\n\n  const as =\n    options.as ?? (typeof commitments[0] === 'string' ? 'Hex' : 'Bytes')\n\n  const hashes: Uint8Array[] | Hex.Hex[] = []\n  for (const commitment of commitments) {\n    hashes.push(\n      commitmentToVersionedHash(commitment, {\n        as,\n        version,\n      }) as never,\n    )\n  }\n  return hashes as never\n}\n\nexport declare namespace commitmentsToVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hashes. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Transform a Commitment to its Blob Versioned Hash.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHash = Blobs.commitmentToVersionedHash(commitment) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hash with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hash with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitment - The commitment.\n * @param options - Options.\n * @returns The Blob Versioned Hash.\n */\nexport function commitmentToVersionedHash<\n  const commitment extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (commitment extends Hex.Hex ? 'Hex' : never)\n    | (commitment extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  commitment: commitment | Hex.Hex | Bytes.Bytes,\n  options: commitmentToVersionedHash.Options<as> = {},\n): commitmentToVersionedHash.ReturnType<as> {\n  const { version = 1 } = options\n  const as = options.as ?? (typeof commitment === 'string' ? 'Hex' : 'Bytes')\n\n  const versionedHash = Hash.sha256(commitment, { as: 'Bytes' })\n  versionedHash.set([version], 0)\n  return (\n    as === 'Bytes' ? versionedHash : Hex.fromBytes(versionedHash)\n  ) as commitmentToVersionedHash.ReturnType<as>\n}\n\nexport declare namespace commitmentToVersionedHash {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hash. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Transforms arbitrary data to {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * ```\n *\n * @example\n * ### Creating Blobs from a String\n *\n * An example of creating Blobs from a string using  {@link ox#Hex.(from:function)}:\n *\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello world!'))\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Blobs with the `as` option.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef', { as: 'Bytes' })\n * //    ^?\n *\n *\n * ```\n *\n * @param data - The data to convert to {@link ox#Blobs.Blobs}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.Blobs}.\n */\nexport function from<\n  const data extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (data extends Hex.Hex ? 'Hex' : never)\n    | (data extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  data: data | Hex.Hex | Bytes.Bytes,\n  options: from.Options<as> = {},\n): from.ReturnType<as> {\n  const as = options.as ?? (typeof data === 'string' ? 'Hex' : 'Bytes')\n  const data_ = (\n    typeof data === 'string' ? Bytes.fromHex(data) : data\n  ) as Bytes.Bytes\n\n  const size_ = Bytes.size(data_)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = Cursor.create(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data_.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    as === 'Bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => Hex.fromBytes(x.bytes))\n  ) as never\n}\n\nexport declare namespace from {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType =\n    | BlobSizeTooLargeError\n    | EmptyBlobError\n    | Bytes.fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Cursor.create.ErrorType\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms a list of {@link ox#Blobs.BlobSidecars} to their Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param sidecars - The {@link ox#Blobs.BlobSidecars} to transform to Blob Versioned Hashes.\n * @param options - Options.\n * @returns The versioned hashes.\n */\nexport function sidecarsToVersionedHashes<\n  const sidecars extends BlobSidecars,\n  as extends 'Hex' | 'Bytes' =\n    | (sidecars extends BlobSidecars<Hex.Hex> ? 'Hex' : never)\n    | (sidecars extends BlobSidecars<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  sidecars: sidecars | BlobSidecars,\n  options: sidecarsToVersionedHashes.Options<as> = {},\n): sidecarsToVersionedHashes.ReturnType<as> {\n  const { version } = options\n\n  const as =\n    options.as ?? (typeof sidecars[0]!.blob === 'string' ? 'Hex' : 'Bytes')\n\n  const hashes: Uint8Array[] | Hex.Hex[] = []\n  for (const { commitment } of sidecars) {\n    hashes.push(\n      commitmentToVersionedHash(commitment, {\n        as,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n\nexport declare namespace sidecarsToVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hashes. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType = commitmentToVersionedHash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with second argument.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs, 'Bytes')\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform.\n * @param to - The type to transform to.\n * @returns The originating data.\n */\nexport function to<\n  const blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n  to extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n  to?: to | 'Hex' | 'Bytes' | undefined,\n): to.ReturnType<to> {\n  const to_ = to ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as Hex.Hex))\n      : blobs\n  ) as Bytes.Bytes[]\n\n  const length = blobs_.reduce((length, blob) => length + blob.length, 0)\n  const data = Cursor.create(new Uint8Array(length))\n  let active = true\n\n  for (const blob of blobs_) {\n    const cursor = Cursor.create(blob)\n    while (active && cursor.position < blob.length) {\n      // First byte will be a zero 0x00 byte – we can skip.\n      cursor.incrementPosition(1)\n\n      let consume = 31\n      if (blob.length - cursor.position < 31)\n        consume = blob.length - cursor.position\n\n      for (const _ in Array.from({ length: consume })) {\n        const byte = cursor.readByte()\n        const isTerminator =\n          byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80)\n        if (isTerminator) {\n          active = false\n          break\n        }\n        data.pushByte(byte)\n      }\n    }\n  }\n\n  const trimmedData = data.bytes.slice(0, data.position)\n  return (to_ === 'Hex' ? Hex.fromBytes(trimmedData) : trimmedData) as never\n}\n\nexport declare namespace to {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex'> =\n    | (to extends 'Bytes' ? Bytes.Bytes : never)\n    | (to extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Cursor.create.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toHex(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n */\nexport function toHex(\n  blobs: Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n): toHex.ReturnType {\n  return to(blobs, 'Hex')\n}\n\nexport declare namespace toHex {\n  type ReturnType = to.ReturnType<'Hex'>\n  type ErrorType = to.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toBytes(blobs) // [!code focus]\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n */\nexport function toBytes(\n  blobs: Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n): toBytes.ReturnType {\n  return to(blobs, 'Bytes')\n}\n\n/**\n * Compute commitments from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, {\n *   as: 'Bytes', // [!code focus]\n *   kzg,\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform to commitments.\n * @param options - Options.\n * @returns The commitments.\n */\nexport function toCommitments<\n  const blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toCommitments.Options<as>,\n): toCommitments.ReturnType<as> {\n  const { kzg } = options\n\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as any))\n      : blobs\n  ) as Bytes.Bytes[]\n\n  const commitments: Bytes.Bytes[] = []\n  for (const blob of blobs_)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\n\n  return (\n    as === 'Bytes' ? commitments : commitments.map((x) => Hex.fromBytes(x))\n  ) as never\n}\n\nexport declare namespace toCommitments {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'blobToKzgCommitment'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = Compute<\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n  >\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\nexport declare namespace toBytes {\n  type ReturnType = to.ReturnType<'Bytes'>\n  type ErrorType = to.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Compute the proofs for a list of {@link ox#Blobs.Blobs} and their commitments.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to compute proofs for.\n * @param options - Options.\n * @returns The Blob proofs.\n */\nexport function toProofs<\n  const blobs extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  const commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends readonly Hex.Hex[] ? 'Hex' : never)\n    | (blobs extends readonly Bytes.Bytes[] ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toProofs.Options<blobs, commitments, as>,\n): toProofs.ReturnType<as> {\n  const { kzg } = options\n\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as any))\n      : blobs\n  ) as Bytes.Bytes[]\n  const commitments = (\n    typeof options.commitments[0] === 'string'\n      ? options.commitments.map((x) => Bytes.fromHex(x as any))\n      : options.commitments\n  ) as Bytes.Bytes[]\n\n  const proofs: Bytes.Bytes[] = []\n  for (let i = 0; i < blobs_.length; i++) {\n    const blob = blobs_[i]!\n    const commitment = commitments[i]!\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (\n    as === 'Bytes' ? proofs : proofs.map((x) => Hex.fromBytes(x))\n  ) as never\n}\n\nexport declare namespace toProofs {\n  type Options<\n    blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex> =\n      | Blobs<Bytes.Bytes>\n      | Blobs<Hex.Hex>,\n    commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[] =\n      | readonly Bytes.Bytes[]\n      | readonly Hex.Hex[],\n    as extends 'Hex' | 'Bytes' =\n      | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n      | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n  > = {\n    /** Commitments for the blobs. */\n    commitments: (commitments | readonly Bytes.Bytes[] | readonly Hex.Hex[]) &\n      (commitments extends blobs\n        ? {}\n        : `commitments must be the same type as blobs`)\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'computeBlobKzgProof'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms {@link ox#Blobs.Blobs} into a {@link ox#Blobs.BlobSidecars} array.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * You can also provide your own commitments and proofs if you do not want `toSidecars`\n * to compute them.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg })\n *\n * const sidecars = Blobs.toSidecars(blobs, { commitments, kzg, proofs }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into {@link ox#Blobs.BlobSidecars}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.BlobSidecars}.\n */\nexport function toSidecars<\n  const blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n>(\n  blobs: blobs,\n  options: toSidecars.Options<blobs>,\n): toSidecars.ReturnType<blobs> {\n  const { kzg } = options\n\n  const commitments = options.commitments ?? toCommitments(blobs, { kzg: kzg! })\n  const proofs =\n    options.proofs ??\n    toProofs(blobs, { commitments: commitments as any, kzg: kzg! })\n\n  const sidecars: Mutable<BlobSidecars> = []\n  for (let i = 0; i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i]!,\n      commitment: commitments[i]!,\n      proof: proofs[i]!,\n    })\n\n  return sidecars as never\n}\n\nexport declare namespace toSidecars {\n  type Options<\n    blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes> =\n      | Blobs<Hex.Hex>\n      | Blobs<Bytes.Bytes>,\n  > = {\n    kzg?: Kzg.Kzg | undefined\n  } & OneOf<\n    | {}\n    | {\n        /** Commitment for each blob. */\n        commitments: blobs | readonly Hex.Hex[] | readonly Bytes.Bytes[]\n        /** Proof for each blob. */\n        proofs: blobs | readonly Hex.Hex[] | readonly Bytes.Bytes[]\n      }\n  >\n\n  type ReturnType<blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>> =\n    UnionCompute<\n      | (blobs extends Blobs<Hex.Hex> ? BlobSidecars<Hex.Hex> : never)\n      | (blobs extends Blobs<Bytes.Bytes> ? BlobSidecars<Bytes.Bytes> : never)\n    >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Compute Blob Versioned Hashes from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const versionedHashes = Blobs.toVersionedHashes(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into Blob Versioned Hashes.\n * @param options - Options.\n * @returns The Blob Versioned Hashes.\n */\nexport function toVersionedHashes<\n  const blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toVersionedHashes.Options<as>,\n): toVersionedHashes.ReturnType<as> {\n  const commitments = toCommitments(blobs, options)\n  return commitmentsToVersionedHashes(commitments, options)\n}\n\nexport declare namespace toVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'blobToKzgCommitment'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = Compute<\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n  >\n\n  type ErrorType =\n    | toCommitments.ErrorType\n    | commitmentsToVersionedHashes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** A list of {@link ox#Blobs.BlobSidecar}. */\nexport type BlobSidecars<\n  type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes,\n> = readonly Compute<BlobSidecar<type>>[]\n\n/** Thrown when the blob size is too large. */\nexport class BlobSizeTooLargeError extends Errors.BaseError {\n  override readonly name = 'Blobs.BlobSizeTooLargeError'\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n    })\n  }\n}\n\n/** Thrown when the blob is empty. */\nexport class EmptyBlobError extends Errors.BaseError {\n  override readonly name = 'Blobs.EmptyBlobError'\n  constructor() {\n    super('Blob data must not be empty.')\n  }\n}\n\n/** Thrown when the blob versioned hashes are empty. */\nexport class EmptyBlobVersionedHashesError extends Errors.BaseError {\n  override readonly name = 'Blobs.EmptyBlobVersionedHashesError'\n  constructor() {\n    super('Blob versioned hashes must not be empty.')\n  }\n}\n\n/** Thrown when the blob versioned hash size is invalid. */\nexport class InvalidVersionedHashSizeError extends Errors.BaseError {\n  override readonly name = 'Blobs.InvalidVersionedHashSizeError'\n  constructor({\n    hash,\n    size,\n  }: {\n    hash: Hex.Hex\n    size: number\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`],\n    })\n  }\n}\n\n/** Thrown when the blob versioned hash version is invalid. */\nexport class InvalidVersionedHashVersionError extends Errors.BaseError {\n  override readonly name = 'Blobs.InvalidVersionedHashVersionError'\n  constructor({\n    hash,\n    version,\n  }: {\n    hash: Hex.Hex\n    version: number\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${Kzg.versionedHashVersion}`,\n        `Received: ${version}`,\n      ],\n    })\n  }\n}\n", "/**\n * BLS (Barreto-Lynn-Scott) family of pairing-friendly curves.\n * BLS != BLS.\n * The file implements BLS (Boneh-Lynn-Shacham) signatures.\n * Used in both BLS (Barreto-Lynn-Scott) and BN (Barreto-Naehrig)\n * families of pairing-friendly curves.\n * Consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\n * Pairing is used to aggregate and verify signatures.\n * There are two main ways to use it:\n * 1. Fp for short private keys, Fp₂ for signatures\n * 2. Fp for short signatures, Fp₂ for private keys\n * @module\n **/\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// TODO: import { AffinePoint } from './curve.ts';\nimport {\n  type H2CPointConstructor,\n  type htfBasicOpts,\n  type Opts as HTFOpts,\n  type MapToCurve,\n  createHasher,\n} from './hash-to-curve.ts';\nimport { type IField, getMinHashLength, mapHashToField } from './modular.ts';\nimport type { Fp12, Fp12Bls, Fp2, Fp2Bls, Fp6 } from './tower.ts';\nimport { type CHash, type Hex, type PrivKey, ensureBytes, memoized } from './utils.ts';\nimport {\n  type CurvePointsRes,\n  type CurvePointsType,\n  type ProjPointType,\n  weierstrassPoints,\n} from './weierstrass.ts';\n\ntype Fp = bigint; // Can be different field?\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\nexport type TwistType = 'multiplicative' | 'divisive';\n\nexport type ShortSignatureCoder<Fp> = {\n  fromHex(hex: Hex): ProjPointType<Fp>;\n  toRawBytes(point: ProjPointType<Fp>): Uint8Array;\n  toHex(point: ProjPointType<Fp>): string;\n};\n\nexport type SignatureCoder<Fp> = {\n  fromHex(hex: Hex): ProjPointType<Fp>;\n  toRawBytes(point: ProjPointType<Fp>): Uint8Array;\n  toHex(point: ProjPointType<Fp>): string;\n};\n\nexport type PostPrecomputePointAddFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2\n) => { Rx: Fp2; Ry: Fp2; Rz: Fp2 };\nexport type PostPrecomputeFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2,\n  pointAdd: PostPrecomputePointAddFn\n) => void;\nexport type CurveType = {\n  G1: Omit<CurvePointsType<Fp>, 'n'> & {\n    ShortSignature: SignatureCoder<Fp>;\n    mapToCurve: MapToCurve<Fp>;\n    htfDefaults: HTFOpts;\n  };\n  G2: Omit<CurvePointsType<Fp2>, 'n'> & {\n    Signature: SignatureCoder<Fp2>;\n    mapToCurve: MapToCurve<Fp2>;\n    htfDefaults: HTFOpts;\n  };\n  fields: {\n    Fp: IField<Fp>;\n    Fr: IField<bigint>;\n    Fp2: Fp2Bls;\n    Fp6: IField<Fp6>;\n    Fp12: Fp12Bls;\n  };\n  params: {\n    // NOTE: MSB is always ignored and used as marker for length,\n    // otherwise leading zeros will be lost.\n    // Can be different from 'X' (seed) param!\n    ateLoopSize: bigint;\n    xNegative: boolean;\n    r: bigint;\n    twistType: TwistType; // BLS12-381: Multiplicative, BN254: Divisive\n  };\n  htfDefaults: HTFOpts;\n  hash: CHash; // Because we need outputLen for DRBG\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  // This is super ugly hack for untwist point in BN254 after miller loop\n  postPrecompute?: PostPrecomputeFn;\n};\n\ntype PrecomputeSingle = [Fp2, Fp2, Fp2][];\ntype Precompute = PrecomputeSingle[];\n\nexport type CurveFn = {\n  getPublicKey: (privateKey: PrivKey) => Uint8Array;\n  getPublicKeyForShortSignatures: (privateKey: PrivKey) => Uint8Array;\n  sign: {\n    (message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (message: ProjPointType<Fp2>, privateKey: PrivKey, htfOpts?: htfBasicOpts): ProjPointType<Fp2>;\n  };\n  signShortSignature: {\n    (message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (message: ProjPointType<Fp>, privateKey: PrivKey, htfOpts?: htfBasicOpts): ProjPointType<Fp>;\n  };\n  verify: (\n    signature: Hex | ProjPointType<Fp2>,\n    message: Hex | ProjPointType<Fp2>,\n    publicKey: Hex | ProjPointType<Fp>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  verifyShortSignature: (\n    signature: Hex | ProjPointType<Fp>,\n    message: Hex | ProjPointType<Fp>,\n    publicKey: Hex | ProjPointType<Fp2>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  verifyBatch: (\n    signature: Hex | ProjPointType<Fp2>,\n    messages: (Hex | ProjPointType<Fp2>)[],\n    publicKeys: (Hex | ProjPointType<Fp>)[],\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  aggregatePublicKeys: {\n    (publicKeys: Hex[]): Uint8Array;\n    (publicKeys: ProjPointType<Fp>[]): ProjPointType<Fp>;\n  };\n  aggregateSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: ProjPointType<Fp2>[]): ProjPointType<Fp2>;\n  };\n  aggregateShortSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: ProjPointType<Fp>[]): ProjPointType<Fp>;\n  };\n  millerLoopBatch: (pairs: [Precompute, Fp, Fp][]) => Fp12;\n  pairing: (P: ProjPointType<Fp>, Q: ProjPointType<Fp2>, withFinalExponent?: boolean) => Fp12;\n  pairingBatch: (\n    pairs: { g1: ProjPointType<Fp>; g2: ProjPointType<Fp2> }[],\n    withFinalExponent?: boolean\n  ) => Fp12;\n  G1: CurvePointsRes<Fp> & ReturnType<typeof createHasher<Fp>>;\n  G2: CurvePointsRes<Fp2> & ReturnType<typeof createHasher<Fp2>>;\n  Signature: SignatureCoder<Fp2>;\n  ShortSignature: ShortSignatureCoder<Fp>;\n  params: {\n    ateLoopSize: bigint;\n    r: bigint;\n    G1b: bigint;\n    G2b: Fp2;\n  };\n  fields: {\n    Fp: IField<Fp>;\n    Fp2: Fp2Bls;\n    Fp6: IField<Fp6>;\n    Fp12: Fp12Bls;\n    Fr: IField<bigint>;\n  };\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    calcPairingPrecomputes: (p: ProjPointType<Fp2>) => Precompute;\n  };\n};\n\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a: bigint) {\n  const res = [];\n  // a>1 because of marker bit\n  for (; a > _1n; a >>= _1n) {\n    if ((a & _1n) === _0n) res.unshift(0);\n    else if ((a & _3n) === _3n) {\n      res.unshift(-1);\n      a += _1n;\n    } else res.unshift(1);\n  }\n  return res;\n}\n\nexport function bls(CURVE: CurveType): CurveFn {\n  // Fields are specific for curve, so for now we'll need to pass them with opts\n  const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n  const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;\n  const TWIST: TwistType = CURVE.params.twistType;\n  // Point on G1 curve: (x, y)\n  const G1_ = weierstrassPoints({ n: Fr.ORDER, ...CURVE.G1 });\n  const G1 = Object.assign(\n    G1_,\n    createHasher(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G1.htfDefaults,\n    })\n  );\n  // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n  const G2_ = weierstrassPoints({ n: Fr.ORDER, ...CURVE.G2 });\n  const G2 = Object.assign(\n    G2_,\n    createHasher(G2_.ProjectivePoint as H2CPointConstructor<Fp2>, CURVE.G2.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G2.htfDefaults,\n    })\n  );\n  type G1 = typeof G1.ProjectivePoint.BASE;\n  type G2 = typeof G2.ProjectivePoint.BASE;\n\n  // Applies sparse multiplication as line function\n  let lineFunction: (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) => Fp12;\n  if (TWIST === 'multiplicative') {\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n  } else if (TWIST === 'divisive') {\n    // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n    // precompute calculations.\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n  } else throw new Error('bls: unknown twist type');\n\n  const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n  function pointDouble(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2) {\n    const t0 = Fp2.sqr(Ry); // Ry²\n    const t1 = Fp2.sqr(Rz); // Rz²\n    const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n    const t3 = Fp2.mul(t2, _3n); // 3 * T2\n    const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n    const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n    const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n    const c2 = Fp2.neg(t4); // -T4 (-h)\n\n    ell.push([c0, c1, c2]);\n\n    Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n    Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n    Rz = Fp2.mul(t0, t4); // T0 * T4\n    return { Rx, Ry, Rz };\n  }\n  function pointAdd(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2, Qx: Fp2, Qy: Fp2) {\n    // Addition\n    const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n    const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n    const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n    const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n    const c2 = t1; // == Rx - Qx * Rz\n\n    ell.push([c0, c1, c2]);\n\n    const t2 = Fp2.sqr(t1); // T1²\n    const t3 = Fp2.mul(t2, t1); // T2 * T1\n    const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n    const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n    Rx = Fp2.mul(t1, t5); // T1 * T5\n    Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n    Rz = Fp2.mul(Rz, t3); // Rz * T3\n    return { Rx, Ry, Rz };\n  }\n\n  // Pre-compute coefficients for sparse multiplication\n  // Point addition and point double calculations is reused for coefficients\n  // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n  // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n  const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);\n\n  const calcPairingPrecomputes = memoized((point: G2) => {\n    const p = point;\n    const { x, y } = p.toAffine();\n    // prettier-ignore\n    const Qx = x, Qy = y, negQy = Fp2.neg(y);\n    // prettier-ignore\n    let Rx = Qx, Ry = Qy, Rz = Fp2.ONE;\n    const ell: Precompute = [];\n    for (const bit of ATE_NAF) {\n      const cur: PrecomputeSingle = [];\n      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));\n      if (bit) ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n      ell.push(cur);\n    }\n    if (CURVE.postPrecompute) {\n      const last = ell[ell.length - 1];\n      CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n    }\n    return ell;\n  });\n\n  // Main pairing logic is here. Computes product of miller loops + final exponentiate\n  // Applies calculated precomputes\n  type MillerInput = [Precompute, Fp, Fp][];\n  function millerLoopBatch(pairs: MillerInput, withFinalExponent: boolean = false) {\n    let f12 = Fp12.ONE;\n    if (pairs.length) {\n      const ellLen = pairs[0][0].length;\n      for (let i = 0; i < ellLen; i++) {\n        f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n        // NOTE: we apply multiple pairings in parallel here\n        for (const [ell, Px, Py] of pairs) {\n          for (const [c0, c1, c2] of ell[i]) f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n        }\n      }\n    }\n    if (BLS_X_IS_NEGATIVE) f12 = Fp12.conjugate(f12);\n    return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n  }\n  type PairingInput = { g1: G1; g2: G2 };\n  // Calculates product of multiple pairings\n  // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n  function pairingBatch(pairs: PairingInput[], withFinalExponent: boolean = true) {\n    const res: MillerInput = [];\n    // Cache precomputed toAffine for all points\n    G1.ProjectivePoint.normalizeZ(pairs.map(({ g1 }) => g1));\n    G2.ProjectivePoint.normalizeZ(pairs.map(({ g2 }) => g2));\n    for (const { g1, g2 } of pairs) {\n      if (g1.equals(G1.ProjectivePoint.ZERO) || g2.equals(G2.ProjectivePoint.ZERO))\n        throw new Error('pairing is not available for ZERO point');\n      // This uses toAffine inside\n      g1.assertValidity();\n      g2.assertValidity();\n      const Qa = g1.toAffine();\n      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n    }\n    return millerLoopBatch(res, withFinalExponent);\n  }\n  // Calculates bilinear pairing\n  function pairing(Q: G1, P: G2, withFinalExponent: boolean = true): Fp12 {\n    return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);\n  }\n\n  const utils = {\n    randomPrivateKey: (): Uint8Array => {\n      const length = getMinHashLength(Fr.ORDER);\n      return mapHashToField(CURVE.randomBytes(length), Fr.ORDER);\n    },\n    calcPairingPrecomputes,\n  };\n\n  const { ShortSignature } = CURVE.G1;\n  const { Signature } = CURVE.G2;\n\n  type G1Hex = Hex | G1;\n  type G2Hex = Hex | G2;\n  function normP1(point: G1Hex): G1 {\n    return point instanceof G1.ProjectivePoint ? (point as G1) : G1.ProjectivePoint.fromHex(point);\n  }\n  function normP1Hash(point: G1Hex, htfOpts?: htfBasicOpts): G1 {\n    return point instanceof G1.ProjectivePoint\n      ? point\n      : (G1.hashToCurve(ensureBytes('point', point), htfOpts) as G1);\n  }\n  function normP2(point: G2Hex): G2 {\n    return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\n  }\n  function normP2Hash(point: G2Hex, htfOpts?: htfBasicOpts): G2 {\n    return point instanceof G2.ProjectivePoint\n      ? point\n      : (G2.hashToCurve(ensureBytes('point', point), htfOpts) as G2);\n  }\n\n  // Multiplies generator (G1) by private key.\n  // P = pk x G\n  function getPublicKey(privateKey: PrivKey): Uint8Array {\n    return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n  }\n\n  // Multiplies generator (G2) by private key.\n  // P = pk x G\n  function getPublicKeyForShortSignatures(privateKey: PrivKey): Uint8Array {\n    return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n  }\n\n  // Executes `hashToCurve` on the message and then multiplies the result by private key.\n  // S = pk x H(m)\n  function sign(message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n  function sign(message: G2, privateKey: PrivKey, htfOpts?: htfBasicOpts): G2;\n  function sign(message: G2Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array | G2 {\n    const msgPoint = normP2Hash(message, htfOpts);\n    msgPoint.assertValidity();\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n    if (message instanceof G2.ProjectivePoint) return sigPoint;\n    return Signature.toRawBytes(sigPoint);\n  }\n\n  function signShortSignature(\n    message: Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array;\n  function signShortSignature(message: G1, privateKey: PrivKey, htfOpts?: htfBasicOpts): G1;\n  function signShortSignature(\n    message: G1Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array | G1 {\n    const msgPoint = normP1Hash(message, htfOpts);\n    msgPoint.assertValidity();\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n    if (message instanceof G1.ProjectivePoint) return sigPoint;\n    return ShortSignature.toRawBytes(sigPoint);\n  }\n\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n  // e(P, H(m)) == e(G, S)\n  function verify(\n    signature: G2Hex,\n    message: G2Hex,\n    publicKey: G1Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const P = normP1(publicKey);\n    const Hm = normP2Hash(message, htfOpts);\n    const G = G1.ProjectivePoint.BASE;\n    const S = normP2(signature);\n    const exp = pairingBatch([\n      { g1: P.negate(), g2: Hm }, // ePHM = pairing(P.negate(), Hm, false);\n      { g1: G, g2: S }, // eGS = pairing(G, S, false);\n    ]);\n    return Fp12.eql(exp, Fp12.ONE);\n  }\n\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n  // e(S, G) == e(H(m), P)\n  function verifyShortSignature(\n    signature: G1Hex,\n    message: G1Hex,\n    publicKey: G2Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const P = normP2(publicKey);\n    const Hm = normP1Hash(message, htfOpts);\n    const G = G2.ProjectivePoint.BASE;\n    const S = normP1(signature);\n    const exp = pairingBatch([\n      { g1: Hm, g2: P }, // eHmP = pairing(Hm, P, false);\n      { g1: S, g2: G.negate() }, // eSG = pairing(S, G.negate(), false);\n    ]);\n    return Fp12.eql(exp, Fp12.ONE);\n  }\n\n  function aNonEmpty(arr: any[]) {\n    if (!Array.isArray(arr) || arr.length === 0) throw new Error('expected non-empty array');\n  }\n\n  // Adds a bunch of public key points together.\n  // pk1 + pk2 + pk3 = pkA\n  function aggregatePublicKeys(publicKeys: Hex[]): Uint8Array;\n  function aggregatePublicKeys(publicKeys: G1[]): G1;\n  function aggregatePublicKeys(publicKeys: G1Hex[]): Uint8Array | G1 {\n    aNonEmpty(publicKeys);\n    const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (publicKeys[0] instanceof G1.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    // toRawBytes ensures point validity\n    return aggAffine.toRawBytes(true);\n  }\n\n  // Adds a bunch of signature points together.\n  function aggregateSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateSignatures(signatures: G2[]): G2;\n  function aggregateSignatures(signatures: G2Hex[]): Uint8Array | G2 {\n    aNonEmpty(signatures);\n    const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (signatures[0] instanceof G2.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    return Signature.toRawBytes(aggAffine);\n  }\n\n  // Adds a bunch of signature points together.\n  function aggregateShortSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateShortSignatures(signatures: G1[]): G1;\n  function aggregateShortSignatures(signatures: G1Hex[]): Uint8Array | G1 {\n    aNonEmpty(signatures);\n    const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (signatures[0] instanceof G1.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    return ShortSignature.toRawBytes(aggAffine);\n  }\n\n  // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n  // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n  function verifyBatch(\n    signature: G2Hex,\n    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n    messages: G2Hex[],\n    publicKeys: G1Hex[],\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    aNonEmpty(messages);\n    if (publicKeys.length !== messages.length)\n      throw new Error('amount of public keys and messages should be equal');\n    const sig = normP2(signature);\n    const nMessages = messages.map((i) => normP2Hash(i, htfOpts));\n    const nPublicKeys = publicKeys.map(normP1);\n    // NOTE: this works only for exact same object\n    const messagePubKeyMap = new Map<G2, G1[]>();\n    for (let i = 0; i < nPublicKeys.length; i++) {\n      const pub = nPublicKeys[i];\n      const msg = nMessages[i];\n      let keys = messagePubKeyMap.get(msg);\n      if (keys === undefined) {\n        keys = [];\n        messagePubKeyMap.set(msg, keys);\n      }\n      keys.push(pub);\n    }\n    const paired = [];\n    try {\n      for (const [msg, keys] of messagePubKeyMap) {\n        const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n        paired.push({ g1: groupPublicKey, g2: msg });\n      }\n      paired.push({ g1: G1.ProjectivePoint.BASE.negate(), g2: sig });\n      return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n    } catch {\n      return false;\n    }\n  }\n\n  G1.ProjectivePoint.BASE._setWindowSize(4);\n\n  return {\n    getPublicKey,\n    getPublicKeyForShortSignatures,\n    sign,\n    signShortSignature,\n    verify,\n    verifyBatch,\n    verifyShortSignature,\n    aggregatePublicKeys,\n    aggregateSignatures,\n    aggregateShortSignatures,\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    G1,\n    G2,\n    Signature,\n    ShortSignature,\n    fields: {\n      Fr,\n      Fp,\n      Fp2,\n      Fp6,\n      Fp12,\n    },\n    params: {\n      ateLoopSize: CURVE.params.ateLoopSize,\n      r: CURVE.params.r,\n      G1b: CURVE.G1.b,\n      G2b: CURVE.G2.b,\n    },\n    utils,\n  };\n}\n", "/**\n * Towered extension fields.\n * Rather than implementing a massive 12th-degree extension directly, it is more efficient\n * to build it up from smaller extensions: a tower of extensions.\n *\n * For BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\n * on top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\n *\n * For more info: \"Pairings for beginners\" by Costello, section 7.3.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport * as mod from './modular.ts';\nimport { bitLen, bitMask, concatBytes, notImplemented } from './utils.ts';\nimport type { ProjConstructor, ProjPointType } from './weierstrass.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\n// Fp₂ over complex plane\nexport type BigintTuple = [bigint, bigint];\nexport type Fp = bigint;\n// Finite extension field over irreducible polynominal.\n// Fp(u) / (u² - β) where β = -1\nexport type Fp2 = { c0: bigint; c1: bigint };\nexport type BigintSix = [bigint, bigint, bigint, bigint, bigint, bigint];\nexport type Fp6 = { c0: Fp2; c1: Fp2; c2: Fp2 };\nexport type Fp12 = { c0: Fp6; c1: Fp6 }; // Fp₁₂ = Fp₆² => Fp₂³, Fp₆(w) / (w² - γ) where γ = v\n// prettier-ignore\nexport type BigintTwelve = [\n  bigint, bigint, bigint, bigint, bigint, bigint,\n  bigint, bigint, bigint, bigint, bigint, bigint\n];\n\nexport type Fp2Bls = mod.IField<Fp2> & {\n  reim: (num: Fp2) => { re: Fp; im: Fp };\n  mulByB: (num: Fp2) => Fp2;\n  frobeniusMap(num: Fp2, power: number): Fp2;\n  fromBigTuple(num: [bigint, bigint]): Fp2;\n};\n\nexport type Fp12Bls = mod.IField<Fp12> & {\n  frobeniusMap(num: Fp12, power: number): Fp12;\n  mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n  mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n  conjugate(num: Fp12): Fp12;\n  finalExponentiate(num: Fp12): Fp12;\n  fromBigTwelve(num: BigintTwelve): Fp12;\n};\n\nfunction calcFrobeniusCoefficients<T>(\n  Fp: mod.IField<T>,\n  nonResidue: T,\n  modulus: bigint,\n  degree: number,\n  num: number = 1,\n  divisor?: number\n) {\n  const _divisor = BigInt(divisor === undefined ? degree : divisor);\n  const towerModulus: any = modulus ** BigInt(degree);\n  const res: T[][] = [];\n  for (let i = 0; i < num; i++) {\n    const a = BigInt(i + 1);\n    const powers: T[] = [];\n    for (let j = 0, qPower = _1n; j < degree; j++) {\n      const power = ((a * qPower - a) / _divisor) % towerModulus;\n      powers.push(Fp.pow(nonResidue, power));\n      qPower *= modulus;\n    }\n    res.push(powers);\n  }\n  return res;\n}\n\n// This works same at least for bls12-381, bn254 and bls12-377\nexport function psiFrobenius(\n  Fp: mod.IField<Fp>,\n  Fp2: Fp2Bls,\n  base: Fp2\n): {\n  psi: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  psi2: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  G2psi: (c: ProjConstructor<Fp2>, P: ProjPointType<Fp2>) => ProjPointType<Fp2>;\n  G2psi2: (c: ProjConstructor<Fp2>, P: ProjPointType<Fp2>) => ProjPointType<Fp2>;\n  PSI_X: Fp2;\n  PSI_Y: Fp2;\n  PSI2_X: Fp2;\n  PSI2_Y: Fp2;\n} {\n  // GLV endomorphism Ψ(P)\n  const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\n  const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\n  function psi(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    // This x10 faster than previous version in bls12-381\n    const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\n    const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\n    return [x2, y2];\n  }\n  // Ψ²(P) endomorphism (psi2(x) = psi(psi(x)))\n  const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\n  // This equals -1, which causes y to be Fp2.neg(y).\n  // But not sure if there are case when this is not true?\n  const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\n  if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE))) throw new Error('psiFrobenius: PSI2_Y!==-1');\n  function psi2(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];\n  }\n  // Map points\n  const mapAffine =\n    <T>(fn: (x: T, y: T) => [T, T]) =>\n    (c: ProjConstructor<T>, P: ProjPointType<T>) => {\n      const affine = P.toAffine();\n      const p = fn(affine.x, affine.y);\n      return c.fromAffine({ x: p[0], y: p[1] });\n    };\n  const G2psi = mapAffine(psi);\n  const G2psi2 = mapAffine(psi2);\n  return { psi, psi2, G2psi, G2psi2, PSI_X, PSI_Y, PSI2_X, PSI2_Y };\n}\n\nexport type Tower12Opts = {\n  ORDER: bigint;\n  NONRESIDUE?: Fp;\n  // Fp2\n  FP2_NONRESIDUE: BigintTuple;\n  Fp2sqrt?: (num: Fp2) => Fp2;\n  Fp2mulByB: (num: Fp2) => Fp2;\n  // Fp12\n  Fp12cyclotomicSquare: (num: Fp12) => Fp12;\n  Fp12cyclotomicExp: (num: Fp12, n: bigint) => Fp12;\n  Fp12finalExponentiate: (num: Fp12) => Fp12;\n};\n\nexport function tower12(opts: Tower12Opts): {\n  Fp: Readonly<mod.IField<bigint> & Required<Pick<mod.IField<bigint>, 'isOdd'>>>;\n  Fp2: mod.IField<Fp2> & {\n    NONRESIDUE: Fp2;\n    fromBigTuple: (tuple: BigintTuple | bigint[]) => Fp2;\n    reim: (num: Fp2) => { re: bigint; im: bigint };\n    mulByNonresidue: (num: Fp2) => Fp2;\n    mulByB: (num: Fp2) => Fp2;\n    frobeniusMap(num: Fp2, power: number): Fp2;\n  };\n  Fp6: mod.IField<Fp6> & {\n    fromBigSix: (tuple: BigintSix) => Fp6;\n    mulByNonresidue: (num: Fp6) => Fp6;\n    frobeniusMap(num: Fp6, power: number): Fp6;\n    mul1(num: Fp6, b1: Fp2): Fp6;\n    mul01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\n    mulByFp2(lhs: Fp6, rhs: Fp2): Fp6;\n  };\n  Fp4Square: (a: Fp2, b: Fp2) => { first: Fp2; second: Fp2 };\n  Fp12: mod.IField<Fp12> & {\n    fromBigTwelve: (t: BigintTwelve) => Fp12;\n    frobeniusMap(num: Fp12, power: number): Fp12;\n    mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n    mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n    mulByFp2(lhs: Fp12, rhs: Fp2): Fp12;\n    conjugate(num: Fp12): Fp12;\n    finalExponentiate(num: Fp12): Fp12;\n    _cyclotomicSquare(num: Fp12): Fp12;\n    _cyclotomicExp(num: Fp12, n: bigint): Fp12;\n  };\n} {\n  const { ORDER } = opts;\n  // Fp\n  const Fp = mod.Field(ORDER);\n  const FpNONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\n  const Fpdiv2 = Fp.div(Fp.ONE, _2n); // 1/2\n\n  // Fp2\n  const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, FpNONRESIDUE, Fp.ORDER, 2)[0];\n  const Fp2Add = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\n    c0: Fp.add(c0, r0),\n    c1: Fp.add(c1, r1),\n  });\n  const Fp2Subtract = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\n    c0: Fp.sub(c0, r0),\n    c1: Fp.sub(c1, r1),\n  });\n  const Fp2Multiply = ({ c0, c1 }: Fp2, rhs: Fp2) => {\n    if (typeof rhs === 'bigint') return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\n    // (a+bi)(c+di) = (ac−bd) + (ad+bc)i\n    const { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp.mul(c0, r0); // c0 * o0\n    let t2 = Fp.mul(c1, r1); // c1 * o1\n    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n    const o0 = Fp.sub(t1, t2);\n    const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n    return { c0: o0, c1: o1 };\n  };\n  const Fp2Square = ({ c0, c1 }: Fp2) => {\n    const a = Fp.add(c0, c1);\n    const b = Fp.sub(c0, c1);\n    const c = Fp.add(c0, c0);\n    return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\n  };\n  type Fp2Utils = {\n    NONRESIDUE: Fp2;\n    fromBigTuple: (tuple: BigintTuple | bigint[]) => Fp2;\n    reim: (num: Fp2) => { re: bigint; im: bigint };\n    mulByNonresidue: (num: Fp2) => Fp2;\n    mulByB: (num: Fp2) => Fp2;\n    frobeniusMap(num: Fp2, power: number): Fp2;\n  };\n  const Fp2fromBigTuple = (tuple: BigintTuple | bigint[]) => {\n    if (tuple.length !== 2) throw new Error('invalid tuple');\n    const fps = tuple.map((n) => Fp.create(n)) as [Fp, Fp];\n    return { c0: fps[0], c1: fps[1] };\n  };\n\n  const FP2_ORDER = ORDER * ORDER;\n  const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\n  const Fp2: mod.IField<Fp2> & Fp2Utils = {\n    ORDER: FP2_ORDER,\n    isLE: Fp.isLE,\n    NONRESIDUE: Fp2Nonresidue,\n    BITS: bitLen(FP2_ORDER),\n    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),\n    MASK: bitMask(bitLen(FP2_ORDER)),\n    ZERO: { c0: Fp.ZERO, c1: Fp.ZERO },\n    ONE: { c0: Fp.ONE, c1: Fp.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => typeof c0 === 'bigint' && typeof c1 === 'bigint',\n    is0: ({ c0, c1 }) => Fp.is0(c0) && Fp.is0(c1),\n    eql: ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\n    neg: ({ c0, c1 }) => ({ c0: Fp.neg(c0), c1: Fp.neg(c1) }),\n    pow: (num, power) => mod.FpPow(Fp2, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp2, nums),\n    // Normalized\n    add: Fp2Add,\n    sub: Fp2Subtract,\n    mul: Fp2Multiply,\n    sqr: Fp2Square,\n    // NonNormalized stuff\n    addN: Fp2Add,\n    subN: Fp2Subtract,\n    mulN: Fp2Multiply,\n    sqrN: Fp2Square,\n    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n    div: (lhs, rhs) =>\n      Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\n    inv: ({ c0: a, c1: b }) => {\n      // We wish to find the multiplicative inverse of a nonzero\n      // element a + bu in Fp2. We leverage an identity\n      //\n      // (a + bu)(a - bu) = a² + b²\n      //\n      // which holds because u² = -1. This can be rewritten as\n      //\n      // (a + bu)(a - bu)/(a² + b²) = 1\n      //\n      // because a² + b² = 0 has no nonzero solutions for (a, b).\n      // This gives that (a - bu)/(a² + b²) is the inverse\n      // of (a + bu). Importantly, this can be computing using\n      // only a single inversion in Fp.\n      const factor = Fp.inv(Fp.create(a * a + b * b));\n      return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\n    },\n    sqrt: (num) => {\n      if (opts.Fp2sqrt) return opts.Fp2sqrt(num);\n      // This is generic for all quadratic extensions (Fp2)\n      const { c0, c1 } = num;\n      if (Fp.is0(c1)) {\n        // if c0 is quadratic residue\n        if (mod.FpLegendre(Fp, c0) === 1) return Fp2.create({ c0: Fp.sqrt(c0), c1: Fp.ZERO });\n        else return Fp2.create({ c0: Fp.ZERO, c1: Fp.sqrt(Fp.div(c0, FpNONRESIDUE)) });\n      }\n      const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), FpNONRESIDUE)));\n      let d = Fp.mul(Fp.add(a, c0), Fpdiv2);\n      const legendre = mod.FpLegendre(Fp, d);\n      // -1, Quadratic non residue\n      if (legendre === -1) d = Fp.sub(d, a);\n      const a0 = Fp.sqrt(d);\n      const candidateSqrt = Fp2.create({ c0: a0, c1: Fp.div(Fp.mul(c1, Fpdiv2), a0) });\n      if (!Fp2.eql(Fp2.sqr(candidateSqrt), num)) throw new Error('Cannot find square root');\n      // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\n      const x1 = candidateSqrt;\n      const x2 = Fp2.neg(x1);\n      const { re: re1, im: im1 } = Fp2.reim(x1);\n      const { re: re2, im: im2 } = Fp2.reim(x2);\n      if (im1 > im2 || (im1 === im2 && re1 > re2)) return x1;\n      return x2;\n    },\n    // Same as sgn0_m_eq_2 in RFC 9380\n    isOdd: (x: Fp2) => {\n      const { re: x0, im: x1 } = Fp2.reim(x);\n      const sign_0 = x0 % _2n;\n      const zero_0 = x0 === _0n;\n      const sign_1 = x1 % _2n;\n      return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\n    },\n    // Bytes util\n    fromBytes(b: Uint8Array): Fp2 {\n      if (b.length !== Fp2.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\n    },\n    toBytes: ({ c0, c1 }) => concatBytes(Fp.toBytes(c0), Fp.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n      c0: Fp.cmov(c0, r0, c),\n      c1: Fp.cmov(c1, r1, c),\n    }),\n    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),\n    // multiply by u + 1\n    mulByNonresidue: ({ c0, c1 }) => Fp2.mul({ c0, c1 }, Fp2Nonresidue),\n    mulByB: opts.Fp2mulByB,\n    fromBigTuple: Fp2fromBigTuple,\n    frobeniusMap: ({ c0, c1 }, power: number): Fp2 => ({\n      c0,\n      c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2]),\n    }),\n  };\n  // Fp6\n  const Fp6Add = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\n    c0: Fp2.add(c0, r0),\n    c1: Fp2.add(c1, r1),\n    c2: Fp2.add(c2, r2),\n  });\n  const Fp6Subtract = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\n    c0: Fp2.sub(c0, r0),\n    c1: Fp2.sub(c1, r1),\n    c2: Fp2.sub(c2, r2),\n  });\n  const Fp6Multiply = ({ c0, c1, c2 }: Fp6, rhs: Fp6 | bigint) => {\n    if (typeof rhs === 'bigint') {\n      return {\n        c0: Fp2.mul(c0, rhs),\n        c1: Fp2.mul(c1, rhs),\n        c2: Fp2.mul(c2, rhs),\n      };\n    }\n    const { c0: r0, c1: r1, c2: r2 } = rhs;\n    const t0 = Fp2.mul(c0, r0); // c0 * o0\n    const t1 = Fp2.mul(c1, r1); // c1 * o1\n    const t2 = Fp2.mul(c2, r2); // c2 * o2\n    return {\n      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n      c0: Fp2.add(\n        t0,\n        Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))\n      ),\n      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n      c1: Fp2.add(\n        Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)),\n        Fp2.mulByNonresidue(t2)\n      ),\n      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n      c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\n    };\n  };\n  const Fp6Square = ({ c0, c1, c2 }: Fp6) => {\n    let t0 = Fp2.sqr(c0); // c0²\n    let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n    let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n    let t4 = Fp2.sqr(c2); // c2²\n    return {\n      c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\n      c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\n      // T1 + (c0 - c1 + c2)² + T3 - T0 - T4\n      c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\n    };\n  };\n  type Fp6Utils = {\n    fromBigSix: (tuple: BigintSix) => Fp6;\n    mulByNonresidue: (num: Fp6) => Fp6;\n    frobeniusMap(num: Fp6, power: number): Fp6;\n    mul1(num: Fp6, b1: Fp2): Fp6;\n    mul01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\n    mulByFp2(lhs: Fp6, rhs: Fp2): Fp6;\n  };\n\n  const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(\n    Fp2,\n    Fp2Nonresidue,\n    Fp.ORDER,\n    6,\n    2,\n    3\n  );\n\n  const Fp6: mod.IField<Fp6> & Fp6Utils = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    isLE: Fp2.isLE,\n    BITS: 3 * Fp2.BITS,\n    BYTES: 3 * Fp2.BYTES,\n    MASK: bitMask(3 * Fp2.BITS),\n    ZERO: { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    ONE: { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1, c2 }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\n    is0: ({ c0, c1, c2 }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\n    neg: ({ c0, c1, c2 }) => ({ c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) }),\n    eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) =>\n      Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\n    sqrt: notImplemented,\n    // Do we need division by bigint at all? Should be done via order:\n    div: (lhs, rhs) =>\n      Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp6, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp6, nums),\n    // Normalized\n    add: Fp6Add,\n    sub: Fp6Subtract,\n    mul: Fp6Multiply,\n    sqr: Fp6Square,\n    // NonNormalized stuff\n    addN: Fp6Add,\n    subN: Fp6Subtract,\n    mulN: Fp6Multiply,\n    sqrN: Fp6Square,\n\n    inv: ({ c0, c1, c2 }) => {\n      let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0² - c2 * c1 * (u + 1)\n      let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2² * (u + 1) - c0 * c1\n      let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1² - c0 * c2\n      // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n      let t4 = Fp2.inv(\n        Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0))\n      );\n      return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\n    },\n    // Bytes utils\n    fromBytes: (b: Uint8Array): Fp6 => {\n      if (b.length !== Fp6.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\n        c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\n        c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES)),\n      };\n    },\n    toBytes: ({ c0, c1, c2 }): Uint8Array =>\n      concatBytes(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\n    cmov: ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6, c) => ({\n      c0: Fp2.cmov(c0, r0, c),\n      c1: Fp2.cmov(c1, r1, c),\n      c2: Fp2.cmov(c2, r2, c),\n    }),\n    fromBigSix: (t: BigintSix): Fp6 => {\n      if (!Array.isArray(t) || t.length !== 6) throw new Error('invalid Fp6 usage');\n      return {\n        c0: Fp2.fromBigTuple(t.slice(0, 2)),\n        c1: Fp2.fromBigTuple(t.slice(2, 4)),\n        c2: Fp2.fromBigTuple(t.slice(4, 6)),\n      };\n    },\n    frobeniusMap: ({ c0, c1, c2 }, power: number) => ({\n      c0: Fp2.frobeniusMap(c0, power),\n      c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\n      c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6]),\n    }),\n    mulByFp2: ({ c0, c1, c2 }, rhs: Fp2): Fp6 => ({\n      c0: Fp2.mul(c0, rhs),\n      c1: Fp2.mul(c1, rhs),\n      c2: Fp2.mul(c2, rhs),\n    }),\n    mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 }),\n    // Sparse multiplication\n    mul1: ({ c0, c1, c2 }, b1: Fp2): Fp6 => ({\n      c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n      c1: Fp2.mul(c0, b1),\n      c2: Fp2.mul(c1, b1),\n    }),\n    // Sparse multiplication\n    mul01({ c0, c1, c2 }, b0: Fp2, b1: Fp2): Fp6 {\n      let t0 = Fp2.mul(c0, b0); // c0 * b0\n      let t1 = Fp2.mul(c1, b1); // c1 * b1\n      return {\n        // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n        c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n        // (b0 + b1) * (c0 + c1) - T0 - T1\n        c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n        // (c0 + c2) * b0 - T0 + T1\n        c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\n      };\n    },\n  };\n\n  // Fp12\n  const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(\n    Fp2,\n    Fp2Nonresidue,\n    Fp.ORDER,\n    12,\n    1,\n    6\n  )[0];\n\n  const Fp12Add = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\n    c0: Fp6.add(c0, r0),\n    c1: Fp6.add(c1, r1),\n  });\n  const Fp12Subtract = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\n    c0: Fp6.sub(c0, r0),\n    c1: Fp6.sub(c1, r1),\n  });\n  const Fp12Multiply = ({ c0, c1 }: Fp12, rhs: Fp12 | bigint) => {\n    if (typeof rhs === 'bigint') return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\n    let { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp6.mul(c0, r0); // c0 * r0\n    let t2 = Fp6.mul(c1, r1); // c1 * r1\n    return {\n      c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\n      // (c0 + c1) * (r0 + r1) - (T1 + T2)\n      c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\n    };\n  };\n  const Fp12Square = ({ c0, c1 }: Fp12) => {\n    let ab = Fp6.mul(c0, c1); // c0 * c1\n    return {\n      // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n      c0: Fp6.sub(\n        Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab),\n        Fp6.mulByNonresidue(ab)\n      ),\n      c1: Fp6.add(ab, ab),\n    }; // AB + AB\n  };\n  function Fp4Square(a: Fp2, b: Fp2): { first: Fp2; second: Fp2 } {\n    const a2 = Fp2.sqr(a);\n    const b2 = Fp2.sqr(b);\n    return {\n      first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b² * Nonresidue + a²\n      second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b)² - a² - b²\n    };\n  }\n  type Fp12Utils = {\n    fromBigTwelve: (t: BigintTwelve) => Fp12;\n    frobeniusMap(num: Fp12, power: number): Fp12;\n    mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n    mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n    mulByFp2(lhs: Fp12, rhs: Fp2): Fp12;\n    conjugate(num: Fp12): Fp12;\n    finalExponentiate(num: Fp12): Fp12;\n    _cyclotomicSquare(num: Fp12): Fp12;\n    _cyclotomicExp(num: Fp12, n: bigint): Fp12;\n  };\n\n  const Fp12: mod.IField<Fp12> & Fp12Utils = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    isLE: Fp6.isLE,\n    BITS: 2 * Fp6.BITS,\n    BYTES: 2 * Fp6.BYTES,\n    MASK: bitMask(2 * Fp6.BITS),\n    ZERO: { c0: Fp6.ZERO, c1: Fp6.ZERO },\n    ONE: { c0: Fp6.ONE, c1: Fp6.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => Fp6.isValid(c0) && Fp6.isValid(c1),\n    is0: ({ c0, c1 }) => Fp6.is0(c0) && Fp6.is0(c1),\n    neg: ({ c0, c1 }) => ({ c0: Fp6.neg(c0), c1: Fp6.neg(c1) }),\n    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\n    sqrt: notImplemented,\n    inv: ({ c0, c1 }) => {\n      let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0² - c1² * v)\n      return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\n    },\n    div: (lhs, rhs) =>\n      Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp12, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp12, nums),\n    // Normalized\n    add: Fp12Add,\n    sub: Fp12Subtract,\n    mul: Fp12Multiply,\n    sqr: Fp12Square,\n    // NonNormalized stuff\n    addN: Fp12Add,\n    subN: Fp12Subtract,\n    mulN: Fp12Multiply,\n    sqrN: Fp12Square,\n\n    // Bytes utils\n    fromBytes: (b: Uint8Array): Fp12 => {\n      if (b.length !== Fp12.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n        c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\n      };\n    },\n    toBytes: ({ c0, c1 }): Uint8Array => concatBytes(Fp6.toBytes(c0), Fp6.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n      c0: Fp6.cmov(c0, r0, c),\n      c1: Fp6.cmov(c1, r1, c),\n    }),\n    // Utils\n    // toString() {\n    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');\n    // },\n    // fromTuple(c: [Fp6, Fp6]) {\n    //   return new Fp12(...c);\n    // }\n    fromBigTwelve: (t: BigintTwelve): Fp12 => ({\n      c0: Fp6.fromBigSix(t.slice(0, 6) as BigintSix),\n      c1: Fp6.fromBigSix(t.slice(6, 12) as BigintSix),\n    }),\n    // Raises to q**i -th power\n    frobeniusMap(lhs, power: number) {\n      const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\n      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\n      return {\n        c0: Fp6.frobeniusMap(lhs.c0, power),\n        c1: Fp6.create({\n          c0: Fp2.mul(c0, coeff),\n          c1: Fp2.mul(c1, coeff),\n          c2: Fp2.mul(c2, coeff),\n        }),\n      };\n    },\n    mulByFp2: ({ c0, c1 }, rhs: Fp2): Fp12 => ({\n      c0: Fp6.mulByFp2(c0, rhs),\n      c1: Fp6.mulByFp2(c1, rhs),\n    }),\n    conjugate: ({ c0, c1 }): Fp12 => ({ c0, c1: Fp6.neg(c1) }),\n    // Sparse multiplication\n    mul014: ({ c0, c1 }, o0: Fp2, o1: Fp2, o4: Fp2) => {\n      let t0 = Fp6.mul01(c0, o0, o1);\n      let t1 = Fp6.mul1(c1, o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\n        // (c1 + c0) * [o0, o1+o4] - T0 - T1\n        c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\n      };\n    },\n    mul034: ({ c0, c1 }, o0: Fp2, o3: Fp2, o4: Fp2) => {\n      const a = Fp6.create({\n        c0: Fp2.mul(c0.c0, o0),\n        c1: Fp2.mul(c0.c1, o0),\n        c2: Fp2.mul(c0.c2, o0),\n      });\n      const b = Fp6.mul01(c1, o3, o4);\n      const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(b), a),\n        c1: Fp6.sub(e, Fp6.add(a, b)),\n      };\n    },\n\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    _cyclotomicSquare: opts.Fp12cyclotomicSquare,\n    _cyclotomicExp: opts.Fp12cyclotomicExp,\n    // https://eprint.iacr.org/2010/354.pdf\n    // https://eprint.iacr.org/2009/565.pdf\n    finalExponentiate: opts.Fp12finalExponentiate,\n  };\n\n  return { Fp, Fp2, Fp6, Fp4Square, Fp12 };\n}\n", "/**\n * bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\n * * Construct zk-SNARKs at the ~120-bit security\n * * Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\n *   the Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\n *\n * ### Summary\n * 1. BLS Relies on Bilinear Pairing (expensive)\n * 2. Private Keys: 32 bytes\n * 3. Public Keys: 48 bytes: 381 bit affine x coordinate, encoded into 48 big-endian bytes.\n * 4. Signatures: 96 bytes: two 381 bit integers (affine x coordinate), encoded into two 48 big-endian byte arrays.\n *     - The signature is a point on the G2 subgroup, which is defined over a finite field\n *       with elements twice as big as the G1 curve (G2 is over Fp2 rather than Fp. Fp2 is analogous to the\n *       complex numbers).\n *     - We also support reversed 96-byte pubkeys & 48-byte short signatures.\n * 5. The 12 stands for the Embedding degree.\n *\n * ### Formulas\n * - `P = pk x G` - public keys\n * - `S = pk x H(m)` - signing\n * - `e(P, H(m)) == e(G, S)` - verification using pairings\n * - `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\n *\n * ### Compatibility and notes\n * 1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC.\n * Filecoin uses little endian byte arrays for private keys - make sure to reverse byte order.\n * 2. Some projects use G2 for public keys and G1 for signatures. It's called \"short signature\".\n * 3. Curve security level is about 120 bits as per [Barbulescu-Duquesne 2017](https://hal.science/hal-01534101/file/main.pdf)\n * 4. Compatible with specs:\n *    [cfrg-pairing-friendly-curves-11](https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11),\n *    [cfrg-bls-signature-05](https://www.rfc-editor.org/rfc/draft-irtf-cfrg-bls-signature-05),\n *    RFC 9380.\n *\n * ### Params\n * To verify curve parameters, see\n * [pairing-friendly-curves spec](https://www.rfc-editor.org/rfc/draft-irtf-cfrg-pairing-friendly-curves-11).\n * Basic math is done over finite fields over p.\n * More complicated math is done over polynominal extension fields.\n * To simplify calculations in Fp12, we construct extension tower:\n *\n * Embedding degree (k): 12\n * Seed (X): -15132376222941642752\n * Fr:  (x⁴-x²+1)\n * Fp: ((x-1)² ⋅ r(x)/3+x)\n * (E/Fp): Y²=X³+4\n * (Eₜ/Fp²): Y² = X³+4(u+1) (M-type twist)\n * Ate loop size: X\n *\n * ### Towers\n * - Fp₁₂ = Fp₆² => Fp₂³\n * - Fp(u) / (u² - β) where β = -1\n * - Fp₂(v) / (v³ - ξ) where ξ = u + 1\n * - Fp₆(w) / (w² - γ) where γ = v\n * - Fp²[u] = Fp/u²+1\n * - Fp⁶[v] = Fp²/v³-1-u\n * - Fp¹²[w] = Fp⁶/w²-v\n *\n * @todo construct bls & bn fp/fr from seed.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { bls, type CurveFn } from './abstract/bls.ts';\nimport { Field } from './abstract/modular.ts';\nimport {\n  bitGet,\n  bitLen,\n  bytesToHex,\n  bytesToNumberBE,\n  concatBytes as concatB,\n  ensureBytes,\n  numberToBytesBE,\n  type Hex,\n} from './abstract/utils.ts';\n// Types\nimport { isogenyMap } from './abstract/hash-to-curve.ts';\nimport type { Fp, Fp12, Fp2, Fp6 } from './abstract/tower.ts';\nimport { psiFrobenius, tower12 } from './abstract/tower.ts';\nimport {\n  mapToCurveSimpleSWU,\n  type AffinePoint,\n  type ProjPointType,\n} from './abstract/weierstrass.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\n// The BLS parameter x (seed) for BLS12-381. NOTE: it is negative!\nconst BLS_X = BigInt('0xd201000000010000');\nconst BLS_X_LEN = bitLen(BLS_X);\n\n// CURVE FIELDS\nconst { Fp, Fp2, Fp6, Fp4Square, Fp12 } = tower12({\n  // Order of Fp\n  ORDER: BigInt(\n    '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'\n  ),\n  // Finite extension field over irreducible polynominal.\n  // Fp(u) / (u² - β) where β = -1\n  FP2_NONRESIDUE: [_1n, _1n],\n  Fp2mulByB: ({ c0, c1 }) => {\n    const t0 = Fp.mul(c0, _4n); // 4 * c0\n    const t1 = Fp.mul(c1, _4n); // 4 * c1\n    // (T0-T1) + (T0+T1)*i\n    return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };\n  },\n  // Fp12\n  // A cyclotomic group is a subgroup of Fp^n defined by\n  //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n  // The result of any pairing is in a cyclotomic subgroup\n  // https://eprint.iacr.org/2009/565.pdf\n  Fp12cyclotomicSquare: ({ c0, c1 }): Fp12 => {\n    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\n    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\n    const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);\n    const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);\n    const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);\n    const t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\n    return {\n      c0: Fp6.create({\n        c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3), // 2 * (T3 - c0c0)  + T3\n        c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5), // 2 * (T5 - c0c1)  + T5\n        c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7),\n      }), // 2 * (T7 - c0c2)  + T7\n      c1: Fp6.create({\n        c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9), // 2 * (T9 + c1c0) + T9\n        c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4), // 2 * (T4 + c1c1) + T4\n        c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6),\n      }),\n    }; // 2 * (T6 + c1c2) + T6\n  },\n  Fp12cyclotomicExp(num, n) {\n    let z = Fp12.ONE;\n    for (let i = BLS_X_LEN - 1; i >= 0; i--) {\n      z = Fp12._cyclotomicSquare(z);\n      if (bitGet(n, i)) z = Fp12.mul(z, num);\n    }\n    return z;\n  },\n  // https://eprint.iacr.org/2010/354.pdf\n  // https://eprint.iacr.org/2009/565.pdf\n  Fp12finalExponentiate: (num) => {\n    const x = BLS_X;\n    // this^(q⁶) / this\n    const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\n    // t0^(q²) * t0\n    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\n    const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\n    const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\n    const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\n    const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\n    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\n    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\n    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\n    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\n    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\n    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\n    // (t2 * t5)^(q²) * (t4 * t1)^(q³) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\n    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\n  },\n});\n\n// Finite field over r.\n// This particular field is not used anywhere in bls12-381, but it is still useful.\nconst Fr = Field(BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'));\n\n// END OF CURVE FIELDS\n\n// HashToCurve\n\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\nconst isogenyMapG2 = isogenyMap(\n  Fp2,\n  [\n    // xNum\n    [\n      [\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n      ],\n      [\n        '0x0',\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a',\n      ],\n      [\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d',\n      ],\n      [\n        '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',\n        '0x0',\n      ],\n    ],\n    // xDen\n    [\n      [\n        '0x0',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63',\n      ],\n      [\n        '0xc',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f',\n      ],\n      ['0x1', '0x0'], // LAST 1\n    ],\n    // yNum\n    [\n      [\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n      ],\n      [\n        '0x0',\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be',\n      ],\n      [\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f',\n      ],\n      [\n        '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',\n        '0x0',\n      ],\n    ],\n    // yDen\n    [\n      [\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n      ],\n      [\n        '0x0',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3',\n      ],\n      [\n        '0x12',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99',\n      ],\n      ['0x1', '0x0'], // LAST 1\n    ],\n  ].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))) as [Fp2[], Fp2[], Fp2[], Fp2[]]\n);\n// 11-isogeny map from E' to E\nconst isogenyMapG1 = isogenyMap(\n  Fp,\n  [\n    // xNum\n    [\n      '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',\n      '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',\n      '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',\n      '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',\n      '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',\n      '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',\n      '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',\n      '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',\n      '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',\n      '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',\n      '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',\n      '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229',\n    ],\n    // xDen\n    [\n      '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',\n      '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',\n      '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',\n      '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',\n      '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',\n      '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',\n      '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',\n      '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',\n      '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',\n      '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n      '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',\n      '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',\n      '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',\n      '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',\n      '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',\n      '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',\n      '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',\n      '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',\n      '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',\n      '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',\n      '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',\n      '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',\n      '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',\n      '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',\n      '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',\n      '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604',\n    ],\n    // yDen\n    [\n      '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',\n      '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',\n      '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',\n      '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',\n      '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',\n      '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',\n      '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',\n      '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',\n      '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',\n      '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',\n      '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',\n      '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',\n      '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',\n      '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',\n      '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n  ].map((i) => i.map((j) => BigInt(j))) as [Fp[], Fp[], Fp[], Fp[]]\n);\n\n// SWU Map - Fp2 to G2': y² = x³ + 240i * x + 1012 + 1012i\nconst G2_SWU = mapToCurveSimpleSWU(Fp2, {\n  A: Fp2.create({ c0: Fp.create(_0n), c1: Fp.create(BigInt(240)) }), // A' = 240 * I\n  B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }), // B' = 1012 * (1 + I)\n  Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) }), // Z: -(2 + I)\n});\n// Optimized SWU Map - Fp to G1\nconst G1_SWU = mapToCurveSimpleSWU(Fp, {\n  A: Fp.create(\n    BigInt(\n      '0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d'\n    )\n  ),\n  B: Fp.create(\n    BigInt(\n      '0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0'\n    )\n  ),\n  Z: Fp.create(BigInt(11)),\n});\n\n// GLV endomorphism Ψ(P), for fast cofactor clearing\nconst { G2psi, G2psi2 } = psiFrobenius(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE)); // 1/(u+1)\n\n// Default hash_to_field options are for hash to G2.\n//\n// Parameter definitions are in section 5.3 of the spec unless otherwise noted.\n// Parameter values come from section 8.8.2 of the spec.\n// https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2\n//\n// Base field F is GF(p^m)\n// p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n// m = 2 (or 1 for G1 see section 8.8.1)\n// k = 128\nconst htfDefaults = Object.freeze({\n  // DST: a domain separation tag\n  // defined in section 2.2.5\n  // Use utils.getDSTLabel(), utils.setDSTLabel(value)\n  DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n  encodeDST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n  // p: the characteristic of F\n  //    where F is a finite field of characteristic p and order q = p^m\n  p: Fp.ORDER,\n  // m: the extension degree of F, m >= 1\n  //     where F is a finite field of characteristic p and order q = p^m\n  m: 2,\n  // k: the target security level for the suite in bits\n  // defined in section 5.1\n  k: 128,\n  // option to use a message that has already been processed by\n  // expand_message_xmd\n  expand: 'xmd',\n  // Hash functions for: expand_message_xmd is appropriate for use with a\n  // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.\n  // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247\n  hash: sha256,\n} as const);\n\n// Encoding utils\n// Point on G1 curve: (x, y)\n\n// Compressed point of infinity\nconst COMPRESSED_ZERO = setMask(Fp.toBytes(_0n), { infinity: true, compressed: true }); // set compressed & point-at-infinity bits\n\nfunction parseMask(bytes: Uint8Array) {\n  // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\n  bytes = bytes.slice();\n  const mask = bytes[0] & 0b1110_0000;\n  const compressed = !!((mask >> 7) & 1); // compression bit (0b1000_0000)\n  const infinity = !!((mask >> 6) & 1); // point at infinity bit (0b0100_0000)\n  const sort = !!((mask >> 5) & 1); // sort bit (0b0010_0000)\n  bytes[0] &= 0b0001_1111; // clear mask (zero first 3 bits)\n  return { compressed, infinity, sort, value: bytes };\n}\n\nfunction setMask(\n  bytes: Uint8Array,\n  mask: { compressed?: boolean; infinity?: boolean; sort?: boolean }\n) {\n  if (bytes[0] & 0b1110_0000) throw new Error('setMask: non-empty mask');\n  if (mask.compressed) bytes[0] |= 0b1000_0000;\n  if (mask.infinity) bytes[0] |= 0b0100_0000;\n  if (mask.sort) bytes[0] |= 0b0010_0000;\n  return bytes;\n}\n\nfunction signatureG1ToRawBytes(point: ProjPointType<Fp>) {\n  point.assertValidity();\n  const isZero = point.equals(bls12_381.G1.ProjectivePoint.ZERO);\n  const { x, y } = point.toAffine();\n  if (isZero) return COMPRESSED_ZERO.slice();\n  const P = Fp.ORDER;\n  const sort = Boolean((y * _2n) / P);\n  return setMask(numberToBytesBE(x, Fp.BYTES), { compressed: true, sort });\n}\n\nfunction signatureG2ToRawBytes(point: ProjPointType<Fp2>) {\n  // NOTE: by some reasons it was missed in bls12-381, looks like bug\n  point.assertValidity();\n  const len = Fp.BYTES;\n  if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))\n    return concatB(COMPRESSED_ZERO, numberToBytesBE(_0n, len));\n  const { x, y } = point.toAffine();\n  const { re: x0, im: x1 } = Fp2.reim(x);\n  const { re: y0, im: y1 } = Fp2.reim(y);\n  const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\n  const sort = Boolean((tmp / Fp.ORDER) & _1n);\n  const z2 = x0;\n  return concatB(\n    setMask(numberToBytesBE(x1, len), { sort, compressed: true }),\n    numberToBytesBE(z2, len)\n  );\n}\n\n/**\n * bls12-381 pairing-friendly curve.\n * @example\n * import { bls12_381 as bls } from '@noble/curves/bls12-381';\n * // G1 keys, G2 signatures\n * const privateKey = '67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c';\n * const message = '64726e3da8';\n * const publicKey = bls.getPublicKey(privateKey);\n * const signature = bls.sign(message, privateKey);\n * const isValid = bls.verify(signature, message, publicKey);\n */\nexport const bls12_381: CurveFn = bls({\n  // Fields\n  fields: {\n    Fp,\n    Fp2,\n    Fp6,\n    Fp12,\n    Fr,\n  },\n  // G1 is the order-q subgroup of E1(Fp) : y² = x³ + 4, #E1(Fp) = h1q, where\n  // characteristic; z + (z⁴ - z² + 1)(z - 1)²/3\n  G1: {\n    Fp,\n    // cofactor; (z - 1)²/3\n    h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),\n    // generator's coordinates\n    // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n    // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\n    Gx: BigInt(\n      '0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'\n    ),\n    Gy: BigInt(\n      '0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'\n    ),\n    a: Fp.ZERO,\n    b: _4n,\n    htfDefaults: { ...htfDefaults, m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    // Checks is the point resides in prime-order subgroup.\n    // point.isTorsionFree() should return true for valid points\n    // It returns false for shitty points.\n    // https://eprint.iacr.org/2021/1130.pdf\n    isTorsionFree: (c, point): boolean => {\n      // GLV endomorphism ψ(P)\n      const beta = BigInt(\n        '0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'\n      );\n      const phi = new c(Fp.mul(point.px, beta), point.py, point.pz);\n      // TODO: unroll\n      const xP = point.multiplyUnsafe(BLS_X).negate(); // [x]P\n      const u2P = xP.multiplyUnsafe(BLS_X); // [u2]P\n      return u2P.equals(phi);\n    },\n    // Clear cofactor of G1\n    // https://eprint.iacr.org/2019/403\n    clearCofactor: (_c, point) => {\n      // return this.multiplyUnsafe(CURVE.h);\n      return point.multiplyUnsafe(BLS_X).add(point); // x*P + P\n    },\n    mapToCurve: (scalars: bigint[]) => {\n      const { x, y } = G1_SWU(Fp.create(scalars[0]));\n      return isogenyMapG1(x, y);\n    },\n    fromBytes: (bytes: Uint8Array): AffinePoint<Fp> => {\n      const { compressed, infinity, sort, value } = parseMask(bytes);\n      if (value.length === 48 && compressed) {\n        // TODO: Fp.bytes\n        const P = Fp.ORDER;\n        const compressedValue = bytesToNumberBE(value);\n        // Zero\n        const x = Fp.create(compressedValue & Fp.MASK);\n        if (infinity) {\n          if (x !== _0n) throw new Error('G1: non-empty compressed point at infinity');\n          return { x: _0n, y: _0n };\n        }\n        const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y² = x³ + b\n        let y = Fp.sqrt(right);\n        if (!y) throw new Error('invalid compressed G1 point');\n        if ((y * _2n) / P !== BigInt(sort)) y = Fp.neg(y);\n        return { x: Fp.create(x), y: Fp.create(y) };\n      } else if (value.length === 96 && !compressed) {\n        // Check if the infinity flag is set\n        const x = bytesToNumberBE(value.subarray(0, Fp.BYTES));\n        const y = bytesToNumberBE(value.subarray(Fp.BYTES));\n        if (infinity) {\n          if (x !== _0n || y !== _0n) throw new Error('G1: non-empty point at infinity');\n          return bls12_381.G1.ProjectivePoint.ZERO.toAffine();\n        }\n        return { x: Fp.create(x), y: Fp.create(y) };\n      } else {\n        throw new Error('invalid point G1, expected 48/96 bytes');\n      }\n    },\n    toBytes: (c, point, isCompressed) => {\n      const isZero = point.equals(c.ZERO);\n      const { x, y } = point.toAffine();\n      if (isCompressed) {\n        if (isZero) return COMPRESSED_ZERO.slice();\n        const P = Fp.ORDER;\n        const sort = Boolean((y * _2n) / P);\n        return setMask(numberToBytesBE(x, Fp.BYTES), { compressed: true, sort });\n      } else {\n        if (isZero) {\n          // 2x PUBLIC_KEY_LENGTH\n          const x = concatB(new Uint8Array([0x40]), new Uint8Array(2 * Fp.BYTES - 1));\n          return x;\n        } else {\n          return concatB(numberToBytesBE(x, Fp.BYTES), numberToBytesBE(y, Fp.BYTES));\n        }\n      }\n    },\n    ShortSignature: {\n      fromHex(hex: Hex): ProjPointType<Fp> {\n        const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex, 48));\n        const P = Fp.ORDER;\n        const compressedValue = bytesToNumberBE(value);\n        // Zero\n        if (infinity) return bls12_381.G1.ProjectivePoint.ZERO;\n        const x = Fp.create(compressedValue & Fp.MASK);\n        const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y² = x³ + b\n        let y = Fp.sqrt(right);\n        if (!y) throw new Error('invalid compressed G1 point');\n        const aflag = BigInt(sort);\n        if ((y * _2n) / P !== aflag) y = Fp.neg(y);\n        const point = bls12_381.G1.ProjectivePoint.fromAffine({ x, y });\n        point.assertValidity();\n        return point;\n      },\n      toRawBytes(point: ProjPointType<Fp>) {\n        return signatureG1ToRawBytes(point);\n      },\n      toHex(point: ProjPointType<Fp>) {\n        return bytesToHex(signatureG1ToRawBytes(point));\n      },\n    },\n  },\n  // G2 is the order-q subgroup of E2(Fp²) : y² = x³+4(1+√−1),\n  // where Fp2 is Fp[√−1]/(x2+1). #E2(Fp2 ) = h2q, where\n  // G² - 1\n  // h2q\n  G2: {\n    Fp: Fp2,\n    // cofactor\n    h: BigInt(\n      '0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'\n    ),\n    Gx: Fp2.fromBigTuple([\n      BigInt(\n        '0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'\n      ),\n      BigInt(\n        '0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e'\n      ),\n    ]),\n    // y =\n    // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,\n    // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n    Gy: Fp2.fromBigTuple([\n      BigInt(\n        '0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'\n      ),\n      BigInt(\n        '0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be'\n      ),\n    ]),\n    a: Fp2.ZERO,\n    b: Fp2.fromBigTuple([_4n, _4n]),\n    hEff: BigInt(\n      '0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'\n    ),\n    htfDefaults: { ...htfDefaults },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    mapToCurve: (scalars: bigint[]) => {\n      const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars));\n      return isogenyMapG2(x, y);\n    },\n    // Checks is the point resides in prime-order subgroup.\n    // point.isTorsionFree() should return true for valid points\n    // It returns false for shitty points.\n    // https://eprint.iacr.org/2021/1130.pdf\n    // Older version: https://eprint.iacr.org/2019/814.pdf\n    isTorsionFree: (c, P): boolean => {\n      return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P)); // ψ(P) == [u](P)\n    },\n    // Maps the point into the prime-order subgroup G2.\n    // clear_cofactor_bls12381_g2 from RFC 9380.\n    // https://eprint.iacr.org/2017/419.pdf\n    // prettier-ignore\n    clearCofactor: (c, P) => {\n      const x = BLS_X;\n      let t1 = P.multiplyUnsafe(x).negate();  // [-x]P\n      let t2 = G2psi(c, P);                   // Ψ(P)\n      let t3 = P.double();                    // 2P\n      t3 = G2psi2(c, t3);                     // Ψ²(2P)\n      t3 = t3.subtract(t2);                   // Ψ²(2P) - Ψ(P)\n      t2 = t1.add(t2);                        // [-x]P + Ψ(P)\n      t2 = t2.multiplyUnsafe(x).negate();     // [x²]P - [x]Ψ(P)\n      t3 = t3.add(t2);                        // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P)\n      t3 = t3.subtract(t1);                   // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P\n      const Q = t3.subtract(P);               // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P - 1P\n      return Q;                               // [x²-x-1]P + [x-1]Ψ(P) + Ψ²(2P)\n    },\n    fromBytes: (bytes: Uint8Array): AffinePoint<Fp2> => {\n      const { compressed, infinity, sort, value } = parseMask(bytes);\n      if (\n        (!compressed && !infinity && sort) || // 00100000\n        (!compressed && infinity && sort) || // 01100000\n        (sort && infinity && compressed) // 11100000\n      ) {\n        throw new Error('invalid encoding flag: ' + (bytes[0] & 0b1110_0000));\n      }\n      const L = Fp.BYTES;\n      const slc = (b: Uint8Array, from: number, to?: number) => bytesToNumberBE(b.slice(from, to));\n      if (value.length === 96 && compressed) {\n        const b = bls12_381.params.G2b;\n        const P = Fp.ORDER;\n        if (infinity) {\n          // check that all bytes are 0\n          if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n            throw new Error('invalid compressed G2 point');\n          }\n          return { x: Fp2.ZERO, y: Fp2.ZERO };\n        }\n        const x_1 = slc(value, 0, L);\n        const x_0 = slc(value, L, 2 * L);\n        const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });\n        const right = Fp2.add(Fp2.pow(x, _3n), b); // y² = x³ + 4 * (u+1) = x³ + b\n        let y = Fp2.sqrt(right);\n        const Y_bit = y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P ? _1n : _0n;\n        y = sort && Y_bit > 0 ? y : Fp2.neg(y);\n        return { x, y };\n      } else if (value.length === 192 && !compressed) {\n        if (infinity) {\n          if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n            throw new Error('invalid uncompressed G2 point');\n          }\n          return { x: Fp2.ZERO, y: Fp2.ZERO };\n        }\n        const x1 = slc(value, 0, L);\n        const x0 = slc(value, L, 2 * L);\n        const y1 = slc(value, 2 * L, 3 * L);\n        const y0 = slc(value, 3 * L, 4 * L);\n        return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };\n      } else {\n        throw new Error('invalid point G2, expected 96/192 bytes');\n      }\n    },\n    toBytes: (c, point, isCompressed) => {\n      const { BYTES: len, ORDER: P } = Fp;\n      const isZero = point.equals(c.ZERO);\n      const { x, y } = point.toAffine();\n      if (isCompressed) {\n        if (isZero) return concatB(COMPRESSED_ZERO, numberToBytesBE(_0n, len));\n        const flag = Boolean(y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P);\n        return concatB(\n          setMask(numberToBytesBE(x.c1, len), { compressed: true, sort: flag }),\n          numberToBytesBE(x.c0, len)\n        );\n      } else {\n        if (isZero) return concatB(new Uint8Array([0x40]), new Uint8Array(4 * len - 1)); // bytes[0] |= 1 << 6;\n        const { re: x0, im: x1 } = Fp2.reim(x);\n        const { re: y0, im: y1 } = Fp2.reim(y);\n        return concatB(\n          numberToBytesBE(x1, len),\n          numberToBytesBE(x0, len),\n          numberToBytesBE(y1, len),\n          numberToBytesBE(y0, len)\n        );\n      }\n    },\n    Signature: {\n      // TODO: Optimize, it's very slow because of sqrt.\n      fromHex(hex: Hex): ProjPointType<Fp2> {\n        const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex));\n        const P = Fp.ORDER;\n        const half = value.length / 2;\n        if (half !== 48 && half !== 96)\n          throw new Error('invalid compressed signature length, must be 96 or 192');\n        const z1 = bytesToNumberBE(value.slice(0, half));\n        const z2 = bytesToNumberBE(value.slice(half));\n        // Indicates the infinity point\n        if (infinity) return bls12_381.G2.ProjectivePoint.ZERO;\n        const x1 = Fp.create(z1 & Fp.MASK);\n        const x2 = Fp.create(z2);\n        const x = Fp2.create({ c0: x2, c1: x1 });\n        const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381.params.G2b); // y² = x³ + 4\n        // The slow part\n        let y = Fp2.sqrt(y2);\n        if (!y) throw new Error('Failed to find a square root');\n\n        // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n        // If y1 happens to be zero, then use the bit of y0\n        const { re: y0, im: y1 } = Fp2.reim(y);\n        const aflag1 = BigInt(sort);\n        const isGreater = y1 > _0n && (y1 * _2n) / P !== aflag1;\n        const isZero = y1 === _0n && (y0 * _2n) / P !== aflag1;\n        if (isGreater || isZero) y = Fp2.neg(y);\n        const point = bls12_381.G2.ProjectivePoint.fromAffine({ x, y });\n        point.assertValidity();\n        return point;\n      },\n      toRawBytes(point: ProjPointType<Fp2>) {\n        return signatureG2ToRawBytes(point);\n      },\n      toHex(point: ProjPointType<Fp2>) {\n        return bytesToHex(signatureG2ToRawBytes(point));\n      },\n    },\n  },\n  params: {\n    ateLoopSize: BLS_X, // The BLS parameter x for BLS12-381\n    r: Fr.ORDER, // order; z⁴ − z² + 1; CURVE.n from other curves\n    xNegative: true,\n    twistType: 'multiplicative',\n  },\n  htfDefaults,\n  hash: sha256,\n  randomBytes,\n});\n", "/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport {\n  pippenger, validateBasic, wNAF,\n  type AffinePoint, type BasicCurve, type Group, type GroupConstructor\n} from './curve.ts';\nimport { Field, FpInvertBatch, mod } from './modular.ts';\n// prettier-ignore\nimport {\n  abool, aInRange, bytesToHex, bytesToNumberLE, concatBytes,\n  ensureBytes, memoized, numberToBytesLE, validateObject,\n  type FHash, type Hex\n} from './utils.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n/** Edwards curves must declare params a & d. */\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: (u: bigint, v: bigint) => { isValid: boolean; value: bigint }; // Ratio √(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\nexport type CurveTypeWithLength = Readonly<CurveType & { nByteLength: number; nBitLength: number }>;\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\nfunction validateOpts(curve: CurveType): CurveTypeWithLength {\n  const opts = validateBasic(curve);\n  validateObject(\n    curve,\n    {\n      hash: 'function',\n      a: 'bigint',\n      d: 'bigint',\n      randomBytes: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      uvRatio: 'function',\n      mapToCurve: 'function',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...opts } as const);\n}\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n  _setWindowSize(windowSize: number): void;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n  msm(points: ExtPointType[], scalars: bigint[]): ExtPointType;\n}\n\n/**\n * Edwards Curve interface.\n * Main methods: `getPublicKey(priv)`, `sign(msg, priv)`, `verify(sig, msg, pub)`.\n */\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n    precompute: (windowSize?: number, point?: ExtPointType) => ExtPointType;\n  };\n};\n\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor,\n  } = CURVE;\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n  const modP = Fp.create; // Function overrides\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n\n  function isEdValidXY(x: bigint, y: bigint): boolean {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n  }\n\n  // Validate whether the passed curve params are valid.\n  // equation ax² + y² = 1 + dx²y² should work for generator point.\n  if (!isEdValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n\n  // sqrt(u/v)\n  const uvRatio =\n    CURVE.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    CURVE.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool('phflag', phflag);\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n  // 0 <= n < MASK\n  // Coordinates larger than Fp.ORDER are allowed for zip215\n  function aCoordinate(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n  }\n\n  function aextpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { ex: x, ey: y, ez: z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const { ex: X, ey: Y, ez: Z, et: T } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    readonly ex: bigint;\n    readonly ey: bigint;\n    readonly ez: bigint;\n    readonly et: bigint;\n\n    constructor(ex: bigint, ey: bigint, ez: bigint, et: bigint) {\n      aCoordinate('x', ex);\n      aCoordinate('y', ey);\n      aCoordinate('z', ez, true);\n      aCoordinate('t', et);\n      this.ex = ex;\n      this.ey = ey;\n      this.ez = ez;\n      this.et = et;\n      Object.freeze(this);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      aCoordinate('x', x);\n      aCoordinate('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = FpInvertBatch(\n        Fp,\n        points.map((p) => p.ez)\n      );\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aextpoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aextpoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const n = scalar;\n      aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const { p, f } = this.wNAF(n);\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      const n = scalar;\n      aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return I;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, iz);\n    }\n\n    clearCofactor(): Point {\n      const { h: cofactor } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('pointHex.y', y, _0n, max);\n\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateKey(privKey: Hex): Point {\n      const { scalar } = getPrivateScalar(privKey);\n      return G.multiply(scalar); // reduced one call of `toRawBytes`\n    }\n    toRawBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex(): string {\n      return bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  const { BASE: G, ZERO: I } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return modN(bytesToNumberLE(hash));\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Hex) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  // Convenience method that creates public key from scalar. RFC8032 5.1.5\n  function getExtendedPublicKey(key: Hex) {\n    const { head, prefix, scalar } = getPrivateScalar(key);\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const res = concatBytes(R, numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomPrivateKey: (): Uint8Array => randomBytes(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point: ExtPointType = Point.BASE): ExtPointType {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    },\n  };\n\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils,\n  };\n}\n", "/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod } from './modular.ts';\nimport {\n  aInRange,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesLE,\n  validateObject,\n} from './utils.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  type: 'x25519' | 'x448';\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  powPminus2: (x: bigint) => bigint;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n};\n\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  validateObject(curve, {\n    adjustScalarBytes: 'function',\n    powPminus2: 'function',\n  });\n  return Object.freeze({ ...curve } as const);\n}\n\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P, type, adjustScalarBytes, powPminus2 } = CURVE;\n  const is25519 = type === 'x25519';\n  if (!is25519 && type !== 'x448') throw new Error('invalid type');\n\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  // RFC 7748 #5:\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n  // (156326 - 2) / 4 = 39081 for curve448/X448\n  // const a = is25519 ? 156326n : 486662n;\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n  // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n  // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n  const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n  const maxAdded = is25519\n    ? BigInt(8) * _2n ** BigInt(251) - _1n\n    : BigInt(4) * _2n ** BigInt(445) - _1n;\n  const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n  const modP = (n: bigint) => mod(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), fieldLen);\n  }\n  function decodeU(u: Hex): bigint {\n    const _u = ensureBytes('u coordinate', u, fieldLen);\n    // RFC: When receiving such an array, implementations of X25519\n    // (but not X448) MUST mask the most significant bit in the final byte.\n    if (is25519) _u[31] &= 127; // 0b0111_1111\n    // RFC: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.  The non-canonical\n    // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n    // - 1 through 2^448 - 1 for X448.\n    return modP(bytesToNumberLE(_u));\n  }\n  function decodeScalar(scalar: Hex): bigint {\n    return bytesToNumberLE(adjustScalarBytes(ensureBytes('scalar', scalar, fieldLen)));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    // Some public keys are useless, of low-order. Curve author doesn't think\n    // it needs to be validated, but we do it nonetheless.\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeU(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  // cswap from RFC7748 \"example code\"\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): { x_2: bigint; x_3: bigint } {\n    // dummy = mask(swap) AND (x_2 XOR x_3)\n    // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n    // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n    x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n    return { x_2, x_3 };\n  }\n\n  /**\n   * Montgomery x-only multiplication ladder.\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n    return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => CURVE.randomBytes!(fieldLen) },\n    GuBytes: GuBytes.slice(),\n  };\n}\n", "/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { type AffinePoint, type Group, pippenger } from './abstract/curve.ts';\nimport { type CurveFn, type ExtPointType, twistedEdwards } from './abstract/edwards.ts';\nimport {\n  createHasher,\n  expand_message_xmd,\n  type Hasher,\n  type htfBasicOpts,\n  type HTFMethod,\n} from './abstract/hash-to-curve.ts';\nimport { Field, FpInvertBatch, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.ts';\nimport { montgomery, type CurveFn as XCurveFn } from './abstract/montgomery.ts';\nimport {\n  bytesToHex,\n  bytesToNumberLE,\n  ensureBytes,\n  equalBytes,\n  type Hex,\n  numberToBytesLE,\n} from './abstract/utils.ts';\n\n// 2n**255n - 19n\nconst ED25519_P = BigInt(\n  '57896044618658097711785492504343953926634992332820282019728792003956564819949'\n);\n// √(-1) aka √(a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ED25519_P;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ED25519_P;\n  const v3 = mod(v * v * v, P); // v³\n  const v7 = mod(v3 * v3 * v, P); // v⁷\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx²\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\n/** Weird / bogus points, useful for debugging. */\nexport const ED25519_TORSION_SUBGROUP: string[] = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n\nconst Fp = /* @__PURE__ */ (() => Field(ED25519_P, undefined, true))();\n\nconst ed25519Defaults = /* @__PURE__ */ (() =>\n  ({\n    // Removing Fp.create() will still work, and is 10% faster on sign\n    a: Fp.create(BigInt(-1)),\n    // d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field 2n**255n - 19n\n    Fp,\n    // Subgroup order 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    h: _8n,\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: sha512,\n    randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/√v\n    uvRatio,\n  }) as const)();\n\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const priv = ed25519.utils.randomPrivateKey();\n * const pub = ed25519.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexport const ed25519: CurveFn = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nexport const ed25519ctx: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n  }))();\nexport const ed25519ph: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards(\n    Object.assign({}, ed25519Defaults, {\n      domain: ed25519_domain,\n      prehash: sha512,\n    })\n  ))();\n\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomPrivateKey());\n */\nexport const x25519: XCurveFn = /* @__PURE__ */ (() =>\n  montgomery({\n    P: ED25519_P,\n    type: 'x25519',\n    powPminus2: (x: bigint): bigint => {\n      const P = ED25519_P;\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n  }))();\n\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n  const _1n = BigInt(1);\n  return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery: typeof edwardsToMontgomeryPub = edwardsToMontgomeryPub; // deprecated\n\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\n\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n\nexport const ed25519_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.ExtendedPoint,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => ed25519_hasher.hashToCurve)();\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() =>\n  ed25519_hasher.encodeToCurve)();\n\nfunction aristp(other: unknown) {\n  if (!(other instanceof RistPoint)) throw new Error('RistrettoPoint expected');\n}\n\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d²\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)²\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/√(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = ExtPointType;\n\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519.CURVE;\n  const P = ed25519.CURVE.Fp.ORDER;\n  const mod = ed25519.CURVE.Fp.create;\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass RistPoint implements Group<RistPoint> {\n  static BASE: RistPoint;\n  static ZERO: RistPoint;\n  private readonly ep: ExtendedPoint;\n  // Private property to discourage combining ExtendedPoint + RistrettoPoint\n  // Always use Ristretto encoding/decoding instead.\n  constructor(ep: ExtendedPoint) {\n    this.ep = ep;\n  }\n\n  static fromAffine(ap: AffinePoint<bigint>): RistPoint {\n    return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n  }\n\n  /**\n   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n   * The hash-to-group operation applies Elligator twice and adds the results.\n   * **Note:** this is one-way map, there is no conversion from point to hash.\n   * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n   * the [website](https://ristretto.group/formulas/elligator.html).\n   * @param hex 64-byte output of a hash function\n   */\n  static hashToCurve(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHash', hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new RistPoint(R1.add(R2));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHex', hex, 32);\n    const { a, d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n) throw new Error(emsg);\n    return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n  }\n\n  static msm(points: RistPoint[], scalars: bigint[]): RistPoint {\n    const Fn = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);\n    return pippenger(RistPoint, Fn, points, scalars);\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n   */\n  toRawBytes(): Uint8Array {\n    let { ex: x, ey: y, ez: z, et: t } = this.ep;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const u1 = mod(mod(z + y) * mod(z - y)); // 1\n    const u2 = mod(x * y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * t); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(t * zInv, P)) {\n      let _x = mod(y * SQRT_M1);\n      let _y = mod(x * SQRT_M1);\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(x * zInv, P)) y = mod(-y); // 9\n    let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return numberToBytesLE(s, 32); // 11\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  /**\n   * Compares two Ristretto points.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n   */\n  equals(other: RistPoint): boolean {\n    aristp(other);\n    const { ex: X1, ey: Y1 } = this.ep;\n    const { ex: X2, ey: Y2 } = other.ep;\n    const mod = ed25519.CURVE.Fp.create;\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  add(other: RistPoint): RistPoint {\n    aristp(other);\n    return new RistPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other: RistPoint): RistPoint {\n    aristp(other);\n    return new RistPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): RistPoint {\n    return new RistPoint(this.ep.double());\n  }\n\n  negate(): RistPoint {\n    return new RistPoint(this.ep.negate());\n  }\n}\n\n/**\n * Wrapper over Edwards Point for ristretto255 from\n * [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nexport const RistrettoPoint: typeof RistPoint = /* @__PURE__ */ (() => {\n  if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n  if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n  return RistPoint;\n})();\n\n/**\n * hash-to-curve for ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B).\n */\nexport const hashToRistretto255 = (msg: Uint8Array, options: htfBasicOpts): RistPoint => {\n  const d = options.DST;\n  const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n  const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n  const P = RistPoint.hashToCurve(uniform_bytes);\n  return P;\n};\n/** @deprecated */\nexport const hash_to_ristretto255: (msg: Uint8Array, options: htfBasicOpts) => RistPoint =\n  hashToRistretto255; // legacy\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is boolean. */\nexport function abool(b: boolean): void {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/**\n * Asserts something is hash\n * TODO: remove\n * @deprecated\n */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport type IHash = {\n  (data: string | Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// Used in micro\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\n\n// Used in micro, ff1\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\n// TODO: remove\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async (): Promise<void> => {};\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n// TODO: remove\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: string | Uint8Array): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  else if (isBytes(data)) data = copyBytes(data);\n  else throw new Error('Uint8Array expected, got ' + typeof data);\n  return data;\n}\n\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nexport function overlapBytes(a: Uint8Array, b: Uint8Array): boolean {\n  return (\n    a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n    b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n  );\n}\n\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input: Uint8Array, output: Uint8Array): void {\n  // This is very cursed. It works somehow, but I'm completely unsure,\n  // reasoning about overlapping aligned windows is very hard.\n  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n    throw new Error('complex overlap of input and output is not supported');\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Used in ARX only\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts: T2\n): T1 & T2 {\n  if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Compares 2 uint8array-s in kinda constant time. */\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// TODO: remove\n/** For runtime check if class implements interface. */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: string | Uint8Array): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\n\n/** Sync cipher: takes byte array and returns byte array. */\nexport type Cipher = {\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\n/** Async cipher e.g. from built-in WebCrypto. */\nexport type AsyncCipher = {\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\n/** Cipher with `output` argument which can optimize by doing 1 less allocation. */\nexport type CipherWithOutput = Cipher & {\n  encrypt(plaintext: Uint8Array, output?: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array, output?: Uint8Array): Uint8Array;\n};\n\n/**\n * Params are outside of return type, so it is accessible before calling constructor.\n * If function support multiple nonceLength's, we return the best one.\n */\nexport type CipherParams = {\n  blockSize: number;\n  nonceLength?: number;\n  tagLength?: number;\n  varSizeNonce?: boolean;\n};\n/** ARX cipher, like salsa or chacha. */\nexport type ARXCipher = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  AAD?: Uint8Array\n) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n};\nexport type CipherCons<T extends any[]> = (key: Uint8Array, ...args: T) => Cipher;\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = <C extends CipherCons<any>, P extends CipherParams>(\n  params: P,\n  constructor: C\n): C & P => {\n  function wrappedCipher(key: Uint8Array, ...args: any[]): CipherWithOutput {\n    // Validate key\n    abytes(key);\n\n    // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n    if (!isLE) throw new Error('Non little-endian hardware is not yet supported');\n\n    // Validate nonce if nonceLength is present\n    if (params.nonceLength !== undefined) {\n      const nonce = args[0];\n      if (!nonce) throw new Error('nonce / iv required');\n      if (params.varSizeNonce) abytes(nonce);\n      else abytes(nonce, params.nonceLength);\n    }\n\n    // Validate AAD if tagLength present\n    const tagl = params.tagLength;\n    if (tagl && args[1] !== undefined) {\n      abytes(args[1]);\n    }\n\n    const cipher = constructor(key, ...args);\n    const checkOutput = (fnLength: number, output?: Uint8Array) => {\n      if (output !== undefined) {\n        if (fnLength !== 2) throw new Error('cipher output not supported');\n        abytes(output);\n      }\n    };\n    // Create wrapped cipher with validation and single-use encryption\n    let called = false;\n    const wrCipher = {\n      encrypt(data: Uint8Array, output?: Uint8Array) {\n        if (called) throw new Error('cannot encrypt() twice with same key + nonce');\n        called = true;\n        abytes(data);\n        checkOutput(cipher.encrypt.length, output);\n        return (cipher as CipherWithOutput).encrypt(data, output);\n      },\n      decrypt(data: Uint8Array, output?: Uint8Array) {\n        abytes(data);\n        if (tagl && data.length < tagl)\n          throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);\n        checkOutput(cipher.decrypt.length, output);\n        return (cipher as CipherWithOutput).decrypt(data, output);\n      },\n    };\n\n    return wrCipher;\n  }\n\n  Object.assign(wrappedCipher, params);\n  return wrappedCipher as C & P;\n};\n\n/** Represents salsa / chacha stream. */\nexport type XorStream = (\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  output?: Uint8Array,\n  counter?: number\n) => Uint8Array;\n\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nexport function getOutput(\n  expectedLength: number,\n  out?: Uint8Array,\n  onlyAligned = true\n): Uint8Array {\n  if (out === undefined) return new Uint8Array(expectedLength);\n  if (out.length !== expectedLength)\n    throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);\n  if (onlyAligned && !isAligned32(out)) throw new Error('invalid output, must be aligned');\n  return out;\n}\n\n/** Polyfill for Safari 14. */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\nexport function u64Lengths(dataLength: number, aadLength: number, isLE: boolean): Uint8Array {\n  abool(isLE);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(aadLength), isLE);\n  setBigUint64(view, 8, BigInt(dataLength), isLE);\n  return num;\n}\n\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes: Uint8Array): boolean {\n  return bytes.byteOffset % 4 === 0;\n}\n\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n", "/**\n * GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n *\n * Implemented in terms of GHash with conversion function for keys\n * GCM GHASH from\n * [NIST SP800-38d](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf),\n * SIV from\n * [RFC 8452](https://datatracker.ietf.org/doc/html/rfc8452).\n *\n * GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n * POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\n *\n * @module\n */\n// prettier-ignore\nimport {\n  abytes, aexists, aoutput,\n  clean, copyBytes, createView, Hash, type Input, toBytes, u32,\n} from './utils.ts';\n\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = u32(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0: number, s1: number, s2: number, s3: number) => {\n  const hiBit = s3 & 1;\n  return {\n    s3: (s2 << 31) | (s3 >>> 1),\n    s2: (s1 << 31) | (s2 >>> 1),\n    s1: (s0 << 31) | (s1 >>> 1),\n    s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n  };\n};\n\nconst swapLE = (n: number) =>\n  (((n >>> 0) & 0xff) << 24) |\n  (((n >>> 8) & 0xff) << 16) |\n  (((n >>> 16) & 0xff) << 8) |\n  ((n >>> 24) & 0xff) |\n  0;\n\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nexport function _toGHASHKey(k: Uint8Array): Uint8Array {\n  k.reverse();\n  const hiBit = k[15] & 1;\n  // k >>= 1\n  let carry = 0;\n  for (let i = 0; i < k.length; i++) {\n    const t = k[i];\n    k[i] = (t >>> 1) | carry;\n    carry = (t & 1) << 7;\n  }\n  k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n  return k;\n}\n\ntype Value = { s0: number; s1: number; s2: number; s3: number };\n\nconst estimateWindow = (bytes: number) => {\n  if (bytes > 64 * 1024) return 8;\n  if (bytes > 1024) return 4;\n  return 2;\n};\n\nclass GHASH implements Hash<GHASH> {\n  readonly blockLen = BLOCK_SIZE;\n  readonly outputLen = BLOCK_SIZE;\n  protected s0 = 0;\n  protected s1 = 0;\n  protected s2 = 0;\n  protected s3 = 0;\n  protected finished = false;\n  protected t: Value[];\n  private W: number;\n  private windowSize: number;\n  // We select bits per window adaptively based on expectedLength\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    abytes(key, 16);\n    const kView = createView(key);\n    let k0 = kView.getUint32(0, false);\n    let k1 = kView.getUint32(4, false);\n    let k2 = kView.getUint32(8, false);\n    let k3 = kView.getUint32(12, false);\n    // generate table of doubled keys (half of montgomery ladder)\n    const doubles: Value[] = [];\n    for (let i = 0; i < 128; i++) {\n      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n    }\n    const W = estimateWindow(expectedLength || 1024);\n    if (![1, 2, 4, 8].includes(W))\n      throw new Error('ghash: invalid window size, expected 2, 4 or 8');\n    this.W = W;\n    const bits = 128; // always 128 bits;\n    const windows = bits / W;\n    const windowSize = (this.windowSize = 2 ** W);\n    const items: Value[] = [];\n    // Create precompute table for window of W bits\n    for (let w = 0; w < windows; w++) {\n      // truth table: 00, 01, 10, 11\n      for (let byte = 0; byte < windowSize; byte++) {\n        // prettier-ignore\n        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n        for (let j = 0; j < W; j++) {\n          const bit = (byte >>> (W - j - 1)) & 1;\n          if (!bit) continue;\n          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n          (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n        }\n        items.push({ s0, s1, s2, s3 });\n      }\n    }\n    this.t = items;\n  }\n  protected _updateBlock(s0: number, s1: number, s2: number, s3: number) {\n    (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n    const { W, t, windowSize } = this;\n    // prettier-ignore\n    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n    const mask = (1 << W) - 1; // 2**W will kill performance.\n    let w = 0;\n    for (const num of [s0, s1, s2, s3]) {\n      for (let bytePos = 0; bytePos < 4; bytePos++) {\n        const byte = (num >>> (8 * bytePos)) & 0xff;\n        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n          const bit = (byte >>> (W * bitPos)) & mask;\n          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n          (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n          w += 1;\n        }\n      }\n    }\n    this.s0 = o0;\n    this.s1 = o1;\n    this.s2 = o2;\n    this.s3 = o3;\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const b32 = u32(data);\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    const left = data.length % BLOCK_SIZE;\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n      clean(ZEROS32); // clean tmp buffer\n    }\n    return this;\n  }\n  destroy() {\n    const { t } = this;\n    // clean precompute table\n    for (const elm of t) {\n      (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n    }\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out;\n  }\n  digest(): Uint8Array {\n    const res = new Uint8Array(BLOCK_SIZE);\n    this.digestInto(res);\n    this.destroy();\n    return res;\n  }\n}\n\nclass Polyval extends GHASH {\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    abytes(key);\n    const ghKey = _toGHASHKey(copyBytes(key));\n    super(ghKey, expectedLength);\n    clean(ghKey);\n  }\n  update(data: Input): this {\n    data = toBytes(data);\n    aexists(this);\n    const b32 = u32(data);\n    const left = data.length % BLOCK_SIZE;\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(\n        swapLE(b32[i * 4 + 3]),\n        swapLE(b32[i * 4 + 2]),\n        swapLE(b32[i * 4 + 1]),\n        swapLE(b32[i * 4 + 0])\n      );\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(\n        swapLE(ZEROS32[3]),\n        swapLE(ZEROS32[2]),\n        swapLE(ZEROS32[1]),\n        swapLE(ZEROS32[0])\n      );\n      clean(ZEROS32);\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // tmp ugly hack\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out.reverse();\n  }\n}\n\nexport type CHashPV = ReturnType<typeof wrapConstructorWithKey>;\nfunction wrapConstructorWithKey<H extends Hash<H>>(\n  hashCons: (key: Input, expectedLength?: number) => Hash<H>\n): {\n  (msg: Input, key: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(key: Input, expectedLength?: number): Hash<H>;\n} {\n  const hashC = (msg: Input, key: Input): Uint8Array =>\n    hashCons(key, msg.length).update(toBytes(msg)).digest();\n  const tmp = hashCons(new Uint8Array(16), 0);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Input, expectedLength?: number) => hashCons(key, expectedLength);\n  return hashC;\n}\n\n/** GHash MAC for AES-GCM. */\nexport const ghash: CHashPV = wrapConstructorWithKey(\n  (key, expectedLength) => new GHASH(key, expectedLength)\n);\n\n/** Polyval MAC for AES-SIV. */\nexport const polyval: CHashPV = wrapConstructorWithKey(\n  (key, expectedLength) => new Polyval(key, expectedLength)\n);\n", "/**\n * [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * a.k.a. Advanced Encryption Standard\n * is a variant of Rijndael block cipher, standardized by NIST in 2001.\n * We provide the fastest available pure JS implementation.\n *\n * Data is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n * 1. **S-box**, table substitution\n * 2. **Shift rows**, cyclic shift left of all rows of data array\n * 3. **Mix columns**, multiplying every column by fixed polynomial\n * 4. **Add round key**, round_key xor i-th column of array\n *\n * Check out [FIPS-197](https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf)\n * and [original proposal](https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf)\n * @module\n */\nimport { ghash, polyval } from './_polyval.ts';\n// prettier-ignore\nimport {\n  abytes, clean, complexOverlapBytes, concatBytes,\n  copyBytes, createView, equalBytes, getOutput, isAligned32, overlapBytes,\n  setBigUint64, u32, u64Lengths, u8, wrapCipher,\n  type Cipher, type CipherWithOutput,\n} from './utils.ts';\n\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = /* @__PURE__ */ new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n\n// TODO: remove multiplication, binary ops only\nfunction mul2(n: number) {\n  return (n << 1) ^ (POLY & -(n >> 7));\n}\n\nfunction mul(a: number, b: number) {\n  let res = 0;\n  for (; b > 0; b >>= 1) {\n    // Montgomery ladder\n    res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n    a = mul2(a); // a = 2*a\n  }\n  return res;\n}\n\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst sbox = /* @__PURE__ */ (() => {\n  const t = new Uint8Array(256);\n  for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x)) t[i] = x;\n  const box = new Uint8Array(256);\n  box[0] = 0x63; // first elm\n  for (let i = 0; i < 255; i++) {\n    let x = t[255 - i];\n    x |= x << 8;\n    box[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n  }\n  clean(t);\n  return box;\n})();\n\n// Inverted S-box\nconst invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));\n\n// Rotate u32 by 8\nconst rotr32_8 = (n: number) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n: number) => (n << 8) | (n >>> 24);\n// The byte swap operation for uint32 (LE<->BE)\nconst byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox: Uint8Array, fn: (n: number) => number) {\n  if (sbox.length !== 256) throw new Error('Wrong sbox length');\n  const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n  const T1 = T0.map(rotl32_8);\n  const T2 = T1.map(rotl32_8);\n  const T3 = T2.map(rotl32_8);\n  const T01 = new Uint32Array(256 * 256);\n  const T23 = new Uint32Array(256 * 256);\n  const sbox2 = new Uint16Array(256 * 256);\n  for (let i = 0; i < 256; i++) {\n    for (let j = 0; j < 256; j++) {\n      const idx = i * 256 + j;\n      T01[idx] = T0[i] ^ T1[j];\n      T23[idx] = T2[i] ^ T3[j];\n      sbox2[idx] = (sbox[i] << 8) | sbox[j];\n    }\n  }\n  return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\n\nconst tableEncoding = /* @__PURE__ */ genTtable(\n  sbox,\n  (s: number) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2)\n);\nconst tableDecoding = /* @__PURE__ */ genTtable(\n  invSbox,\n  (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14)\n);\n\nconst xPowers = /* @__PURE__ */ (() => {\n  const p = new Uint8Array(16);\n  for (let i = 0, x = 1; i < 16; i++, x = mul2(x)) p[i] = x;\n  return p;\n})();\n\n/** Key expansion used in CTR. */\nfunction expandKeyLE(key: Uint8Array): Uint32Array {\n  abytes(key);\n  const len = key.length;\n  if (![16, 24, 32].includes(len))\n    throw new Error('aes: invalid key size, should be 16, 24 or 32, got ' + len);\n  const { sbox2 } = tableEncoding;\n  const toClean = [];\n  if (!isAligned32(key)) toClean.push((key = copyBytes(key)));\n  const k32 = u32(key);\n  const Nk = k32.length;\n  const subByte = (n: number) => applySbox(sbox2, n, n, n, n);\n  const xk = new Uint32Array(len + 28); // expanded key\n  xk.set(k32);\n  // 4.3.1 Key expansion\n  for (let i = Nk; i < xk.length; i++) {\n    let t = xk[i - 1];\n    if (i % Nk === 0) t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];\n    else if (Nk > 6 && i % Nk === 4) t = subByte(t);\n    xk[i] = xk[i - Nk] ^ t;\n  }\n  clean(...toClean);\n  return xk;\n}\n\nfunction expandKeyDecLE(key: Uint8Array): Uint32Array {\n  const encKey = expandKeyLE(key);\n  const xk = encKey.slice();\n  const Nk = encKey.length;\n  const { sbox2 } = tableEncoding;\n  const { T0, T1, T2, T3 } = tableDecoding;\n  // Inverse key by chunks of 4 (rounds)\n  for (let i = 0; i < Nk; i += 4) {\n    for (let j = 0; j < 4; j++) xk[i + j] = encKey[Nk - i - 4 + j];\n  }\n  clean(encKey);\n  // apply InvMixColumn except first & last round\n  for (let i = 4; i < Nk - 4; i++) {\n    const x = xk[i];\n    const w = applySbox(sbox2, x, x, x, x);\n    xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n  }\n  return xk;\n}\n\n// Apply tables\nfunction apply0123(\n  T01: Uint32Array,\n  T23: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n) {\n  return (\n    T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n    T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]\n  );\n}\n\nfunction applySbox(sbox2: Uint16Array, s0: number, s1: number, s2: number, s3: number) {\n  return (\n    sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n    (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16)\n  );\n}\n\nfunction encrypt(\n  xk: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n): { s0: number; s1: number; s2: number; s3: number } {\n  const { sbox2, T01, T23 } = tableEncoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // last round (without mixcolumns, so using SBOX2 table)\n  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\n// Can't be merged with encrypt: arg positions for apply0123 / applySbox are different\nfunction decrypt(\n  xk: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n): {\n  s0: number;\n  s1: number;\n  s2: number;\n  s3: number;\n} {\n  const { sbox2, T01, T23 } = tableDecoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // Last round\n  const t0: number = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n  const t1: number = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n  const t2: number = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n  const t3: number = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\n// TODO: investigate merging with ctr32\nfunction ctrCounter(\n  xk: Uint32Array,\n  nonce: Uint8Array,\n  src: Uint8Array,\n  dst?: Uint8Array\n): Uint8Array {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  const srcLen = src.length;\n  dst = getOutput(srcLen, dst);\n  complexOverlapBytes(src, dst);\n  const ctr = nonce;\n  const c32 = u32(ctr);\n  // Fill block (empty, ctr=0)\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    // Full 128 bit counter with wrap around\n    let carry = 1;\n    for (let i = ctr.length - 1; i >= 0; i--) {\n      carry = (carry + (ctr[i] & 0xff)) | 0;\n      ctr[i] = carry & 0xff;\n      carry >>>= 8;\n    }\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than block)\n  // It's possible to handle > u32 fast, but is it worth it?\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(\n  xk: Uint32Array,\n  isLE: boolean,\n  nonce: Uint8Array,\n  src: Uint8Array,\n  dst?: Uint8Array\n): Uint8Array {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  dst = getOutput(src.length, dst);\n  const ctr = nonce; // write new value to nonce, so it can be re-used\n  const c32 = u32(ctr);\n  const view = createView(ctr);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  const ctrPos = isLE ? 0 : 12;\n  const srcLen = src.length;\n  // Fill block (empty, ctr=0)\n  let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n    view.setUint32(ctrPos, ctrNum, isLE);\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than a block)\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexport const ctr: ((key: Uint8Array, nonce: Uint8Array) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aesctr(key: Uint8Array, nonce: Uint8Array): CipherWithOutput {\n    function processCtr(buf: Uint8Array, dst?: Uint8Array) {\n      abytes(buf);\n      if (dst !== undefined) {\n        abytes(dst);\n        if (!isAligned32(dst)) throw new Error('unaligned destination');\n      }\n      const xk = expandKeyLE(key);\n      const n = copyBytes(nonce); // align + avoid changing\n      const toClean = [xk, n];\n      if (!isAligned32(buf)) toClean.push((buf = copyBytes(buf)));\n      const out = ctrCounter(xk, n, buf, dst);\n      clean(...toClean);\n      return out;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCtr(plaintext, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCtr(ciphertext, dst),\n    };\n  }\n);\n\nfunction validateBlockDecrypt(data: Uint8Array) {\n  abytes(data);\n  if (data.length % BLOCK_SIZE !== 0) {\n    throw new Error(\n      'aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size ' + BLOCK_SIZE\n    );\n  }\n}\n\nfunction validateBlockEncrypt(plaintext: Uint8Array, pcks5: boolean, dst?: Uint8Array) {\n  abytes(plaintext);\n  let outLen = plaintext.length;\n  const remaining = outLen % BLOCK_SIZE;\n  if (!pcks5 && remaining !== 0)\n    throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n  if (!isAligned32(plaintext)) plaintext = copyBytes(plaintext);\n  const b = u32(plaintext);\n  if (pcks5) {\n    let left = BLOCK_SIZE - remaining;\n    if (!left) left = BLOCK_SIZE; // if no bytes left, create empty padding block\n    outLen = outLen + left;\n  }\n  dst = getOutput(outLen, dst);\n  complexOverlapBytes(plaintext, dst);\n  const o = u32(dst);\n  return { b, o, out: dst };\n}\n\nfunction validatePCKS(data: Uint8Array, pcks5: boolean) {\n  if (!pcks5) return data;\n  const len = data.length;\n  if (!len) throw new Error('aes/pcks5: empty ciphertext not allowed');\n  const lastByte = data[len - 1];\n  if (lastByte <= 0 || lastByte > 16) throw new Error('aes/pcks5: wrong padding');\n  const out = data.subarray(0, -lastByte);\n  for (let i = 0; i < lastByte; i++)\n    if (data[len - i - 1] !== lastByte) throw new Error('aes/pcks5: wrong padding');\n  return out;\n}\n\nfunction padPCKS(left: Uint8Array) {\n  const tmp = new Uint8Array(16);\n  const tmp32 = u32(tmp);\n  tmp.set(left);\n  const paddingByte = BLOCK_SIZE - left.length;\n  for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++) tmp[i] = paddingByte;\n  return tmp32;\n}\n\n/** Options for ECB and CBC. */\nexport type BlockOpts = { disablePadding?: boolean };\n\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexport const ecb: ((key: Uint8Array, opts?: BlockOpts) => CipherWithOutput) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16 },\n  function aesecb(key: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt(plaintext: Uint8Array, dst?: Uint8Array) {\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        const xk = expandKeyLE(key);\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(xk);\n        return _out;\n      },\n      decrypt(ciphertext: Uint8Array, dst?: Uint8Array) {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        dst = getOutput(ciphertext.length, dst);\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        complexOverlapBytes(ciphertext, dst);\n        const b = u32(ciphertext);\n        const o = u32(dst);\n        for (let i = 0; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(...toClean);\n        return validatePCKS(dst, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CBC: Cipher-Block-Chaining. Key is previous round’s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexport const cbc: ((key: Uint8Array, iv: Uint8Array, opts?: BlockOpts) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aescbc(key: Uint8Array, iv: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt(plaintext: Uint8Array, dst?: Uint8Array) {\n        const xk = expandKeyLE(key);\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        let _iv = iv;\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n        const n32 = u32(_iv);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(...toClean);\n        return _out;\n      },\n      decrypt(ciphertext: Uint8Array, dst?: Uint8Array) {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        let _iv = iv;\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n        const n32 = u32(_iv);\n        dst = getOutput(ciphertext.length, dst);\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        complexOverlapBytes(ciphertext, dst);\n        const b = u32(ciphertext);\n        const o = u32(dst);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        for (let i = 0; i + 4 <= b.length; ) {\n          // prettier-ignore\n          const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n          (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n          const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n          (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n        }\n        clean(...toClean);\n        return validatePCKS(dst, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */\nexport const cfb: ((key: Uint8Array, iv: Uint8Array) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aescfb(key: Uint8Array, iv: Uint8Array): CipherWithOutput {\n    function processCfb(src: Uint8Array, isEncrypt: boolean, dst?: Uint8Array) {\n      abytes(src);\n      const srcLen = src.length;\n      dst = getOutput(srcLen, dst);\n      if (overlapBytes(src, dst)) throw new Error('overlapping src and dst not supported.');\n      const xk = expandKeyLE(key);\n      let _iv = iv;\n      const toClean: (Uint8Array | Uint32Array)[] = [xk];\n      if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n      if (!isAligned32(src)) toClean.push((src = copyBytes(src)));\n      const src32 = u32(src);\n      const dst32 = u32(dst);\n      const next32 = isEncrypt ? dst32 : src32;\n      const n32 = u32(_iv);\n      // prettier-ignore\n      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n      for (let i = 0; i + 4 <= src32.length; ) {\n        const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);\n        dst32[i + 0] = src32[i + 0] ^ e0;\n        dst32[i + 1] = src32[i + 1] ^ e1;\n        dst32[i + 2] = src32[i + 2] ^ e2;\n        dst32[i + 3] = src32[i + 3] ^ e3;\n        (s0 = next32[i++]), (s1 = next32[i++]), (s2 = next32[i++]), (s3 = next32[i++]);\n      }\n      // leftovers (less than block)\n      const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n      if (start < srcLen) {\n        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n        const buf = u8(new Uint32Array([s0, s1, s2, s3]));\n        for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n        clean(buf);\n      }\n      clean(...toClean);\n      return dst;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCfb(plaintext, true, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCfb(ciphertext, false, dst),\n    };\n  }\n);\n\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(\n  fn: typeof ghash,\n  isLE: boolean,\n  key: Uint8Array,\n  data: Uint8Array,\n  AAD?: Uint8Array\n) {\n  const aadLength = AAD ? AAD.length : 0;\n  const h = fn.create(key, data.length + aadLength);\n  if (AAD) h.update(AAD);\n  const num = u64Lengths(8 * data.length, 8 * aadLength, isLE);\n  h.update(data);\n  h.update(num);\n  const res = h.digest();\n  clean(num);\n  return res;\n}\n\n/**\n * GCM: Galois/Counter Mode.\n * Modern, parallel version of CTR, with MAC.\n * Be careful: MACs can be forged.\n * Unsafe to use random nonces under the same key, due to collision chance.\n * As for nonce size, prefer 12-byte, instead of 8-byte.\n */\nexport const gcm: ((key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array) => Cipher) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n  varSizeNonce: true;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true },\n  function aesgcm(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    // NIST 800-38d doesn't enforce minimum nonce length.\n    // We enforce 8 bytes for compat with openssl.\n    // 12 bytes are recommended. More than 12 bytes would be converted into 12.\n    if (nonce.length < 8) throw new Error('aes/gcm: invalid nonce length');\n    const tagLength = 16;\n    function _computeTag(authKey: Uint8Array, tagMask: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(ghash, false, authKey, data, AAD);\n      for (let i = 0; i < tagMask.length; i++) tag[i] ^= tagMask[i];\n      return tag;\n    }\n    function deriveKeys() {\n      const xk = expandKeyLE(key);\n      const authKey = EMPTY_BLOCK.slice();\n      const counter = EMPTY_BLOCK.slice();\n      ctr32(xk, false, counter, counter, authKey);\n      // NIST 800-38d, page 15: different behavior for 96-bit and non-96-bit nonces\n      if (nonce.length === 12) {\n        counter.set(nonce);\n      } else {\n        const nonceLen = EMPTY_BLOCK.slice();\n        const view = createView(nonceLen);\n        setBigUint64(view, 8, BigInt(nonce.length * 8), false);\n        // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n        const g = ghash.create(authKey).update(nonce).update(nonceLen);\n        g.digestInto(counter); // digestInto doesn't trigger '.destroy'\n        g.destroy();\n      }\n      const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n      return { xk, authKey, counter, tagMask };\n    }\n    return {\n      encrypt(plaintext: Uint8Array) {\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const out = new Uint8Array(plaintext.length + tagLength);\n        const toClean: (Uint8Array | Uint32Array)[] = [xk, authKey, counter, tagMask];\n        if (!isAligned32(plaintext)) toClean.push((plaintext = copyBytes(plaintext)));\n        ctr32(xk, false, counter, plaintext, out.subarray(0, plaintext.length));\n        const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n        toClean.push(tag);\n        out.set(tag, plaintext.length);\n        clean(...toClean);\n        return out;\n      },\n      decrypt(ciphertext: Uint8Array) {\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const toClean: (Uint8Array | Uint32Array)[] = [xk, authKey, tagMask, counter];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = _computeTag(authKey, tagMask, data);\n        toClean.push(tag);\n        if (!equalBytes(tag, passedTag)) throw new Error('aes/gcm: invalid ghash tag');\n        const out = ctr32(xk, false, counter, data);\n        clean(...toClean);\n        return out;\n      },\n    };\n  }\n);\n\nconst limit = (name: string, min: number, max: number) => (value: number) => {\n  if (!Number.isSafeInteger(value) || min > value || value > max) {\n    const minmax = '[' + min + '..' + max + ']';\n    throw new Error('' + name + ': expected value in range ' + minmax + ', got ' + value);\n  }\n};\n\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexport const gcmsiv: ((key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array) => Cipher) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n  varSizeNonce: true;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true },\n  function aessiv(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    abytes(key, 16, 24, 32);\n    NONCE_LIMIT(nonce.length);\n    if (AAD !== undefined) AAD_LIMIT(AAD.length);\n    function deriveKeys() {\n      const xk = expandKeyLE(key);\n      const encKey = new Uint8Array(key.length);\n      const authKey = new Uint8Array(16);\n      const toClean: (Uint8Array | Uint32Array)[] = [xk, encKey];\n      let _nonce = nonce;\n      if (!isAligned32(_nonce)) toClean.push((_nonce = copyBytes(_nonce)));\n      const n32 = u32(_nonce);\n      // prettier-ignore\n      let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n      let counter = 0;\n      for (const derivedKey of [authKey, encKey].map(u32)) {\n        const d32 = u32(derivedKey);\n        for (let i = 0; i < d32.length; i += 2) {\n          // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n          const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n          d32[i + 0] = o0;\n          d32[i + 1] = o1;\n          s0 = ++counter; // increment counter inside state\n        }\n      }\n      const res = { authKey, encKey: expandKeyLE(encKey) };\n      // Cleanup\n      clean(...toClean);\n      return res;\n    }\n    function _computeTag(encKey: Uint32Array, authKey: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(polyval, true, authKey, data, AAD);\n      // Compute the expected tag by XORing S_s and the nonce, clearing the\n      // most significant bit of the last byte and encrypting with the\n      // message-encryption key.\n      for (let i = 0; i < 12; i++) tag[i] ^= nonce[i];\n      tag[15] &= 0x7f; // Clear the highest bit\n      // encrypt tag as block\n      const t32 = u32(tag);\n      // prettier-ignore\n      let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n      ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n      (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n      return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey: Uint32Array, tag: Uint8Array, input: Uint8Array) {\n      let block = copyBytes(tag);\n      block[15] |= 0x80; // Force highest bit\n      const res = ctr32(encKey, true, block, input);\n      // Cleanup\n      clean(block);\n      return res;\n    }\n    return {\n      encrypt(plaintext: Uint8Array) {\n        PLAIN_LIMIT(plaintext.length);\n        const { encKey, authKey } = deriveKeys();\n        const tag = _computeTag(encKey, authKey, plaintext);\n        const toClean: (Uint8Array | Uint32Array)[] = [encKey, authKey, tag];\n        if (!isAligned32(plaintext)) toClean.push((plaintext = copyBytes(plaintext)));\n        const out = new Uint8Array(plaintext.length + tagLength);\n        out.set(tag, plaintext.length);\n        out.set(processSiv(encKey, tag, plaintext));\n        // Cleanup\n        clean(...toClean);\n        return out;\n      },\n      decrypt(ciphertext: Uint8Array) {\n        CIPHER_LIMIT(ciphertext.length);\n        const tag = ciphertext.subarray(-tagLength);\n        const { encKey, authKey } = deriveKeys();\n        const toClean: (Uint8Array | Uint32Array)[] = [encKey, authKey];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n        const expectedTag = _computeTag(encKey, authKey, plaintext);\n        toClean.push(expectedTag);\n        if (!equalBytes(tag, expectedTag)) {\n          clean(...toClean);\n          throw new Error('invalid polyval tag');\n        }\n        // Cleanup\n        clean(...toClean);\n        return plaintext;\n      },\n    };\n  }\n);\n\n/**\n * AES-GCM-SIV, not AES-SIV.\n * This is legace name, use `gcmsiv` export instead.\n * @deprecated\n */\nexport const siv: typeof gcmsiv = gcmsiv;\n\nfunction isBytes32(a: unknown): a is Uint32Array {\n  return (\n    a instanceof Uint32Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint32Array')\n  );\n}\n\nfunction encryptBlock(xk: Uint32Array, block: Uint8Array): Uint8Array {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_encryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\nfunction decryptBlock(xk: Uint32Array, block: Uint8Array): Uint8Array {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_decryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\n/**\n * AES-W (base for AESKW/AESKWP).\n * Specs: [SP800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf),\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [RFC 5649](https://datatracker.ietf.org/doc/rfc5649/).\n */\nconst AESW = {\n  /*\n  High-level pseudocode:\n  ```\n  A: u64 = IV\n  out = []\n  for (let i=0, ctr = 0; i<6; i++) {\n    for (const chunk of chunks(plaintext, 8)) {\n      A ^= swapEndianess(ctr++)\n      [A, res] = chunks(encrypt(A || chunk), 8);\n      out ||= res\n    }\n  }\n  out = A || out\n  ```\n  Decrypt is the same, but reversed.\n  */\n  encrypt(kek: Uint8Array, out: Uint8Array) {\n    // Size is limited to 4GB, otherwise ctr will overflow and we'll need to switch to bigints.\n    // If you need it larger, open an issue.\n    if (out.length >= 2 ** 32) throw new Error('plaintext should be less than 4gb');\n    const xk = expandKeyLE(kek);\n    if (out.length === 16) encryptBlock(xk, out);\n    else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0], a1 = o32[1]; // A\n      for (let j = 0, ctr = 1; j < 6; j++) {\n        for (let pos = 2; pos < o32.length; pos += 2, ctr++) {\n          const { s0, s1, s2, s3 } = encrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          // A = MSB(64, B) ^ t where t = (n*j)+i\n          (a0 = s0), (a1 = s1 ^ byteSwap(ctr)), (o32[pos] = s2), (o32[pos + 1] = s3);\n        }\n      }\n      (o32[0] = a0), (o32[1] = a1); // out = A || out\n    }\n    xk.fill(0);\n  },\n  decrypt(kek: Uint8Array, out: Uint8Array) {\n    if (out.length - 8 >= 2 ** 32) throw new Error('ciphertext should be less than 4gb');\n    const xk = expandKeyDecLE(kek);\n    const chunks = out.length / 8 - 1; // first chunk is IV\n    if (chunks === 1) decryptBlock(xk, out);\n    else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0], a1 = o32[1]; // A\n      for (let j = 0, ctr = chunks * 6; j < 6; j++) {\n        for (let pos = chunks * 2; pos >= 1; pos -= 2, ctr--) {\n          a1 ^= byteSwap(ctr);\n          const { s0, s1, s2, s3 } = decrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          (a0 = s0), (a1 = s1), (o32[pos] = s2), (o32[pos + 1] = s3);\n        }\n      }\n      (o32[0] = a0), (o32[1] = a1);\n    }\n    xk.fill(0);\n  },\n};\n\nconst AESKW_IV = /* @__PURE__ */ new Uint8Array(8).fill(0xa6); // A6A6A6A6A6A6A6A6\n\n/**\n * AES-KW (key-wrap). Injects static IV into plaintext, adds counter, encrypts 6 times.\n * Reduces block size from 16 to 8 bytes.\n * For padded version, use aeskwp.\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [NIST.SP.800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf).\n */\nexport const aeskw: ((kek: Uint8Array) => Cipher) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 8 },\n  (kek: Uint8Array): Cipher => ({\n    encrypt(plaintext: Uint8Array) {\n      if (!plaintext.length || plaintext.length % 8 !== 0)\n        throw new Error('invalid plaintext length');\n      if (plaintext.length === 8)\n        throw new Error('8-byte keys not allowed in AESKW, use AESKWP instead');\n      const out = concatBytes(AESKW_IV, plaintext);\n      AESW.encrypt(kek, out);\n      return out;\n    },\n    decrypt(ciphertext: Uint8Array) {\n      // ciphertext must be at least 24 bytes and a multiple of 8 bytes\n      // 24 because should have at least two block (1 iv + 2).\n      // Replace with 16 to enable '8-byte keys'\n      if (ciphertext.length % 8 !== 0 || ciphertext.length < 3 * 8)\n        throw new Error('invalid ciphertext length');\n      const out = copyBytes(ciphertext);\n      AESW.decrypt(kek, out);\n      if (!equalBytes(out.subarray(0, 8), AESKW_IV)) throw new Error('integrity check failed');\n      out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n      return out.subarray(8);\n    },\n  })\n);\n\n/*\nWe don't support 8-byte keys. The rabbit hole:\n\n- Wycheproof says: \"NIST SP 800-38F does not define the wrapping of 8 byte keys.\n  RFC 3394 Section 2  on the other hand specifies that 8 byte keys are wrapped\n  by directly encrypting one block with AES.\"\n    - https://github.com/C2SP/wycheproof/blob/master/doc/key_wrap.md\n    - \"RFC 3394 specifies in Section 2, that the input for the key wrap\n      algorithm must be at least two blocks and otherwise the constant\n      field and key are simply encrypted with ECB as a single block\"\n- What RFC 3394 actually says (in Section 2):\n    - \"Before being wrapped, the key data is parsed into n blocks of 64 bits.\n      The only restriction the key wrap algorithm places on n is that n be\n      at least two\"\n    - \"For key data with length less than or equal to 64 bits, the constant\n      field used in this specification and the key data form a single\n      128-bit codebook input making this key wrap unnecessary.\"\n- Which means \"assert(n >= 2)\" and \"use something else for 8 byte keys\"\n- NIST SP800-38F actually prohibits 8-byte in \"5.3.1 Mandatory Limits\".\n  It states that plaintext for KW should be \"2 to 2^54 -1 semiblocks\".\n- So, where does \"directly encrypt single block with AES\" come from?\n    - Not RFC 3394. Pseudocode of key wrap in 2.2 explicitly uses\n      loop of 6 for any code path\n    - There is a weird W3C spec:\n      https://www.w3.org/TR/2002/REC-xmlenc-core-20021210/Overview.html#kw-aes128\n    - This spec is outdated, as admitted by Wycheproof authors\n    - There is RFC 5649 for padded key wrap, which is padding construction on\n      top of AESKW. In '4.1.2' it says: \"If the padded plaintext contains exactly\n      eight octets, then prepend the AIV as defined in Section 3 above to P[1] and\n      encrypt the resulting 128-bit block using AES in ECB mode [Modes] with key\n      K (the KEK).  In this case, the output is two 64-bit blocks C[0] and C[1]:\"\n    - Browser subtle crypto is actually crashes on wrapping keys less than 16 bytes:\n      `Error: error:1C8000E6:Provider routines::invalid input length] { opensslErrorStack: [ 'error:030000BD:digital envelope routines::update error' ]`\n\nIn the end, seems like a bug in Wycheproof.\nThe 8-byte check can be easily disabled inside of AES_W.\n*/\n\nconst AESKWP_IV = 0xa65959a6; // single u32le value\n\n/**\n * AES-KW, but with padding and allows random keys.\n * Second u32 of IV is used as counter for length.\n * [RFC 5649](https://www.rfc-editor.org/rfc/rfc5649)\n */\nexport const aeskwp: ((kek: Uint8Array) => Cipher) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 8 },\n  (kek: Uint8Array): Cipher => ({\n    encrypt(plaintext: Uint8Array) {\n      if (!plaintext.length) throw new Error('invalid plaintext length');\n      const padded = Math.ceil(plaintext.length / 8) * 8;\n      const out = new Uint8Array(8 + padded);\n      out.set(plaintext, 8);\n      const out32 = u32(out);\n      out32[0] = AESKWP_IV;\n      out32[1] = byteSwap(plaintext.length);\n      AESW.encrypt(kek, out);\n      return out;\n    },\n    decrypt(ciphertext: Uint8Array) {\n      // 16 because should have at least one block\n      if (ciphertext.length < 16) throw new Error('invalid ciphertext length');\n      const out = copyBytes(ciphertext);\n      const o32 = u32(out);\n      AESW.decrypt(kek, out);\n      const len = byteSwap(o32[1]) >>> 0;\n      const padded = Math.ceil(len / 8) * 8;\n      if (o32[0] !== AESKWP_IV || out.length - 8 !== padded)\n        throw new Error('integrity check failed');\n      for (let i = len; i < padded; i++)\n        if (out[8 + i] !== 0) throw new Error('integrity check failed');\n      out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n      return out.subarray(8, 8 + len);\n    },\n  })\n);\n\n/** Unsafe low-level internal methods. May change at any time. */\nexport const unsafe: {\n  expandKeyLE: typeof expandKeyLE;\n  expandKeyDecLE: typeof expandKeyDecLE;\n  encrypt: typeof encrypt;\n  decrypt: typeof decrypt;\n  encryptBlock: typeof encryptBlock;\n  decryptBlock: typeof decryptBlock;\n  ctrCounter: typeof ctrCounter;\n  ctr32: typeof ctr32;\n} = {\n  expandKeyLE,\n  expandKeyDecLE,\n  encrypt,\n  decrypt,\n  encryptBlock,\n  decryptBlock,\n  ctrCounter,\n  ctr32,\n};\n", "import type { Errors, RpcRequest } from '../index.js'\nimport type {\n  Compute,\n  IsNarrowable,\n  IsNever,\n  OneOf,\n  UnionPartialBy,\n} from './internal/types.js'\n\n/** A JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object). */\nexport type RpcResponse<\n  result = unknown,\n  error extends ErrorObject = ErrorObject,\n> = Compute<\n  {\n    id: number\n    jsonrpc: '2.0'\n  } & OneOf<{ result: result } | { error: error }>\n>\n\n/** JSON-RPC error object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#error_object). */\nexport type ErrorObject = {\n  code: number\n  message: string\n  data?: unknown | undefined\n}\n\n/**\n * A type-safe interface to instantiate a JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#response_object).\n *\n * @example\n * ### Instantiating a Response Object\n *\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const response = RpcResponse.from({\n *   id: 0,\n *   jsonrpc: '2.0',\n *   result: '0x69420',\n * })\n * ```\n *\n * @example\n * ### Type-safe Instantiation\n *\n * If you have a JSON-RPC request object, you can use it to strongly-type the response. If a `request` is provided,\n * then the `id` and `jsonrpc` properties will be overridden with the values from the request.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const request = RpcRequest.from({ id: 0, method: 'eth_blockNumber' })\n *\n * const response = RpcResponse.from(\n *   { result: '0x69420' },\n *   { request },\n * )\n * ```\n *\n * @param response - Opaque JSON-RPC response object.\n * @param options - Parsing options.\n * @returns Typed JSON-RPC result, or response object (if `raw` is `true`).\n */\nexport function from<\n  request extends RpcRequest.RpcRequest | undefined = undefined,\n  const response =\n    | (request extends RpcRequest.RpcRequest\n        ? request['_returnType']\n        : RpcResponse)\n    | unknown,\n>(\n  response: from.Response<request, response>,\n  options?: from.Options<request>,\n): Compute<from.ReturnType<response>>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(response: RpcResponse, options: any = {}): RpcResponse {\n  const { request } = options\n  return {\n    ...response,\n    id: response.id ?? request?.id,\n    jsonrpc: response.jsonrpc ?? request.jsonrpc,\n  }\n}\n\nexport declare namespace from {\n  type Response<\n    request extends RpcRequest.RpcRequest | undefined = undefined,\n    response = unknown,\n  > = response &\n    (request extends RpcRequest.RpcRequest\n      ? UnionPartialBy<RpcResponse<request['_returnType']>, 'id' | 'jsonrpc'>\n      : RpcResponse)\n\n  type Options<\n    request extends RpcRequest.RpcRequest | undefined =\n      | RpcRequest.RpcRequest\n      | undefined,\n  > = {\n    request?: request | RpcRequest.RpcRequest | undefined\n  }\n\n  type ReturnType<response> = IsNarrowable<response, RpcResponse> extends true\n    ? RpcResponse\n    : response & Readonly<{ id: number; jsonrpc: '2.0' }>\n}\n\n/**\n * A type-safe interface to parse a JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#response_object), and extract the result.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Create a request store.\n * const store = RpcRequest.createStore()\n *\n * // 2. Get a request object.\n * const request = store.prepare({\n *   method: 'eth_getBlockByNumber',\n *   params: ['0x1', false],\n * })\n *\n * // 3. Send the JSON-RPC request via HTTP.\n * const block = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 4. Parse the JSON-RPC response into a type-safe result. // [!code focus]\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code focus]\n *\n * block // [!code focus]\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::tip\n *\n * If you don't need the return type, you can omit the options entirely.\n *\n * ```ts twoslash\n * // @noErrors\n * import { RpcResponse } from 'ox'\n *\n * const block = await fetch('https://1.rpc.thirdweb.com', {})\n *  .then((response) => response.json())\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code --]\n *  .then(RpcResponse.parse) // [!code ++]\n * ```\n * :::\n *\n * @example\n * ### Raw Mode\n *\n * If `raw` is `true`, the response will be returned as an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n *\n * const response = RpcResponse.parse({}, {\n *   request,\n *   raw: true, // [!code hl]\n * })\n *\n * response.result\n * //       ^?\n *\n *\n * response.error\n * //       ^?\n *\n *\n * ```\n *\n * @param response - Opaque JSON-RPC response object.\n * @param options - Parsing options.\n * @returns Typed JSON-RPC result, or response object (if `raw` is `true`).\n */\nexport function parse<\n  const response extends RpcResponse | unknown,\n  returnType,\n  raw extends boolean = false,\n>(\n  response: response,\n  options: parse.Options<returnType, raw> = {},\n): parse.ReturnType<\n  unknown extends response\n    ? returnType\n    : response extends RpcResponse\n      ? response extends { result: infer result }\n        ? result\n        : never\n      : returnType,\n  raw\n> {\n  const { raw = false } = options\n  const response_ = response as RpcResponse\n  if (raw) return response as never\n  if (response_.error) throw parseError(response_.error)\n  return response_.result as never\n}\n\nexport declare namespace parse {\n  type Options<returnType, raw extends boolean = false> = {\n    /**\n     * JSON-RPC Method that was used to make the request. Used for typing the response.\n     */\n    request?:\n      | {\n          _returnType: returnType\n        }\n      | RpcRequest.RpcRequest\n      | undefined\n    /**\n     * Enables raw mode – responses will return an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n     *\n     * - `true`: a JSON-RPC response object will be returned with `result` and `error` properties.\n     * - `false`: the JSON-RPC response object's `result` property will be returned directly, and JSON-RPC Errors will be thrown.\n     *\n     * @default false\n     */\n    raw?: raw | boolean | undefined\n  }\n\n  type ReturnType<returnType, raw extends boolean = false> = Compute<\n    raw extends true ? RpcResponse<returnType> : returnType\n  >\n\n  type ErrorType =\n    | ParseError\n    | InvalidInputError\n    | ResourceNotFoundError\n    | ResourceUnavailableError\n    | TransactionRejectedError\n    | MethodNotSupportedError\n    | LimitExceededError\n    | VersionNotSupportedError\n    | InvalidRequestError\n    | MethodNotFoundError\n    | InvalidParamsError\n    | InternalError\n    | BaseErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Parses an error into a RPC Error instance.\n *\n * @example\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const error = RpcResponse.parseError({ code: -32000, message: 'unsupported method' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - Error.\n * @returns RPC Error instance.\n */\nexport function parseError<const error extends Error | ErrorObject | unknown>(\n  error: error | Error | ErrorObject,\n): parseError.ReturnType<error> {\n  const error_ = error as Error | ErrorObject\n\n  if (error_ instanceof Error && !('code' in error_))\n    return new InternalError({\n      cause: error_,\n      data: error_,\n      message: error_.message,\n      stack: error_.stack,\n    }) as never\n\n  const { code } = error_\n  if (code === InternalError.code)\n    return new InternalError(error_ as never) as never\n  if (code === InvalidInputError.code)\n    return new InvalidInputError(error_) as never\n  if (code === InvalidParamsError.code)\n    return new InvalidParamsError(error_) as never\n  if (code === InvalidRequestError.code)\n    return new InvalidRequestError(error_) as never\n  if (code === LimitExceededError.code)\n    return new LimitExceededError(error_) as never\n  if (code === MethodNotFoundError.code)\n    return new MethodNotFoundError(error_) as never\n  if (code === MethodNotSupportedError.code)\n    return new MethodNotSupportedError(error_) as never\n  if (code === ParseError.code) return new ParseError(error_) as never\n  if (code === ResourceNotFoundError.code)\n    return new ResourceNotFoundError(error_) as never\n  if (code === ResourceUnavailableError.code)\n    return new ResourceUnavailableError(error_) as never\n  if (code === TransactionRejectedError.code)\n    return new TransactionRejectedError(error_) as never\n  if (code === VersionNotSupportedError.code)\n    return new VersionNotSupportedError(error_) as never\n  return new InternalError({\n    cause: error_ instanceof Error ? error_ : undefined,\n    data: error_,\n    message: error_.message,\n    stack: error_ instanceof Error ? error_.stack : undefined,\n  }) as never\n}\n\nexport declare namespace parseError {\n  type ReturnType<\n    errorObject extends ErrorObject | unknown,\n    //\n    error = errorObject extends ErrorObject\n      ?\n          | (errorObject['code'] extends InternalError['code']\n              ? InternalError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InternalError\n              : never)\n          | (errorObject['code'] extends InvalidInputError['code']\n              ? InvalidInputError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidInputError\n              : never)\n          | (errorObject['code'] extends ResourceNotFoundError['code']\n              ? ResourceNotFoundError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ResourceNotFoundError\n              : never)\n          | (errorObject['code'] extends ResourceUnavailableError['code']\n              ? ResourceUnavailableError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ResourceUnavailableError\n              : never)\n          | (errorObject['code'] extends TransactionRejectedError['code']\n              ? TransactionRejectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? TransactionRejectedError\n              : never)\n          | (errorObject['code'] extends ParseError['code']\n              ? ParseError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ParseError\n              : never)\n          | (errorObject['code'] extends MethodNotSupportedError['code']\n              ? MethodNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? MethodNotSupportedError\n              : never)\n          | (errorObject['code'] extends LimitExceededError['code']\n              ? LimitExceededError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? LimitExceededError\n              : never)\n          | (errorObject['code'] extends VersionNotSupportedError['code']\n              ? VersionNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? VersionNotSupportedError\n              : never)\n          | (errorObject['code'] extends InvalidRequestError['code']\n              ? InvalidRequestError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidRequestError\n              : never)\n          | (errorObject['code'] extends MethodNotFoundError['code']\n              ? MethodNotFoundError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? MethodNotFoundError\n              : never)\n          | (errorObject['code'] extends InvalidParamsError['code']\n              ? InvalidParamsError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidParamsError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? BaseError\n              : never)\n      : parseError.ReturnType<ErrorObject>,\n  > = IsNever<error> extends true ? BaseError : error\n}\n\nexport type BaseErrorType = BaseError & { name: 'BaseError' }\n\n/** Thrown when a JSON-RPC error has occurred. */\nexport class BaseError extends Error {\n  override name = 'RpcResponse.BaseError'\n\n  override readonly cause: Error | undefined\n  override readonly stack: string\n  readonly code: number\n  readonly data?: unknown | undefined\n\n  constructor(\n    errorObject: ErrorObject & {\n      cause?: Error | undefined\n      stack?: string | undefined\n    },\n  ) {\n    const { cause, code, message, data, stack } = errorObject\n\n    super(message, { cause })\n\n    this.cause = cause\n    this.code = code\n    this.data = data\n    this.stack = stack ?? ''\n  }\n}\n\n/** Thrown when the input to a JSON-RPC method is invalid. */\nexport class InvalidInputError extends BaseError {\n  static readonly code = -32000\n  override readonly code = -32000\n  override readonly name = 'RpcResponse.InvalidInputError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidInputError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Missing or invalid parameters.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC resource is not found. */\nexport class ResourceNotFoundError extends BaseError {\n  static readonly code = -32001\n  override readonly code = -32001\n  override readonly name = 'RpcResponse.ResourceNotFoundError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ResourceNotFoundError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Requested resource not found.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC resource is unavailable. */\nexport class ResourceUnavailableError extends BaseError {\n  static readonly code = -32002\n  override readonly code = -32002\n  override readonly name = 'RpcResponse.ResourceUnavailableError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ResourceUnavailableError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Requested resource not available.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC transaction is rejected. */\nexport class TransactionRejectedError extends BaseError {\n  static readonly code = -32003\n  override readonly code = -32003\n  override readonly name = 'RpcResponse.TransactionRejectedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: TransactionRejectedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Transaction creation failed.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC method is not supported. */\nexport class MethodNotSupportedError extends BaseError {\n  static readonly code = -32004\n  override readonly code = -32004\n  override readonly name = 'RpcResponse.MethodNotSupportedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: MethodNotSupportedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Method is not implemented.',\n    })\n  }\n}\n\n/** Thrown when a rate-limit is exceeded. */\nexport class LimitExceededError extends BaseError {\n  static readonly code = -32005\n  override readonly code = -32005\n  override readonly name = 'RpcResponse.LimitExceededError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: LimitExceededError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Rate limit exceeded.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC version is not supported. */\nexport class VersionNotSupportedError extends BaseError {\n  static readonly code = -32006\n  override readonly code = -32006\n  override readonly name = 'RpcResponse.VersionNotSupportedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: VersionNotSupportedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'JSON-RPC version not supported.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC request is invalid. */\nexport class InvalidRequestError extends BaseError {\n  static readonly code = -32600\n  override readonly code = -32600\n  override readonly name = 'RpcResponse.InvalidRequestError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidRequestError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Input is not a valid JSON-RPC request.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC method is not found. */\nexport class MethodNotFoundError extends BaseError {\n  static readonly code = -32601\n  override readonly code = -32601\n  override readonly name = 'RpcResponse.MethodNotFoundError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: MethodNotFoundError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Method does not exist.',\n    })\n  }\n}\n\n/** Thrown when the parameters to a JSON-RPC method are invalid. */\nexport class InvalidParamsError extends BaseError {\n  static readonly code = -32602\n  override readonly code = -32602\n  override readonly name = 'RpcResponse.InvalidParamsError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidParamsError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Invalid method parameters.',\n    })\n  }\n}\n\n/** Thrown when an internal JSON-RPC error has occurred. */\nexport class InternalError extends BaseError {\n  static readonly code = -32603\n  override readonly code = -32603\n  override readonly name = 'RpcResponse.InternalError'\n\n  constructor(\n    parameters: Partial<Omit<ErrorObject, 'code'>> & {\n      cause?: Error | undefined\n      stack?: string | undefined\n    } = {},\n  ) {\n    super({\n      cause: parameters.cause,\n      code: InternalError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Internal JSON-RPC error.',\n      stack: parameters.stack,\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC response is invalid. */\nexport class ParseError extends BaseError {\n  static readonly code = -32700\n  override readonly code = -32700\n  override readonly name = 'RpcResponse.ParseError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ParseError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Failed to parse JSON-RPC response.',\n    })\n  }\n}\n", "import { EventEmitter } from 'eventemitter3'\nimport type * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport type { Compute, IsNarrowable, IsNever } from './internal/types.js'\nimport * as RpcResponse from './RpcResponse.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\n/** Options for a {@link ox#Provider.Provider}. */\nexport type Options = {\n  /**\n   * Whether to include event functions (`on`, `removeListener`) on the Provider.\n   *\n   * @default true\n   */\n  includeEvents?: boolean | undefined\n  /**\n   * RPC Schema to use for the Provider's `request` function.\n   * See {@link ox#RpcSchema.(from:function)} for more.\n   *\n   * @default `RpcSchema.Generic`\n   */\n  schema?: RpcSchema.Generic | undefined\n}\n\n/** Root type for an EIP-1193 Provider. */\nexport type Provider<\n  options extends Options | undefined = undefined,\n  ///\n  _schema extends RpcSchema.Generic = options extends {\n    schema: infer schema extends RpcSchema.Generic\n  }\n    ? schema\n    : RpcSchema.Default,\n> = Compute<\n  {\n    request: RequestFn<_schema>\n  } & (options extends { includeEvents: true } | undefined\n    ? {\n        on: EventListenerFn\n        removeListener: EventListenerFn\n      }\n    : {})\n>\n\n/** Type for an EIP-1193 Provider's event emitter. */\nexport type Emitter = Compute<EventEmitter<EventMap>>\n\n/** EIP-1193 Provider's `request` function. */\nexport type RequestFn<schema extends RpcSchema.Generic = RpcSchema.Generic> = <\n  methodName extends RpcSchema.MethodNameGeneric,\n>(\n  parameters: RpcSchema_internal.ExtractRequestOpaque<schema, methodName>,\n) => Promise<RpcSchema.ExtractReturnType<schema, methodName>>\n\n/** Type for an EIP-1193 Provider's event listener functions (`on`, `removeListener`, etc). */\nexport type EventListenerFn = <event extends keyof EventMap>(\n  event: event,\n  listener: EventMap[event],\n) => void\n\nexport type ConnectInfo = {\n  chainId: string\n}\n\nexport type Message = {\n  type: string\n  data: unknown\n}\n\nexport class ProviderRpcError extends Error {\n  override name = 'ProviderRpcError'\n\n  code: number\n  details: string\n\n  constructor(code: number, message: string) {\n    super(message)\n    this.code = code\n    this.details = message\n  }\n}\n\nexport type EventMap = {\n  accountsChanged: (accounts: readonly Address.Address[]) => void\n  chainChanged: (chainId: string) => void\n  connect: (connectInfo: ConnectInfo) => void\n  disconnect: (error: ProviderRpcError) => void\n  message: (message: Message) => void\n}\n\n/** The user rejected the request. */\nexport class UserRejectedRequestError extends ProviderRpcError {\n  static readonly code = 4001\n  override readonly code = 4001\n  override readonly name = 'Provider.UserRejectedRequestError'\n\n  constructor({\n    message = 'The user rejected the request.',\n  }: { message?: string | undefined } = {}) {\n    super(4001, message)\n  }\n}\n\n/** The requested method and/or account has not been authorized by the user. */\nexport class UnauthorizedError extends ProviderRpcError {\n  static readonly code = 4100\n  override readonly code = 4100\n  override readonly name = 'Provider.UnauthorizedError'\n\n  constructor({\n    message = 'The requested method and/or account has not been authorized by the user.',\n  }: { message?: string | undefined } = {}) {\n    super(4100, message)\n  }\n}\n\n/** The provider does not support the requested method. */\nexport class UnsupportedMethodError extends ProviderRpcError {\n  static readonly code = 4200\n  override readonly code = 4200\n  override readonly name = 'Provider.UnsupportedMethodError'\n\n  constructor({\n    message = 'The provider does not support the requested method.',\n  }: { message?: string | undefined } = {}) {\n    super(4200, message)\n  }\n}\n\n/** The provider is disconnected from all chains. */\nexport class DisconnectedError extends ProviderRpcError {\n  static readonly code = 4900\n  override readonly code = 4900\n  override readonly name = 'Provider.DisconnectedError'\n\n  constructor({\n    message = 'The provider is disconnected from all chains.',\n  }: { message?: string | undefined } = {}) {\n    super(4900, message)\n  }\n}\n\n/** The provider is not connected to the requested chain. */\nexport class ChainDisconnectedError extends ProviderRpcError {\n  static readonly code = 4901\n  override readonly code = 4901\n  override readonly name = 'Provider.ChainDisconnectedError'\n\n  constructor({\n    message = 'The provider is not connected to the requested chain.',\n  }: { message?: string | undefined } = {}) {\n    super(4901, message)\n  }\n}\n\n/** An error occurred when attempting to switch chain. */\nexport class SwitchChainError extends ProviderRpcError {\n  static readonly code = 4902\n  override readonly code = 4902\n  override readonly name = 'Provider.SwitchChainError'\n\n  constructor({\n    message = 'An error occurred when attempting to switch chain.',\n  }: { message?: string | undefined } = {}) {\n    super(4902, message)\n  }\n}\n\n/** This Wallet does not support a capability that was not marked as optional. */\nexport class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {\n  static readonly code = 5700\n  override readonly code = 5700\n  override readonly name = 'Provider.UnsupportedNonOptionalCapabilityError'\n\n  constructor({\n    message = 'This Wallet does not support a capability that was not marked as optional.',\n  }: { message?: string | undefined } = {}) {\n    super(5700, message)\n  }\n}\n\n/** This Wallet does not support the requested chain ID. */\nexport class UnsupportedChainIdError extends ProviderRpcError {\n  static readonly code = 5710\n  override readonly code = 5710\n  override readonly name = 'Provider.UnsupportedChainIdError'\n\n  constructor({\n    message = 'This Wallet does not support the requested chain ID.',\n  }: { message?: string | undefined } = {}) {\n    super(5710, message)\n  }\n}\n\n/** There is already a bundle submitted with this ID. */\nexport class DuplicateIdError extends ProviderRpcError {\n  static readonly code = 5720\n  override readonly code = 5720\n  override readonly name = 'Provider.DuplicateIdError'\n\n  constructor({\n    message = 'There is already a bundle submitted with this ID.',\n  }: { message?: string | undefined } = {}) {\n    super(5720, message)\n  }\n}\n\n/** This bundle id is unknown / has not been submitted. */\nexport class UnknownBundleIdError extends ProviderRpcError {\n  static readonly code = 5730\n  override readonly code = 5730\n  override readonly name = 'Provider.UnknownBundleIdError'\n\n  constructor({\n    message = 'This bundle id is unknown / has not been submitted.',\n  }: { message?: string | undefined } = {}) {\n    super(5730, message)\n  }\n}\n\n/** The call bundle is too large for the Wallet to process. */\nexport class BundleTooLargeError extends ProviderRpcError {\n  static readonly code = 5740\n  override readonly code = 5740\n  override readonly name = 'Provider.BundleTooLargeError'\n\n  constructor({\n    message = 'The call bundle is too large for the Wallet to process.',\n  }: { message?: string | undefined } = {}) {\n    super(5740, message)\n  }\n}\n\n/** The Wallet can support atomicity after an upgrade, but the user rejected the upgrade. */\nexport class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {\n  static readonly code = 5750\n  override readonly code = 5750\n  override readonly name = 'Provider.AtomicReadyWalletRejectedUpgradeError'\n\n  constructor({\n    message = 'The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.',\n  }: { message?: string | undefined } = {}) {\n    super(5750, message)\n  }\n}\n\n/** The wallet does not support atomic execution but the request requires it. */\nexport class AtomicityNotSupportedError extends ProviderRpcError {\n  static readonly code = 5760\n  override readonly code = 5760\n  override readonly name = 'Provider.AtomicityNotSupportedError'\n\n  constructor({\n    message = 'The wallet does not support atomic execution but the request requires it.',\n  }: { message?: string | undefined } = {}) {\n    super(5760, message)\n  }\n}\n\n/**\n * Creates an EIP-1193 flavored event emitter to be injected onto a Provider.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox' // [!code focus]\n *\n * // 1. Instantiate a Provider Emitter. // [!code focus]\n * const emitter = Provider.createEmitter() // [!code focus]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider. // [!code focus]\n *   ...emitter, // [!code focus]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events. // [!code focus]\n * emitter.emit('accountsChanged', ['0x...']) // [!code focus]\n * ```\n *\n * @returns An event emitter.\n */\nexport function createEmitter(): Emitter {\n  const emitter = new EventEmitter<EventMap>()\n\n  return {\n    get eventNames() {\n      return emitter.eventNames.bind(emitter)\n    },\n    get listenerCount() {\n      return emitter.listenerCount.bind(emitter)\n    },\n    get listeners() {\n      return emitter.listeners.bind(emitter)\n    },\n    addListener: emitter.addListener.bind(emitter),\n    emit: emitter.emit.bind(emitter),\n    off: emitter.off.bind(emitter),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter),\n    removeAllListeners: emitter.removeAllListeners.bind(emitter),\n    removeListener: emitter.removeListener.bind(emitter),\n  }\n}\n\nexport declare namespace createEmitter {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) {@link ox#Provider.Provider}\n * from an arbitrary [EIP-1193 Provider](https://eips.ethereum.org/EIPS/eip-1193) interface.\n *\n * @example\n * ### Instantiating with RPC Transport\n *\n * Ox's {@link ox#RpcTransport} is EIP-1193 compliant, and can be used to instantiate an EIP-1193 Provider. This means you can use any HTTP RPC endpoint as an EIP-1193 Provider.\n *\n * ```ts twoslash\n * import { Provider, RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n * const provider = Provider.from(transport)\n * ```\n *\n * @example\n * ### Instantiating with External Providers\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from an\n * external EIP-1193 Provider like `window.ethereum`.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider } from 'ox'\n *\n * const provider = Provider.from(window.ethereum)\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * :::tip\n *\n * There are also libraries that distribute EIP-1193 Provider objects that you can use with `Provider.from`:\n *\n * - [`@walletconnect/ethereum-provider`](https://www.npmjs.com/package/\\@walletconnect/ethereum-provider)\n *\n * - [`@coinbase/wallet-sdk`](https://www.npmjs.com/package/\\@coinbase/wallet-sdk)\n *\n * - [`@metamask/detect-provider`](https://www.npmjs.com/package/\\@metamask/detect-provider)\n *\n * - [`@safe-global/safe-apps-provider`](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-provider)\n *\n * - [`mipd`](https://github.com/wevm/mipd): EIP-6963 Multi Injected Providers\n *\n * :::\n *\n * @example\n * ### Instantiating a Custom Provider\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from a\n * HTTP `fetch` JSON-RPC request. You can use this pattern to integrate with any asynchronous JSON-RPC\n * transport, including WebSockets and IPC.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * @example\n * ### Type-safe Custom Schemas\n *\n * It is possible to define your own type-safe schema by using the {@link ox#RpcSchema.(from:function)} type.\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Provider, RpcSchema } from 'ox'\n *\n * const schema = RpcSchema.from<\n *   | RpcSchema.Default\n *   | {\n *       Request: {\n *         method: 'abe_foo',\n *         params: [id: number],\n *       }\n *       ReturnType: string\n *     }\n *   | {\n *       Request: {\n *         method: 'abe_bar',\n *         params: [id: string],\n *       }\n *       ReturnType: string\n *     }\n * >()\n *\n * const provider = Provider.from(window.ethereum, { schema })\n *\n * const blockNumber = await provider.request({ method: 'e' })\n * //                                                    ^|\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating a Provider with Events\n *\n * The example below demonstrates how to instantiate a Provider with your own EIP-1193 flavored event emitter.\n *\n * This example is useful for Wallets that distribute an EIP-1193 Provider (e.g. webpage injection via `window.ethereum`).\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Instantiate a Provider Emitter.\n * const emitter = Provider.createEmitter() // [!code ++]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider.\n *   ...emitter, // [!code ++]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events.\n * emitter.emit('accountsChanged', ['0x...']) // [!code ++]\n * ```\n *\n * @param provider - The EIP-1193 provider to convert.\n * @returns An typed EIP-1193 Provider.\n */\nexport function from<\n  const provider extends Provider | unknown,\n  options extends Options | undefined = undefined,\n>(\n  provider: provider | Provider<{ schema: RpcSchema.Generic }>,\n  options?: options | Options,\n): Provider<options>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(provider: any, options: Options = {}): Provider<Options> {\n  const { includeEvents = true } = options\n  if (!provider) throw new IsUndefinedError()\n  return {\n    ...(includeEvents\n      ? {\n          on: provider.on?.bind(provider),\n          removeListener: provider.removeListener?.bind(provider),\n        }\n      : {}),\n    async request(args) {\n      try {\n        const result = await provider.request(args)\n        if (\n          result &&\n          typeof result === 'object' &&\n          'jsonrpc' in (result as { jsonrpc?: unknown })\n        )\n          return RpcResponse.parse(result) as never\n        return result\n      } catch (error) {\n        throw parseError(error)\n      }\n    },\n  }\n}\n\nexport declare namespace from {\n  type ErrorType = IsUndefinedError | Errors.GlobalErrorType\n}\n\n/**\n * Parses an error into a Provider error instance.\n *\n * @example\n * ```ts twoslash\n * import { Provider } from 'ox'\n *\n * const error = Provider.parseError({ code: 4200, message: 'foo' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - The error object to parse.\n * @returns An error instance.\n */\nexport function parseError<\n  const error extends RpcResponse.ErrorObject | Error | unknown,\n>(\n  error: error | Error | RpcResponse.ErrorObject,\n): parseError.ReturnType<error> {\n  const error_ = RpcResponse.parseError(error)\n  if (error_ instanceof RpcResponse.InternalError) {\n    if (!error_.data) return error_ as never\n\n    const { code } = error_.data as RpcResponse.ErrorObject\n    if (code === DisconnectedError.code)\n      return new DisconnectedError(error_) as never\n    if (code === ChainDisconnectedError.code)\n      return new ChainDisconnectedError(error_) as never\n    if (code === UserRejectedRequestError.code)\n      return new UserRejectedRequestError(error_) as never\n    if (code === UnauthorizedError.code)\n      return new UnauthorizedError(error_) as never\n    if (code === UnsupportedMethodError.code)\n      return new UnsupportedMethodError(error_) as never\n    if (code === SwitchChainError.code)\n      return new SwitchChainError(error_) as never\n    if (code === AtomicReadyWalletRejectedUpgradeError.code)\n      return new AtomicReadyWalletRejectedUpgradeError(error_) as never\n    if (code === AtomicityNotSupportedError.code)\n      return new AtomicityNotSupportedError(error_) as never\n    if (code === BundleTooLargeError.code)\n      return new BundleTooLargeError(error_) as never\n    if (code === UnknownBundleIdError.code)\n      return new UnknownBundleIdError(error_) as never\n    if (code === DuplicateIdError.code)\n      return new DuplicateIdError(error_) as never\n    if (code === UnsupportedChainIdError.code)\n      return new UnsupportedChainIdError(error_) as never\n    if (code === UnsupportedNonOptionalCapabilityError.code)\n      return new UnsupportedNonOptionalCapabilityError(error_) as never\n  }\n  return error_ as never\n}\n\nexport declare namespace parseError {\n  type ReturnType<\n    errorObject extends RpcResponse.ErrorObject | unknown,\n    //\n    error = errorObject extends RpcResponse.ErrorObject\n      ?\n          | (errorObject['code'] extends DisconnectedError['code']\n              ? DisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? DisconnectedError\n              : never)\n          | (errorObject['code'] extends ChainDisconnectedError['code']\n              ? ChainDisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ChainDisconnectedError\n              : never)\n          | (errorObject['code'] extends UserRejectedRequestError['code']\n              ? UserRejectedRequestError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UserRejectedRequestError\n              : never)\n          | (errorObject['code'] extends UnauthorizedError['code']\n              ? UnauthorizedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnauthorizedError\n              : never)\n          | (errorObject['code'] extends UnsupportedMethodError['code']\n              ? UnsupportedMethodError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedMethodError\n              : never)\n          | (errorObject['code'] extends SwitchChainError['code']\n              ? SwitchChainError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? SwitchChainError\n              : never)\n          | (errorObject['code'] extends AtomicReadyWalletRejectedUpgradeError['code']\n              ? AtomicReadyWalletRejectedUpgradeError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? AtomicReadyWalletRejectedUpgradeError\n              : never)\n          | (errorObject['code'] extends AtomicityNotSupportedError['code']\n              ? AtomicityNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? AtomicityNotSupportedError\n              : never)\n          | (errorObject['code'] extends BundleTooLargeError['code']\n              ? BundleTooLargeError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? BundleTooLargeError\n              : never)\n          | (errorObject['code'] extends UnknownBundleIdError['code']\n              ? UnknownBundleIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnknownBundleIdError\n              : never)\n          | (errorObject['code'] extends DuplicateIdError['code']\n              ? DuplicateIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? DuplicateIdError\n              : never)\n          | (errorObject['code'] extends UnsupportedChainIdError['code']\n              ? UnsupportedChainIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedChainIdError\n              : never)\n          | (errorObject['code'] extends UnsupportedNonOptionalCapabilityError['code']\n              ? UnsupportedNonOptionalCapabilityError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedNonOptionalCapabilityError\n              : never)\n      : RpcResponse.parseError.ReturnType<RpcResponse.ErrorObject>,\n  > = IsNever<error> extends true\n    ? RpcResponse.parseError.ReturnType<errorObject>\n    : error\n}\n\n/** Thrown when the provider is undefined. */\nexport class IsUndefinedError extends Errors.BaseError {\n  override readonly name = 'Provider.IsUndefinedError'\n\n  constructor() {\n    super('`provider` is undefined.')\n  }\n}\n", "import { ens_normalize } from '@adraffy/ens-normalize'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as internal from './internal/ens.js'\n\n/**\n * Hashes ENS label.\n *\n * Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n * ```\n *\n * @param label - ENS label.\n * @returns ENS labelhash.\n */\nexport function labelhash(label: string) {\n  const result = new Uint8Array(32).fill(0)\n  if (!label) return Hex.fromBytes(result)\n  return (\n    internal.unwrapLabelhash(label) || Hash.keccak256(Hex.fromString(label))\n  )\n}\n\nexport declare namespace labelhash {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | internal.unwrapLabelhash.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Hashes ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.namehash('wevm.eth')\n * // @log: '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'\n * ```\n *\n * @param name - ENS name.\n * @returns ENS namehash.\n */\nexport function namehash(name: string) {\n  let result = new Uint8Array(32).fill(0)\n  if (!name) return Hex.fromBytes(result)\n\n  const labels = name.split('.')\n  // Iterate in reverse order building up hash\n  for (let i = labels.length - 1; i >= 0; i -= 1) {\n    const hashFromEncodedLabel = internal.unwrapLabelhash(labels[i]!)\n    const hashed = hashFromEncodedLabel\n      ? Bytes.fromHex(hashFromEncodedLabel)\n      : Hash.keccak256(Bytes.fromString(labels[i]!), { as: 'Bytes' })\n    result = Hash.keccak256(Bytes.concat(result, hashed), { as: 'Bytes' })\n  }\n\n  return Hex.fromBytes(result)\n}\n\nexport declare namespace namehash {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | internal.unwrapLabelhash.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Bytes.concat.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Normalizes ENS name according to [ENSIP-15](https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md).\n *\n * For more info see [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) on name processing.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.normalize('wevm.eth')\n * // @log: 'wevm.eth'\n * ```\n *\n * @param name - ENS name.\n * @returns Normalized ENS name.\n */\nexport function normalize(name: string): string {\n  return ens_normalize(name)\n}\n\nexport declare namespace normalize {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Ens from 'ox/Ens'\nimport type { ErrorType } from '../../errors/utils.js'\n\nexport type NormalizeErrorType = ErrorType\n\n/**\n * @description Normalizes ENS name according to ENSIP-15.\n *\n * @example\n * normalize('wevm.eth')\n * 'wevm.eth'\n *\n * @see https://docs.ens.domains/contract-api-reference/name-processing#normalising-names\n * @see https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md\n */\nexport function normalize(name: string) {\n  return Ens.normalize(name)\n}\n", null, null],
  "mappings": "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",
  "names": ["themeMode", "themeVariables", "Fp", "Fr", "Fp2", "Fp6", "Fp12", "y", "getPublicKey", "msg", "_0n", "_1n", "_2n", "_3n", "Fp", "Fp2", "y", "y2", "G2psi", "G2psi2", "concatBytes", "Fp6", "Fp4Square", "Fp12", "_0n", "_1n", "_2n", "_3n", "z", "y", "concatBytes", "x", "from", "_0n", "_1n", "_2n", "Fp", "randomBytes", "y", "y2", "uvRatio", "adjustScalarBytes", "z", "G", "cofactor", "getPublicKey", "concatBytes", "_0n", "_1n", "_2n", "validateOpts", "adjustScalarBytes", "_0n", "_1n", "_2n", "_3n", "_8n", "Fp", "_8n", "_3n", "Fp", "_3n", "_8n", "_2n", "y", "_1n", "mod", "_0n", "z", "abool", "abytes", "aexists", "aoutput", "abytes", "u8", "u32", "clean", "utf8ToBytes", "toBytes", "utf8ToBytes", "concatBytes", "abytes", "equalBytes", "abytes", "isLE", "abool", "u32", "toBytes", "abytes", "aexists", "clean", "aoutput", "BLOCK_SIZE", "POLY", "mul2", "clean", "sbox", "sbox2", "abytes", "u32", "t0", "t1", "t2", "t3", "ctr", "i", "u8", "isLE", "equalBytes", "abytes", "u32", "ctr", "concatBytes", "equalBytes", "BaseError", "normalize", "ConstantsUtil", "normalize", "modal"]
}
